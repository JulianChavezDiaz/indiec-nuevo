{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport { Animation, compile as templateComplier, Browser } from '@syncfusion/ej2-base';\nimport { merge, extend, isNullOrUndefined, resetBlazorTemplate } from '@syncfusion/ej2-base';\nimport { createElement, remove } from '@syncfusion/ej2-base';\nimport { Index } from '../../common/model/base';\nimport { VisibleLabels } from '../../chart/axis/axis';\nimport { axisLabelRender, regSub } from '../model/constants';\nimport { measureText, Rect, TextOption, Size, PathOption, SvgRenderer, CanvasRenderer } from '@syncfusion/ej2-svg-base';\n/**\r\n * Function to sort the dataSource, by default it sort the data in ascending order.\r\n *\r\n * @param  {Object} data chart data\r\n * @param  {string} fields date fields\r\n * @param  {boolean} isDescending boolean values of descending\r\n * @returns {Object[]} It returns chart data which be sorted.\r\n */\nexport function sort(data, fields, isDescending) {\n  var sortData = extend([], data, null);\n  for (var i = 0; i < sortData.length; i++) {\n    for (var j = 0; j < fields.length; j++) {\n      if (sortData[i][fields[j]] instanceof Date) {\n        sortData[i][fields[j]] = sortData[i][fields[j]].getTime();\n      }\n    }\n  }\n  sortData.sort(function (a, b) {\n    var first = 0;\n    var second = 0;\n    for (var i = 0; i < fields.length; i++) {\n      first += a[fields[i]];\n      second += b[fields[i]];\n    }\n    if (!isDescending && first < second || isDescending && first > second) {\n      return -1;\n    } else if (first === second) {\n      return 0;\n    }\n    return 1;\n  });\n  return sortData;\n}\n/**\r\n * Checks if a label contains a line break.\r\n *\r\n * @param {string} label - The label to check.\r\n * @returns {boolean} - True if the label contains a line break, otherwise false.\r\n */\nexport function isBreakLabel(label) {\n  return label.indexOf('<br>') !== -1;\n}\n/**\r\n * Retrieves the visible data points from a series.\r\n *\r\n * @param {Series | Chart3DSeries} series - The series to retrieve the visible data points.\r\n * @returns {Points[]} - An array containing the visible data points.\r\n */\nexport function getVisiblePoints(series) {\n  var points = extend([], series.points, null, true);\n  var tempPoints = [];\n  var tempPoint;\n  var pointIndex = 0;\n  for (var i = 0; i < points.length; i++) {\n    tempPoint = points[i];\n    if (isNullOrUndefined(tempPoint.x)) {\n      continue;\n    } else {\n      tempPoint.index = pointIndex++;\n      tempPoints.push(tempPoint);\n    }\n  }\n  return tempPoints;\n}\n/**\r\n * Rotates the size of text based on the provided angle.\r\n *\r\n * @param {FontModel} font - The font style of the text.\r\n * @param {string} text - The text to be rotated.\r\n * @param {number} angle - The angle of rotation.\r\n * @param {Chart | Chart3D} chart - The chart instance.\r\n * @param {FontModel} themeFontStyle - The font style based on the theme.\r\n * @returns {Size} - The rotated size of the text.\r\n */\nexport function rotateTextSize(font, text, angle, chart, themeFontStyle) {\n  var transformValue = chart.element.style.transform;\n  if (transformValue) {\n    chart.element.style.transform = '';\n  }\n  var renderer = new SvgRenderer(chart.element.id);\n  var labelText;\n  var textCollection = [];\n  var height;\n  var dy;\n  var label;\n  var tspanElement;\n  var options = {\n    id: 'rotate_text',\n    x: chart.initialClipRect.x,\n    y: chart.initialClipRect.y,\n    'font-size': font.size || themeFontStyle.size,\n    'font-style': font.fontStyle || themeFontStyle.fontStyle,\n    'font-family': font.fontFamily,\n    'font-weight': font.fontWeight || themeFontStyle.fontWeight,\n    'transform': 'rotate(' + angle + ', 0, 0)',\n    'text-anchor': 'middle'\n  };\n  if (isBreakLabel(text)) {\n    textCollection = text.split('<br>');\n    labelText = textCollection[0];\n  } else {\n    labelText = text;\n  }\n  var htmlObject = renderer.createText(options, labelText);\n  if (!chart.delayRedraw && !chart.redraw && !chart.stockChart) {\n    chart.element.appendChild(chart.svgObject);\n  }\n  // for line break label\n  if (typeof textCollection !== 'string' && textCollection.length > 1) {\n    for (var i = 1, len = textCollection.length; i < len; i++) {\n      height = measureText(textCollection[i], font, chart.themeStyle.axisLabelFont).height;\n      dy = options.y + i * height;\n      label = textCollection[i];\n      tspanElement = renderer.createTSpan({\n        'x': options.x,\n        'id': options.id,\n        'y': dy\n      }, label);\n      htmlObject.appendChild(tspanElement);\n    }\n  }\n  var axisSvgObject = chart.svgRenderer.createSvg({\n    id: 'AxisLabelMax_svg'\n  });\n  if (chart.element.parentElement.style.transform.indexOf('scale') > -1) {\n    document.body.appendChild(axisSvgObject);\n    axisSvgObject.appendChild(htmlObject);\n  } else {\n    chart.svgObject.appendChild(htmlObject);\n  }\n  var box = htmlObject.getBoundingClientRect();\n  if (transformValue) {\n    chart.element.style.transform = transformValue;\n  }\n  if (chart.element.parentElement.style.transform.indexOf('scale') > -1) {\n    remove(axisSvgObject);\n  } else {\n    remove(htmlObject);\n  }\n  if (!chart.delayRedraw && !chart.redraw && !chart.stockChart && !chart.pointsAdded) {\n    remove(chart.svgObject);\n  }\n  if (chart.enableCanvas) {\n    var textWidth = measureText(text, font, chart.themeStyle.axisLabelFont).width;\n    var textHeight = measureText(text, font, chart.themeStyle.axisLabelFont).height;\n    var angleInRadians = angle * Math.PI / 180; // Convert the rotation angle to radians\n    var rotatedTextWidth = Math.abs(Math.cos(angleInRadians) * textWidth) + Math.abs(Math.sin(angleInRadians) * textHeight);\n    var rotatedTextHeight = Math.abs(Math.sin(angleInRadians) * textWidth) + Math.abs(Math.cos(angleInRadians) * textHeight);\n    return new Size(rotatedTextWidth, rotatedTextHeight);\n  }\n  return new Size(box.right - box.left, box.bottom - box.top);\n}\n/**\r\n * Removes the specified element.\r\n *\r\n * @param {string | Element} id - The id or reference of the element to be removed.\r\n * @returns {void}\r\n */\nexport function removeElement(id) {\n  if (!id) {\n    return null;\n  }\n  var element = typeof id === 'string' ? getElement(id) : id;\n  if (element) {\n    remove(element);\n  }\n}\n/**\r\n * Calculates the logarithm of a specified value with respect to a specified base.\r\n *\r\n * @param {number} value - The value for which to calculate the logarithm.\r\n * @param {number} base - The base of the logarithm.\r\n * @returns {number} - The logarithm of the value with respect to the specified base.\r\n */\nexport function logBase(value, base) {\n  return Math.log(value) / Math.log(base);\n}\n/**\r\n * Displays a tooltip at the specified coordinates with the given text.\r\n *\r\n * @param {string} text - The text content of the tooltip.\r\n * @param {number} x - The x-coordinate where the tooltip should be displayed.\r\n * @param {number} y - The y-coordinate where the tooltip should be displayed.\r\n * @param {number} areaWidth - The width of the area where the tooltip is displayed.\r\n * @param {string} id - The id of the tooltip element.\r\n * @param {Element} element - The element to which the tooltip is appended.\r\n * @param {boolean} isTouch - Indicates whether the tooltip is displayed on a touch device.\r\n * @param {boolean} isTitleOrLegendEnabled - Indicates whether the tooltip is enabled for title or legend.\r\n * @returns {void}\r\n */\nexport function showTooltip(text, x, y, areaWidth, id, element, isTouch, isTitleOrLegendEnabled, bound) {\n  //let id1: string = 'EJ2_legend_tooltip';\n  var tooltip = document.getElementById(id);\n  var size = measureText(text, {\n    fontFamily: 'Segoe UI',\n    size: '12px',\n    fontStyle: 'Normal',\n    fontWeight: 'Regular'\n  });\n  var width = size.width + 5;\n  x = x + width > areaWidth ? x - (width + 15) : x;\n  if (bound && x < bound.x) {\n    x = bound.x;\n  }\n  y = isTitleOrLegendEnabled ? y - size.height / 2 : y + 15;\n  if (!tooltip) {\n    tooltip = createElement('div', {\n      id: id,\n      styles: 'top:' + y.toString() + 'px;left:' + (x + 15).toString() + 'px;background-color: rgb(255, 255, 255) !important; color:black !important; ' + 'position:absolute;border:1px solid rgb(112, 112, 112); padding-left : 3px; padding-right : 2px;' + 'padding-bottom : 2px; padding-top : 2px; font-size:12px; font-family: \"Segoe UI\"'\n    });\n    tooltip.innerText = text;\n    element.appendChild(tooltip);\n    var left = parseInt(tooltip.style.left.replace('px', ''), 10);\n    if (left < 0) {\n      tooltip.style.left = '0px';\n    }\n  } else {\n    tooltip.innerText = text;\n    tooltip.style.top = y.toString() + 'px';\n    tooltip.style.left = (x + 15).toString() + 'px';\n  }\n  if (isTouch) {\n    setTimeout(function () {\n      removeElement(id);\n    }, 1500);\n  }\n}\n/**\r\n * Checks if a value is within the specified range.\r\n *\r\n * @param {number} value - The value to check.\r\n * @param {VisibleRangeModel} range - The range to check against.\r\n * @returns {boolean} - True if the value is inside the range, otherwise false.\r\n */\nexport function inside(value, range) {\n  return value < range.max && value > range.min;\n}\n/**\r\n * Checks if a value is within the specified range.\r\n *\r\n * @param {number} value - The value to check.\r\n * @param {VisibleRangeModel} range - The range to check against.\r\n * @returns {boolean} - True if the value is inside the range, otherwise false.\r\n */\nexport function withIn(value, range) {\n  return value <= range.max && value >= range.min;\n}\n/**\r\n * Adjusts the value based on the axis type.\r\n *\r\n * @param {number} value - The value to adjust.\r\n * @param {Axis} axis - The axis used for adjustment.\r\n * @returns {number} - The adjusted value.\r\n */\nexport function logWithIn(value, axis) {\n  return axis.valueType === 'Logarithmic' ? logBase(value, axis.logBase) : value;\n}\n/**\r\n * Checks if a point is within the range of the previous and next points in a series.\r\n *\r\n * @param {Points} previousPoint - The previous point in the series.\r\n * @param {Points} currentPoint - The current point to check.\r\n * @param {Points} nextPoint - The next point in the series.\r\n * @param {Series} series - The series to which the points belong.\r\n * @returns {boolean} - A boolean indicating if the point is within the range.\r\n */\nexport function withInRange(previousPoint, currentPoint, nextPoint, series) {\n  var mX2 = logWithIn(currentPoint.xValue, series.xAxis);\n  var mX1 = previousPoint ? logWithIn(previousPoint.xValue, series.xAxis) : mX2;\n  var mX3 = nextPoint ? logWithIn(nextPoint.xValue, series.xAxis) : mX2;\n  var xStart = Math.floor(series.xAxis.visibleRange.min);\n  var xEnd = Math.ceil(series.xAxis.visibleRange.max);\n  return mX1 >= xStart && mX1 <= xEnd || mX2 >= xStart && mX2 <= xEnd || mX3 >= xStart && mX3 <= xEnd || xStart >= mX1 && xStart <= mX3;\n}\n/**\r\n * Calculates the sum of an array of numbers.\r\n *\r\n * @param {number[]} values - An array of numbers.\r\n * @returns {number} - The sum of the numbers in the array.\r\n */\nexport function sum(values) {\n  var sum = 0;\n  for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n    var value = values_1[_i];\n    sum += value;\n  }\n  return sum;\n}\n/**\r\n * Calculates the sum of elements in a subarray.\r\n *\r\n * @param {Object[]} values - The array containing elements.\r\n * @param {number} first - The index of the first element in the subarray.\r\n * @param {number} last - The index of the last element in the subarray.\r\n * @param {number[]} index - The array of indices.\r\n * @param {Series} series - The series object.\r\n * @returns {number} - The sum of elements in the subarray.\r\n */\nexport function subArraySum(values, first, last, index, series) {\n  var sum = 0;\n  if (index !== null) {\n    for (var i = first + 1; i < last; i++) {\n      if (index.indexOf(i) === -1) {\n        sum += values[i][series.yName];\n      }\n    }\n  } else {\n    for (var i = first + 1; i < last; i++) {\n      if (!isNullOrUndefined(values[i][series.yName])) {\n        sum += values[i][series.yName];\n      }\n    }\n  }\n  return sum;\n}\n/**\r\n * Subtracts thickness from the given rectangle.\r\n *\r\n * @param {Rect} rect - The rectangle from which to subtract thickness.\r\n * @param {Thickness} thickness - The thickness to subtract.\r\n * @returns {Rect} - The resulting rectangle after subtracting thickness.\r\n */\nexport function subtractThickness(rect, thickness) {\n  rect.x += thickness.left;\n  rect.y += thickness.top;\n  rect.width -= thickness.left + thickness.right;\n  rect.height -= thickness.top + thickness.bottom;\n  return rect;\n}\n/**\r\n * Subtracts a rectangle representing thickness from the given rectangle.\r\n *\r\n * @param {Rect} rect - The rectangle from which to subtract the thickness rectangle.\r\n * @param {Thickness} thickness - The rectangle representing the thickness to subtract.\r\n * @returns {Rect} - The resulting rectangle after subtracting the thickness rectangle.\r\n */\nexport function subtractRect(rect, thickness) {\n  rect.x += thickness.x;\n  rect.y += thickness.y;\n  rect.width -= thickness.x + thickness.width;\n  rect.height -= thickness.y + thickness.height;\n  return rect;\n}\n/**\r\n * Converts a degree value to a location on the chart based on the provided radius and center point.\r\n *\r\n * @param {number} degree - The degree value to convert.\r\n * @param {number} radius - The radius from the center point.\r\n * @param {ChartLocation} center - The center point of the chart.\r\n * @returns {ChartLocation} - The location on the chart corresponding to the degree value.\r\n */\nexport function degreeToLocation(degree, radius, center) {\n  var radian = degree * Math.PI / 180;\n  return new ChartLocation(Math.cos(radian) * radius + center.x, Math.sin(radian) * radius + center.y);\n}\n/**\r\n * Converts a degree value to radians.\r\n *\r\n * @param {number} degree - The degree value to convert.\r\n * @returns {number} - The equivalent value in radians.\r\n */\nexport function degreeToRadian(degree) {\n  return degree * (Math.PI / 180);\n}\n/**\r\n * Get the coordinates of a rotated rectangle.\r\n *\r\n * @param {ChartLocation[]} actualPoints - The coordinates of the original rectangle.\r\n * @param {number} centerX - The x-coordinate of the center of rotation.\r\n * @param {number} centerY - The y-coordinate of the center of rotation.\r\n * @param {number} angle - The angle of rotation in degrees.\r\n * @returns {ChartLocation[]} - The coordinates of the rotated rectangle.\r\n */\nexport function getRotatedRectangleCoordinates(actualPoints, centerX, centerY, angle) {\n  var coordinatesAfterRotation = [];\n  for (var i = 0; i < 4; i++) {\n    var point = actualPoints[i];\n    // translate point to origin\n    var tempX = point.x - centerX;\n    var tempY = point.y - centerY;\n    // now apply rotation\n    var rotatedX = tempX * Math.cos(degreeToRadian(angle)) - tempY * Math.sin(degreeToRadian(angle));\n    var rotatedY = tempX * Math.sin(degreeToRadian(angle)) + tempY * Math.cos(degreeToRadian(angle));\n    // translate back\n    point.x = rotatedX + centerX;\n    point.y = rotatedY + centerY;\n    coordinatesAfterRotation.push(new ChartLocation(point.x, point.y));\n  }\n  return coordinatesAfterRotation;\n}\n/**\r\n * Helper function to determine whether there is an intersection between the two polygons described\r\n * by the lists of vertices. Uses the Separating Axis Theorem.\r\n *\r\n * @param {ChartLocation[]} a an array of connected points [{x:, y:}, {x:, y:},...] that form a closed polygon\r\n * @param {ChartLocation[]} b an array of connected points [{x:, y:}, {x:, y:},...] that form a closed polygon\r\n * @returns {boolean} if there is any intersection between the 2 polygons, false otherwise\r\n */\nexport function isRotatedRectIntersect(a, b) {\n  var polygons = [a, b];\n  var minA;\n  var maxA;\n  var projected;\n  var i;\n  var i1;\n  var j;\n  var minB;\n  var maxB;\n  for (i = 0; i < polygons.length; i++) {\n    // for each polygon, look at each edge of the polygon, and determine if it separates\n    // the two shapes\n    var polygon = polygons[i];\n    for (i1 = 0; i1 < polygon.length; i1++) {\n      // grab 2 vertices to create an edge\n      var i2 = (i1 + 1) % polygon.length;\n      var p1 = polygon[i1];\n      var p2 = polygon[i2];\n      // find the line perpendicular to this edge\n      var normal = new ChartLocation(p2.y - p1.y, p1.x - p2.x);\n      minA = maxA = undefined;\n      // for each vertex in the first shape, project it onto the line perpendicular to the edge\n      // and keep track of the min and max of these values\n      for (j = 0; j < a.length; j++) {\n        projected = normal.x * a[j].x + normal.y * a[j].y;\n        if (isNullOrUndefined(minA) || projected < minA) {\n          minA = projected;\n        }\n        if (isNullOrUndefined(maxA) || projected > maxA) {\n          maxA = projected;\n        }\n      }\n      // for each vertex in the second shape, project it onto the line perpendicular to the edge\n      // and keep track of the min and max of these values\n      minB = maxB = undefined;\n      for (j = 0; j < b.length; j++) {\n        projected = normal.x * b[j].x + normal.y * b[j].y;\n        if (isNullOrUndefined(minB) || projected < minB) {\n          minB = projected;\n        }\n        if (isNullOrUndefined(maxB) || projected > maxB) {\n          maxB = projected;\n        }\n      }\n      // if there is no overlap between the projects, the edge we are looking at separates the two\n      // polygons, and we know there is no overlap\n      if (maxA < minB || maxB < minA) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n/**\r\n * Generates the legend for accumulation chart.\r\n *\r\n * @param {number} locX - The x-coordinate of the legend position.\r\n * @param {number} locY - The y-coordinate of the legend position.\r\n * @param {number} r - The radius of the chart.\r\n * @param {number} height - The height of the legend.\r\n * @param {number} width - The width of the legend.\r\n * @returns {string} - The generated legend.\r\n */\nfunction getAccumulationLegend(locX, locY, r, height, width) {\n  var cartesianlarge = degreeToLocation(270, r, new ChartLocation(locX, locY));\n  var cartesiansmall = degreeToLocation(270, r, new ChartLocation(locX + width / 10, locY));\n  return 'M' + ' ' + locX + ' ' + locY + ' ' + 'L' + ' ' + (locX + r) + ' ' + locY + ' ' + 'A' + ' ' + r + ' ' + r + ' ' + 0 + ' ' + 1 + ' ' + 1 + ' ' + cartesianlarge.x + ' ' + cartesianlarge.y + ' ' + 'Z' + ' ' + 'M' + ' ' + (locX + width / 10) + ' ' + (locY - height / 10) + ' ' + 'L' + (locX + r) + ' ' + (locY - height / 10) + ' ' + 'A' + ' ' + r + ' ' + r + ' ' + 0 + ' ' + 0 + ' ' + 0 + ' ' + cartesiansmall.x + ' ' + cartesiansmall.y + ' ' + 'Z';\n}\n/**\r\n * Calculates the angle between two points.\r\n *\r\n * @param {ChartLocation} center - The center point.\r\n * @param {ChartLocation} point - The point to calculate the angle from the center.\r\n * @returns {number} - The angle in degrees.\r\n */\nexport function getAngle(center, point) {\n  var angle = Math.atan2(point.y - center.y, point.x - center.x);\n  angle = angle < 0 ? 6.283 + angle : angle;\n  return angle * (180 / Math.PI);\n}\n/**\r\n * Returns a sub-array of values starting from the specified index.\r\n *\r\n * @param {number[]} values - The array of numbers.\r\n * @param {number} index - The index from which the sub-array starts.\r\n * @returns {number[]} - The sub-array of values.\r\n */\nexport function subArray(values, index) {\n  var subArray = [];\n  for (var i = 0; i <= index - 1; i++) {\n    subArray.push(values[i]);\n  }\n  return subArray;\n}\n/**\r\n * Converts a value to its corresponding coefficient based on the axis range.\r\n *\r\n * @param {number} value - The value to be converted.\r\n * @param {Axis} axis - The axis object containing range information.\r\n * @returns {number} - The coefficient value corresponding to the input value.\r\n */\nexport function valueToCoefficient(value, axis) {\n  var range = axis.visibleRange;\n  var result = (value - range.min) / range.delta;\n  var isInverse = axis.isChart ? axis.isAxisInverse : axis.isInversed;\n  return isInverse ? 1 - result : result;\n}\n/**\r\n * Transforms a point to its visible position based on the axes range and inversion.\r\n *\r\n * @param {number} x - The x-coordinate of the point.\r\n * @param {number} y - The y-coordinate of the point.\r\n * @param {Axis} xAxis - The x-axis object containing range information.\r\n * @param {Axis} yAxis - The y-axis object containing range information.\r\n * @param {boolean} [isInverted=false] - Specifies if the chart is inverted.\r\n * @param {Series} [series] - The series object for additional information (optional).\r\n * @returns {ChartLocation} - The transformed visible position of the point.\r\n */\nexport function TransformToVisible(x, y, xAxis, yAxis, isInverted, series) {\n  x = xAxis.valueType === 'Logarithmic' ? logBase(x > 1 ? x : 1, xAxis.logBase) : x;\n  y = yAxis.valueType === 'Logarithmic' ? logBase(y > 1 ? y : 1, yAxis.logBase) : y;\n  x += xAxis.valueType === 'Category' && xAxis.labelPlacement === 'BetweenTicks' && series.type !== 'Radar' ? 0.5 : 0;\n  var radius = series.chart.radius * valueToCoefficient(y, yAxis);\n  var point = CoefficientToVector(valueToPolarCoefficient(x, xAxis), series.chart.primaryXAxis.startAngle);\n  return {\n    x: series.clipRect.width / 2 + series.clipRect.x + radius * point.x,\n    y: series.clipRect.height / 2 + series.clipRect.y + radius * point.y\n  };\n}\n/**\r\n * Finds the index from the given id.\r\n *\r\n * @param {string} id - The id to search for.\r\n * @param {boolean} [isPoint=false] - Specifies if the id represents a data point (optional).\r\n * @returns {Index} - The index found from the id.\r\n */\nexport function indexFinder(id, isPoint) {\n  if (isPoint === void 0) {\n    isPoint = false;\n  }\n  var ids = ['NaN', 'NaN'];\n  if (id.indexOf('_Point_') > -1) {\n    ids = id.split('_Series_')[1].split('_Point_');\n  } else if (id.indexOf('_shape_') > -1 && (!isPoint || isPoint && id.indexOf('_legend_') === -1)) {\n    ids = id.split('_shape_');\n    ids[0] = '0';\n  } else if (id.indexOf('_text_') > -1 && (!isPoint || isPoint && id.indexOf('_legend_') === -1)) {\n    ids = id.split('_text_');\n    ids[0] = '0';\n  }\n  return new Index(parseInt(ids[0], 10), parseInt(ids[1], 10));\n}\n/**\r\n * Converts a coefficient value to a vector representing a point on the circumference of a circle.\r\n *\r\n * @param {number} coefficient - The coefficient value to convert.\r\n * @param {number} startAngle - The starting angle of the circle.\r\n * @returns {ChartLocation} - The vector representing the point on the circle.\r\n */\nexport function CoefficientToVector(coefficient, startAngle) {\n  startAngle = startAngle < 0 ? startAngle + 360 : startAngle;\n  var angle = Math.PI * (1.5 - 2 * coefficient);\n  angle = angle + startAngle * Math.PI / 180;\n  return {\n    x: Math.cos(angle),\n    y: Math.sin(angle)\n  };\n}\n/**\r\n * Converts a value to a polar coefficient value based on the axis.\r\n *\r\n * @param {number} value - The value to convert.\r\n * @param {Axis} axis - The axis object.\r\n * @returns {number} - The polar coefficient value.\r\n */\nexport function valueToPolarCoefficient(value, axis) {\n  var range = axis.visibleRange;\n  var delta;\n  var length;\n  if (axis.valueType !== 'Category') {\n    delta = range.max - (axis.valueType === 'DateTime' ? axis.dateTimeInterval : range.interval) - range.min;\n    length = axis.visibleLabels.length - 1;\n    delta = delta === 0 ? 1 : delta;\n  } else {\n    // To split an interval equally based on visible labels count\n    delta = axis.visibleLabels.length === 1 ? 1 : axis.visibleLabels[axis.visibleLabels.length - 1].value - axis.visibleLabels[0].value;\n    length = axis.visibleLabels.length;\n  }\n  return axis.isAxisInverse ? (value - range.min) / delta * (1 - 1 / length) : 1 - (value - range.min) / delta * (1 - 1 / length);\n}\n/** @private */\nvar Mean = /** @class */function () {\n  function Mean(verticalStandardMean, verticalSquareRoot, horizontalStandardMean, horizontalSquareRoot, verticalMean, horizontalMean) {\n    this.verticalStandardMean = verticalStandardMean;\n    this.horizontalStandardMean = horizontalStandardMean;\n    this.verticalSquareRoot = verticalSquareRoot;\n    this.horizontalSquareRoot = horizontalSquareRoot;\n    this.verticalMean = verticalMean;\n    this.horizontalMean = horizontalMean;\n  }\n  return Mean;\n}();\nexport { Mean };\n/** @private */\nvar PolarArc = /** @class */function () {\n  function PolarArc(startAngle, endAngle, innerRadius, radius, currentXPosition) {\n    this.startAngle = startAngle;\n    this.endAngle = endAngle;\n    this.innerRadius = innerRadius;\n    this.radius = radius;\n    this.currentXPosition = currentXPosition;\n  }\n  return PolarArc;\n}();\nexport { PolarArc };\n/**\r\n * Creates a tooltip element with the specified id, text, position, and font size.\r\n *\r\n * @param {string} id - The id of the tooltip element.\r\n * @param {string} text - The text content of the tooltip.\r\n * @param {number} top - The top position of the tooltip.\r\n * @param {number} left - The left position of the tooltip.\r\n * @param {string} fontSize - The font size of the tooltip text.\r\n * @returns {void}\r\n */\nexport function createTooltip(id, text, top, left, fontSize) {\n  var tooltip = getElement(id);\n  var style = 'top:' + top.toString() + 'px;' + 'left:' + left.toString() + 'px;' + 'color:black !important; ' + 'background:#FFFFFF !important; ' + 'position:absolute;border:1px solid #707070;font-size:' + fontSize + ';border-radius:2px; z-index:1';\n  if (!tooltip) {\n    tooltip = createElement('div', {\n      id: id,\n      innerHTML: '&nbsp;' + text + '&nbsp;',\n      styles: style\n    });\n    document.body.appendChild(tooltip);\n  } else {\n    tooltip.setAttribute('innerHTML', '&nbsp;' + text + '&nbsp;');\n    tooltip.setAttribute('styles', style);\n  }\n}\n/**\r\n * Creates zooming labels for the specified axis and adds them to the parent element.\r\n *\r\n * @param {Chart} chart - The chart instance.\r\n * @param {Axis} axis - The axis for which to create zooming labels.\r\n * @param {Element} parent - The parent element to which the labels will be appended.\r\n * @param {number} index - The index of the label.\r\n * @param {boolean} isVertical - Indicates whether the axis is vertical.\r\n * @param {Rect} rect - The bounding rectangle of the label.\r\n * @returns {Element} - The created zooming label element.\r\n */\nexport function createZoomingLabels(chart, axis, parent, index, isVertical, rect) {\n  var margin = 5;\n  var opposedPosition = axis.isAxisOpposedPosition;\n  var anchor = chart.enableRtl ? 'end' : isVertical ? 'start' : 'auto';\n  var size;\n  var chartRect = chart.availableSize.width;\n  var pathElement;\n  var x;\n  var y;\n  var rx = 3;\n  var arrowLocation;\n  var direction;\n  var scrollBarHeight = axis.scrollbarSettings.enable || axis.zoomingScrollBar && axis.zoomingScrollBar.svgObject ? axis.scrollBarHeight : 0;\n  var isRtlEnabled = chart.enableRtl && !isVertical && !axis.isInversed || axis.isInversed && !(chart.enableRtl && !isVertical);\n  for (var i = 0; i < 2; i++) {\n    size = measureText(i ? isRtlEnabled ? axis.startLabel : axis.endLabel : isRtlEnabled ? axis.endLabel : axis.startLabel, axis.labelStyle, chart.themeStyle.axisLabelFont);\n    if (isVertical) {\n      arrowLocation = i ? new ChartLocation(rect.x - scrollBarHeight, rect.y + rx) : new ChartLocation(axis.rect.x - scrollBarHeight, rect.y + rect.height - rx);\n      x = rect.x + (opposedPosition ? rect.width + margin + scrollBarHeight : -(size.width + margin + margin + scrollBarHeight));\n      y = rect.y + (i ? 0 : rect.height - size.height - margin);\n      x += x < 0 || chartRect < x + size.width + margin ? opposedPosition ? -(size.width / 2) : size.width / 2 : 0;\n      direction = findCrosshairDirection(rx, rx, new Rect(x, y, size.width + margin, size.height + margin), arrowLocation, margin, false, false, !opposedPosition, arrowLocation.x, arrowLocation.y + (i ? -rx : rx));\n    } else {\n      arrowLocation = i ? new ChartLocation(rect.x + rect.width - rx, rect.y + rect.height + scrollBarHeight) : new ChartLocation(rect.x + rx, rect.y + rect.height + scrollBarHeight);\n      x = rect.x + (i ? rect.width - size.width - margin : 0);\n      y = opposedPosition ? rect.y - size.height - 10 - scrollBarHeight : rect.y + rect.height + margin + scrollBarHeight;\n      direction = findCrosshairDirection(rx, rx, new Rect(x, y, size.width + margin, size.height + margin), arrowLocation, margin, opposedPosition, !opposedPosition, false, arrowLocation.x + (i ? rx : -rx), arrowLocation.y);\n    }\n    x = x + margin / 2;\n    y = y + 3 * (size.height / 4) + margin / 2;\n    pathElement = chart.renderer.drawPath({\n      'id': chart.element.id + '_Zoom_' + index + '_AxisLabel_Shape_' + i,\n      'fill': chart.themeStyle.crosshairFill,\n      'width': 2,\n      'color': chart.themeStyle.crosshairFill,\n      'opacity': 1,\n      'stroke-dasharray': null,\n      'd': direction\n    }, null);\n    parent.appendChild(pathElement);\n    if (chart.theme === 'Fluent' || chart.theme === 'FluentDark') {\n      var shadowId = chart.element.id + '_shadow';\n      pathElement.setAttribute('filter', Browser.isIE ? '' : 'url(#' + shadowId + ')');\n      var shadow = '<filter id=\"' + shadowId + '\" height=\"130%\"><feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"3\"/>';\n      shadow += '<feOffset dx=\"3\" dy=\"3\" result=\"offsetblur\"/><feComponentTransfer><feFuncA type=\"linear\" slope=\"0.5\"/>';\n      shadow += '</feComponentTransfer><feMerge><feMergeNode/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\n      var defElement = chart.renderer.createDefs();\n      defElement.setAttribute('id', chart.element.id + 'SVG_tooltip_definition');\n      parent.appendChild(defElement);\n      defElement.innerHTML = shadow;\n      pathElement.setAttribute('stroke', '#cccccc');\n      pathElement.setAttribute('stroke-width', '0.5');\n    }\n    textElement(chart.renderer, new TextOption(chart.element.id + '_Zoom_' + index + '_AxisLabel_' + i, x, y, anchor, i ? isRtlEnabled ? axis.startLabel : axis.endLabel : isRtlEnabled ? axis.endLabel : axis.startLabel), {\n      color: chart.themeStyle.crosshairLabelFont.color,\n      fontFamily: 'Segoe UI',\n      fontWeight: 'Regular',\n      size: '11px'\n    }, chart.themeStyle.crosshairLabelFont.color, parent, null, null, null, null, null, null, null, null, null, null, chart.themeStyle.crosshairLabelFont);\n  }\n  return parent;\n}\n/**\r\n * Finds the direction of the crosshair based on the provided parameters.\r\n *\r\n * @param {number} rX - The x-coordinate of the crosshair line.\r\n * @param {number} rY - The y-coordinate of the crosshair line.\r\n * @param {Rect} rect - The bounding rectangle of the crosshair.\r\n * @param {ChartLocation} arrowLocation - The location of the arrow in the crosshair.\r\n * @param {number} arrowPadding - The padding for the arrow.\r\n * @param {boolean} top - Indicates whether the crosshair is positioned at the top.\r\n * @param {boolean} bottom - Indicates whether the crosshair is positioned at the bottom.\r\n * @param {boolean} left - Indicates whether the crosshair is positioned at the left.\r\n * @param {number} tipX - The x-coordinate of the crosshair tip.\r\n * @param {number} tipY - The y-coordinate of the crosshair tip.\r\n * @returns {string} - The direction of the crosshair ('Top', 'Bottom', 'Left', 'Right', 'Center').\r\n */\nexport function findCrosshairDirection(rX, rY, rect, arrowLocation, arrowPadding, top, bottom, left, tipX, tipY) {\n  var direction = '';\n  var startX = rect.x;\n  var startY = rect.y;\n  var width = rect.x + rect.width;\n  var height = rect.y + rect.height;\n  if (top) {\n    direction = direction.concat('M' + ' ' + startX + ' ' + (startY + rY) + ' Q ' + startX + ' ' + startY + ' ' + (startX + rX) + ' ' + startY);\n    direction = direction.concat(' L' + ' ' + (width - rX) + ' ' + startY + ' Q ' + width + ' ' + startY + ' ' + width + ' ' + (startY + rY));\n    direction = direction.concat(' L' + ' ' + width + ' ' + (height - rY) + ' Q ' + width + ' ' + height + ' ' + (width - rX) + ' ' + height);\n    if (arrowPadding !== 0) {\n      direction = direction.concat(' L' + ' ' + (arrowLocation.x + arrowPadding / 2) + ' ' + height);\n      direction = direction.concat(' L' + ' ' + tipX + ' ' + (height + arrowPadding) + ' L' + ' ' + (arrowLocation.x - arrowPadding / 2) + ' ' + height);\n    }\n    if (arrowLocation.x - arrowPadding / 2 > startX) {\n      direction = direction.concat(' L' + ' ' + (startX + rX) + ' ' + height + ' Q ' + startX + ' ' + height + ' ' + startX + ' ' + (height - rY) + ' z');\n    } else {\n      if (arrowPadding === 0) {\n        direction = direction.concat(' L' + ' ' + (startX + rX) + ' ' + height + ' Q ' + startX + ' ' + height + ' ' + startX + ' ' + (height - rY) + ' z');\n      } else {\n        direction = direction.concat(' L' + ' ' + startX + ' ' + (height + rY) + ' z');\n      }\n    }\n  } else if (bottom) {\n    direction = direction.concat('M' + ' ' + startX + ' ' + (startY + rY) + ' Q ' + startX + ' ' + startY + ' ' + (startX + rX) + ' ' + startY + ' L' + ' ' + (arrowLocation.x - arrowPadding / 2) + ' ' + startY);\n    direction = direction.concat(' L' + ' ' + tipX + ' ' + arrowLocation.y);\n    direction = direction.concat(' L' + ' ' + (arrowLocation.x + arrowPadding / 2) + ' ' + startY);\n    direction = direction.concat(' L' + ' ' + (width - rX) + ' ' + startY + ' Q ' + width + ' ' + startY + ' ' + width + ' ' + (startY + rY));\n    direction = direction.concat(' L' + ' ' + width + ' ' + (height - rY) + ' Q ' + width + ' ' + height + ' ' + (width - rX) + ' ' + height);\n    direction = direction.concat(' L' + ' ' + (startX + rX) + ' ' + height + ' Q ' + startX + ' ' + height + ' ' + startX + ' ' + (height - rY) + ' z');\n  } else if (left) {\n    direction = direction.concat('M' + ' ' + startX + ' ' + (startY + rY) + ' Q ' + startX + ' ' + startY + ' ' + (startX + rX) + ' ' + startY);\n    direction = direction.concat(' L' + ' ' + (width - rX) + ' ' + startY + ' Q ' + width + ' ' + startY + ' ' + width + ' ' + (startY + rY) + ' L' + ' ' + width + ' ' + (arrowLocation.y - arrowPadding / 2));\n    direction = direction.concat(' L' + ' ' + (width + arrowPadding) + ' ' + tipY);\n    direction = direction.concat(' L' + ' ' + width + ' ' + (arrowLocation.y + arrowPadding / 2));\n    direction = direction.concat(' L' + ' ' + width + ' ' + (height - rY) + ' Q ' + width + ' ' + height + ' ' + (width - rX) + ' ' + height);\n    direction = direction.concat(' L' + ' ' + (startX + rX) + ' ' + height + ' Q ' + startX + ' ' + height + ' ' + startX + ' ' + (height - rY) + ' z');\n  } else {\n    direction = direction.concat('M' + ' ' + (startX + rX) + ' ' + startY + ' Q ' + startX + ' ' + startY + ' ' + startX + ' ' + (startY + rY) + ' L' + ' ' + startX + ' ' + (arrowLocation.y - arrowPadding / 2));\n    direction = direction.concat(' L' + ' ' + (startX - arrowPadding) + ' ' + tipY);\n    direction = direction.concat(' L' + ' ' + startX + ' ' + (arrowLocation.y + arrowPadding / 2));\n    direction = direction.concat(' L' + ' ' + startX + ' ' + (height - rY) + ' Q ' + startX + ' ' + height + ' ' + (startX + rX) + ' ' + height);\n    direction = direction.concat(' L' + ' ' + (width - rX) + ' ' + height + ' Q ' + width + ' ' + height + ' ' + width + ' ' + (height - rY));\n    direction = direction.concat(' L' + ' ' + width + ' ' + (startY + rY) + ' Q ' + width + ' ' + startY + ' ' + (width - rX) + ' ' + startY + ' z');\n  }\n  return direction;\n}\n//Within bounds\n/**\r\n * Checks if the provided coordinates are within the bounds of the rectangle.\r\n *\r\n * @param {number} x - The x-coordinate to check.\r\n * @param {number} y - The y-coordinate to check.\r\n * @param {Rect} bounds - The bounding rectangle.\r\n * @param {number} width - The width of the area to include in the bounds check.\r\n * @param {number} height - The height of the area to include in the bounds check.\r\n * @returns {boolean} - Returns true if the coordinates are within the bounds; otherwise, false.\r\n */\nexport function withInBounds(x, y, bounds, width, height) {\n  if (width === void 0) {\n    width = 0;\n  }\n  if (height === void 0) {\n    height = 0;\n  }\n  return x >= bounds.x - width && x <= bounds.x + bounds.width + width && y >= bounds.y - height && y <= bounds.y + bounds.height + height;\n}\n/**\r\n * Gets the x-coordinate value for a given point value on the axis.\r\n *\r\n * @param {number} value - The point value.\r\n * @param {number} size - The size of the axis.\r\n * @param {Axis} axis - The axis.\r\n * @returns {number} - Returns the x-coordinate value.\r\n */\nexport function getValueXByPoint(value, size, axis) {\n  var actualValue = !axis.isAxisInverse ? value / size : 1 - value / size;\n  return actualValue * axis.visibleRange.delta + axis.visibleRange.min;\n}\n/**\r\n * Gets the y-coordinate value for a given point value on the axis.\r\n *\r\n * @param {number} value - The point value.\r\n * @param {number} size - The size of the axis.\r\n * @param {Axis} axis - The axis.\r\n * @returns {number} - Returns the y-coordinate value.\r\n */\nexport function getValueYByPoint(value, size, axis) {\n  var actualValue = axis.isAxisInverse ? value / size : 1 - value / size;\n  return actualValue * axis.visibleRange.delta + axis.visibleRange.min;\n}\n/**\r\n * Finds the clip rectangle for a series.\r\n *\r\n * @param {Series} series - The series for which to find the clip rectangle.\r\n * @param {boolean} isCanvas - Indicates whether the rendering is on a canvas.\r\n * @returns {void}\r\n */\nexport function findClipRect(series, isCanvas) {\n  if (isCanvas === void 0) {\n    isCanvas = false;\n  }\n  var rect = series.clipRect;\n  if (isCanvas && (series.type === 'Polar' || series.type === 'Radar')) {\n    if (series.drawType === 'Scatter') {\n      rect.x = series.xAxis.rect.x;\n      rect.y = series.yAxis.rect.y;\n      rect.width = series.xAxis.rect.width;\n      rect.height = series.yAxis.rect.height;\n    } else {\n      rect.x = series.xAxis.rect.x / 2;\n      rect.y = series.yAxis.rect.y / 2;\n      rect.width = series.xAxis.rect.width;\n      rect.height = series.yAxis.rect.height;\n    }\n  } else {\n    if (series.chart.requireInvertedAxis) {\n      rect.x = series.yAxis.rect.x;\n      rect.y = series.xAxis.rect.y;\n      rect.width = series.yAxis.rect.width;\n      rect.height = series.xAxis.rect.height;\n    } else {\n      rect.x = series.xAxis.rect.x;\n      rect.y = series.yAxis.rect.y;\n      rect.width = series.xAxis.rect.width;\n      rect.height = series.yAxis.rect.height;\n    }\n  }\n}\n/**\r\n * Converts the first character of a string to lowercase.\r\n *\r\n * @param {string} str - The string to convert.\r\n * @returns {string} The converted string.\r\n */\nexport function firstToLowerCase(str) {\n  return str.substr(0, 1).toLowerCase() + str.substr(1);\n}\n/**\r\n * Gets the transformation of the chart area based on the provided axes and inverted axis state.\r\n *\r\n * @param {Axis} xAxis - The X-axis of the chart.\r\n * @param {Axis} yAxis - The Y-axis of the chart.\r\n * @param {boolean} invertedAxis - Indicates whether the chart axis is inverted.\r\n * @returns {Rect} The transformed chart area.\r\n */\nexport function getTransform(xAxis, yAxis, invertedAxis) {\n  var x;\n  var y;\n  var width;\n  var height;\n  if (invertedAxis) {\n    x = yAxis.rect.x;\n    y = xAxis.rect.y;\n    width = yAxis.rect.width;\n    height = xAxis.rect.height;\n  } else {\n    x = xAxis.rect.x;\n    y = yAxis.rect.y;\n    width = xAxis.rect.width;\n    height = yAxis.rect.height;\n  }\n  return new Rect(x, y, width, height);\n}\n/**\r\n * Calculates the minimum points delta between data points on the provided axis.\r\n *\r\n * @param {Axis | Chart3DAxis} axis - The axis for which to calculate the minimum points delta.\r\n * @param {Series[]} seriesCollection - The collection of series in the chart.\r\n * @returns {number} The minimum points delta.\r\n */\nexport function getMinPointsDelta(axis, seriesCollection) {\n  var minDelta = Number.MAX_VALUE;\n  var xValues;\n  var minVal;\n  var seriesMin;\n  var stackingGroups = [];\n  for (var index = 0; index < seriesCollection.length; index++) {\n    var series = seriesCollection[index];\n    xValues = [];\n    if (series.visible && (axis.name === series.xAxisName || axis.name === 'primaryXAxis' && series.xAxisName === null || axis.name === series.chart.primaryXAxis.name && !series.xAxisName)) {\n      if (series.type.indexOf('Stacking') > -1 && stackingGroups.indexOf(series.stackingGroup) === -1) {\n        stackingGroups.push(series.stackingGroup);\n      }\n      xValues = series.points.map(function (point) {\n        return point.xValue;\n      });\n      xValues.sort(function (first, second) {\n        return first - second;\n      });\n      if (xValues.length === 1) {\n        seriesMin = axis.valueType === 'DateTime' && series.xMin === series.xMax ? series.xMin - 25920000 : series.xMin;\n        minVal = xValues[0] - (!isNullOrUndefined(seriesMin) ? seriesMin : axis.visibleRange.min);\n        if (minVal !== 0) {\n          minDelta = Math.min(minDelta, minVal);\n        }\n      } else {\n        for (var index_1 = 0; index_1 < xValues.length; index_1++) {\n          var value = xValues[index_1];\n          if (index_1 > 0 && value) {\n            minVal = series.type.indexOf('Stacking') > -1 && axis.valueType === 'Category' ? stackingGroups.length : value - xValues[index_1 - 1];\n            if (minVal !== 0) {\n              minDelta = Math.min(minDelta, minVal);\n            }\n          }\n        }\n      }\n    }\n  }\n  if (minDelta === Number.MAX_VALUE) {\n    minDelta = 1;\n  }\n  return minDelta;\n}\n/**\r\n * Retrieves the animation function based on the specified effect.\r\n *\r\n * @param {string} effect - The name of the animation effect.\r\n * @returns {Function} The animation function corresponding to the effect.\r\n */\nexport function getAnimationFunction(effect) {\n  var functionName;\n  switch (effect) {\n    case 'Linear':\n      functionName = linear;\n      break;\n  }\n  return functionName;\n}\n/**\r\n * Linear animation function.\r\n *\r\n * @param {number} currentTime - The current time of the animation.\r\n * @param {number} startValue - The starting value of the animation.\r\n * @param {number} endValue - The ending value of the animation.\r\n * @param {number} duration - The duration of the animation.\r\n * @returns {number} The interpolated value at the current time.\r\n */\nexport function linear(currentTime, startValue, endValue, duration) {\n  return -endValue * Math.cos(currentTime / duration * (Math.PI / 2)) + endValue + startValue;\n}\n/**\r\n * Animates the marker element.\r\n *\r\n * @param {Element} element - The marker element to animate.\r\n * @param {number} delay - The delay before starting the animation.\r\n * @param {number} duration - The duration of the animation.\r\n * @param {Series | AccumulationSeries} series - The series associated with the marker.\r\n * @param {number} pointIndex - The index of the point in the series.\r\n * @param {ChartLocation} point - The location of the point.\r\n * @param {boolean} isLabel - Specifies whether the marker is a data label.\r\n * @returns {void}\r\n */\nexport function markerAnimate(element, delay, duration, series, pointIndex, point, isLabel) {\n  var centerX = point.x;\n  var centerY = point.y;\n  var height = 0;\n  element.style.visibility = 'hidden';\n  var transform = element.getAttribute('transform');\n  new Animation({}).animate(element, {\n    duration: duration,\n    delay: delay,\n    progress: function (args) {\n      if (args.timeStamp > args.delay) {\n        args.element.style.visibility = 'visible';\n        height = (args.timeStamp - args.delay) / args.duration;\n        element.setAttribute('transform', 'translate(' + centerX + ' ' + centerY + ') scale(' + height + ') translate(' + -centerX + ' ' + -centerY + ')');\n      }\n    },\n    end: function () {\n      element.style.visibility = '';\n      element.setAttribute('transform', transform ? transform : '');\n      if ((series.type === 'Scatter' || series.type === 'Bubble') && !isLabel && pointIndex === series.points.length - 1) {\n        series.chart.trigger('animationComplete', {\n          series: series.chart.isBlazor ? {} : series\n        });\n      }\n    }\n  });\n}\n/**\r\n * Animates the rectangle element.\r\n *\r\n * @param {Element} element - The rectangle element to animate.\r\n * @param {number} delay - The delay before starting the animation.\r\n * @param {number} duration - The duration of the animation.\r\n * @param {Rect} currentRect - The current rectangle dimensions.\r\n * @param {Rect} previousRect - The previous rectangle dimensions.\r\n * @returns {void}\r\n */\nexport function animateRectElement(element, delay, duration, currentRect, previousRect) {\n  var setStyle = function (rect) {\n    element.setAttribute('x', rect.x + '');\n    element.setAttribute('y', rect.y + '');\n    element.setAttribute('width', rect.width + '');\n    element.setAttribute('height', rect.height + '');\n  };\n  new Animation({}).animate(createElement('div'), {\n    duration: duration,\n    delay: delay,\n    //name: name,\n    progress: function (args) {\n      setStyle(new Rect(linear(args.timeStamp, previousRect.x, currentRect.x - previousRect.x, args.duration), linear(args.timeStamp, previousRect.y, currentRect.y - previousRect.y, args.duration), linear(args.timeStamp, previousRect.width, currentRect.width - previousRect.width, args.duration), linear(args.timeStamp, previousRect.height, currentRect.height - previousRect.height, args.duration)));\n    },\n    end: function () {\n      setStyle(currentRect);\n    }\n  });\n}\n/**\r\n * Animation after legend click a path.\r\n *\r\n * @param {Element} element - element to be animated\r\n * @param {string} direction - current direction of the path\r\n * @param {boolean} redraw - chart redraw\r\n * @param {string} previousDirection - previous direction of the path\r\n * @param {number} animateDuration - animateDuration of the path\r\n * @returns {void}\r\n */\nexport function pathAnimation(element, direction, redraw, previousDirection, animateDuration) {\n  if (!redraw || !previousDirection && !element) {\n    return null;\n  }\n  var duration = 300;\n  if (!isNullOrUndefined(animateDuration)) {\n    duration = animateDuration;\n  }\n  var startDirections = previousDirection || element.getAttribute('d');\n  var splitDirections = startDirections.split(/(?=[LMCZAQ])/);\n  var endDirections = direction.split(/(?=[LMCZAQ])/);\n  var currentDireciton;\n  var startPath = [];\n  var endPath = [];\n  var c;\n  var end;\n  element.setAttribute('d', startDirections);\n  new Animation({}).animate(createElement('div'), {\n    duration: duration,\n    progress: function (args) {\n      currentDireciton = '';\n      splitDirections.map(function (directions, index) {\n        startPath = directions.split(' ');\n        endPath = endDirections[index] ? endDirections[index].split(' ') : startPath;\n        if (startPath[0] === 'Z') {\n          currentDireciton += 'Z' + ' ';\n        } else if (startPath[0] === '') {\n          currentDireciton = '';\n        } else {\n          currentDireciton += startPath[0] + ' ' + linear(args.timeStamp, +startPath[1], +endPath[1] - +startPath[1], args.duration) + ' ' + linear(args.timeStamp, +startPath[2], +endPath[2] - +startPath[2], args.duration) + ' ';\n        }\n        if (startPath[0] === 'C' || startPath[0] === 'Q') {\n          c = 3;\n          end = startPath[0] === 'Q' ? 4 : 6;\n          while (c < end) {\n            currentDireciton += linear(args.timeStamp, +startPath[c], +endPath[c] - +startPath[c], args.duration) + ' ' + linear(args.timeStamp, +startPath[++c], +endPath[c] - +startPath[c], args.duration) + ' ';\n            ++c;\n          }\n        }\n        if (startPath[0] === 'A') {\n          currentDireciton += 0 + ' ' + 0 + ' ' + 1 + ' ' + linear(args.timeStamp, +startPath[6], +endPath[6] - +startPath[6], args.duration) + ' ' + linear(args.timeStamp, +startPath[7], +endPath[7] - +startPath[7], args.duration) + ' ';\n        }\n      });\n      element.setAttribute('d', currentDireciton);\n    },\n    end: function () {\n      element.setAttribute('d', direction);\n    }\n  });\n}\n/**\r\n * Point based animation in chart series.\r\n *\r\n * @param {Element} element element to be animated.\r\n * @param {string} direction current direction of the path.\r\n * @param {boolean} redraw chart redraw.\r\n * @param {string} previousDirection previous direction of the path.\r\n * @param {number} animateDuration animateDuration of the path.\r\n * @param {string} removeDirection removeDirection of the path.\r\n * @returns {void}\r\n */\nexport function animateAddPoints(element, direction, redraw, previousDirection, animateDuration, removeDirection) {\n  if (!redraw || !previousDirection && !element) {\n    return null;\n  }\n  var duration = 300;\n  if (!isNullOrUndefined(animateDuration)) {\n    duration = animateDuration;\n  }\n  var startDirections = previousDirection || element.getAttribute('d');\n  var endDirections = direction;\n  var currentDirection = '';\n  element.setAttribute('d', startDirections);\n  new Animation({}).animate(createElement('div'), {\n    duration: duration,\n    progress: function (args) {\n      currentDirection = '';\n      var startPathCommands = startDirections.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n      var endPathCommands = endDirections.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\n      var maxLength = Math.max(startPathCommands.length, endPathCommands.length);\n      for (var i = 0; i < maxLength; i++) {\n        var startPathCommand = startPathCommands[i] || '';\n        var endPathCommand = endPathCommands[i] || '';\n        var startCoords = startPathCommand.trim().split(/\\s+/);\n        var endCoords = endPathCommand.trim().split(/\\s+/);\n        var interpolatedCoords = [];\n        for (var j = 1; j < startCoords.length; j++) {\n          var startCoord = parseFloat(startCoords[j]);\n          var endCoord = parseFloat(endCoords[j]);\n          if (!isNaN(startCoord) && !isNaN(endCoord) && startCoords.length === endCoords.length) {\n            var interpolatedValue = linear(args.timeStamp, startCoord, endCoord - startCoord, duration);\n            if (i === maxLength - 1) {\n              interpolatedCoords.push(interpolatedValue);\n            } else {\n              interpolatedCoords.push(interpolatedValue);\n            }\n          }\n        }\n        if (startCoords.length !== endCoords.length) {\n          currentDirection += 'L';\n        } else {\n          currentDirection += startCoords[0];\n        }\n        currentDirection += ' ' + interpolatedCoords.join(' ');\n        currentDirection += ' ';\n      }\n      element.setAttribute('d', currentDirection);\n    },\n    end: function () {\n      element.setAttribute('d', removeDirection || direction);\n    }\n  });\n}\n/**\r\n * To append the clip rect element.\r\n *\r\n * @param {boolean} redraw - chart redraw value.\r\n * @param {BaseAttibutes} options - element options.\r\n * @param {SvgRenderer} renderer - svg renderer values.\r\n * @param {string} clipPath - clipPath of the element.\r\n * @returns {Element} - Returns clip rect element.\r\n */\nexport function appendClipElement(redraw, options, renderer, clipPath) {\n  if (clipPath === void 0) {\n    clipPath = 'drawClipPath';\n  }\n  var clipElement = redrawElement(redraw, options.id, options, renderer);\n  if (clipElement) {\n    var def = renderer.createDefs();\n    def.appendChild(clipElement);\n    return def;\n  } else {\n    return renderer[clipPath](options);\n  }\n}\n/**\r\n * Triggers the label render event.\r\n *\r\n * @param {Chart | RangeNavigator | Chart3D} chart - The chart or range navigator instance.\r\n * @param {number} tempInterval - The temporary interval value.\r\n * @param {string} text - The label text.\r\n * @param {FontModel} labelStyle - The style of the label.\r\n * @param {Axis | Chart3DAxis} axis - The axis associated with the label.\r\n * @returns {void}\r\n */\nexport function triggerLabelRender(chart, tempInterval, text, labelStyle, axis) {\n  var argsData = {\n    cancel: false,\n    name: axisLabelRender,\n    axis: axis,\n    text: text,\n    value: tempInterval,\n    labelStyle: labelStyle\n  };\n  chart.trigger(axisLabelRender, argsData);\n  if (!argsData.cancel) {\n    var isLineBreakLabels = argsData.text.indexOf('<br>') !== -1;\n    var text_1 = axis.enableTrim ? isLineBreakLabels ? lineBreakLabelTrim(axis.maximumLabelWidth, argsData.text, axis.labelStyle, chart.themeStyle.axisLabelFont) : textTrim(axis.maximumLabelWidth, argsData.text, axis.labelStyle, chart.enableRtl, chart.themeStyle.axisLabelFont) : argsData.text;\n    axis.visibleLabels.push(new VisibleLabels(text_1, argsData.value, argsData.labelStyle, argsData.text));\n  }\n}\n/**\r\n * The function used to find whether the range is set.\r\n *\r\n * @param {Axis | Chart3DAxis} axis - The axis to check.\r\n * @returns {boolean} - It returns true if the axis range is set otherwise false.\r\n * @private\r\n */\nexport function setRange(axis) {\n  return axis.minimum != null && axis.maximum != null;\n}\n/**\r\n * Checks if zooming is enabled for the axis.\r\n *\r\n * @param {Axis} axis - The axis to check for zooming.\r\n * @returns {boolean} - Returns true if zooming is enabled for the axis, otherwise false.\r\n */\nexport function isZoomSet(axis) {\n  return axis.zoomFactor < 1 && axis.zoomPosition >= 0;\n}\n/**\r\n * Calculates the actual desired intervals count based on the available size and axis.\r\n *\r\n * @param {Size} availableSize - The available size for rendering.\r\n * @param {Axis | Chart3DAxis} axis - The axis for which to calculate the intervals count.\r\n * @returns {number} - The actual desired intervals count.\r\n */\nexport function getActualDesiredIntervalsCount(availableSize, axis) {\n  var size = axis.orientation === 'Horizontal' ? availableSize.width : availableSize.height;\n  if (isNullOrUndefined(axis.desiredIntervals)) {\n    var desiredIntervalsCount = (axis.orientation === 'Horizontal' ? 0.533 : 1) * axis.maximumLabels;\n    desiredIntervalsCount = Math.max(size * (desiredIntervalsCount / 100), 1);\n    return desiredIntervalsCount;\n  } else {\n    return axis.desiredIntervals;\n  }\n}\n/**\r\n * Animates the template element.\r\n *\r\n * @param {Element} element - The element to animate.\r\n * @param {number} delay - The delay before starting the animation.\r\n * @param {number} duration - The duration of the animation.\r\n * @param {Effect} name - The name of the animation effect.\r\n * @param {boolean} [isRemove] - Indicates whether to remove the element after animation completion.\r\n * @returns {void}\r\n */\nexport function templateAnimate(element, delay, duration, name, isRemove) {\n  new Animation({}).animate(element, {\n    duration: duration,\n    delay: delay,\n    name: name,\n    progress: function (args) {\n      args.element.style.visibility = 'visible';\n    },\n    end: function (args) {\n      if (isRemove) {\n        remove(args.element);\n      } else {\n        args.element.style.visibility = 'visible';\n      }\n    }\n  });\n}\n/**\r\n * Draws a symbol at the specified location.\r\n *\r\n * @param {ChartLocation} location - The location to draw the symbol.\r\n * @param {string} shape - The shape of the symbol.\r\n * @param {Size} size - The size of the symbol.\r\n * @param {string} url - The URL of the image symbol.\r\n * @param {PathOption} options - The options for drawing the symbol.\r\n * @param {string} label - The label for the symbol.\r\n * @param {SvgRenderer | CanvasRenderer} [renderer] - The renderer for drawing the symbol.\r\n * @param {Rect} [clipRect] - The clipping rectangle.\r\n * @param {boolean} [isChartControl] - Indicates whether it is a chart control.\r\n * @param {BulletChart} [control] - The bullet chart control.\r\n * @returns {Element} - The element representing the drawn symbol.\r\n */\nexport function drawSymbol(location, shape, size, url, options, label, renderer, clipRect, isChartControl, control) {\n  var chartRenderer = renderer ? renderer : new SvgRenderer('');\n  var shapeOption = calculateShapes(location, size, shape, options, url, isChartControl, control);\n  var drawElement = chartRenderer['draw' + shapeOption.functionName](shapeOption.renderOption, clipRect ? new Int32Array([clipRect.x, clipRect.y]) : null);\n  //drawElement.setAttribute('aria-label', label);\n  return drawElement;\n}\n/**\r\n * Calculates the shapes based on the specified parameters.\r\n *\r\n * @param {ChartLocation} location - The location for the shapes.\r\n * @param {Size} size - The size of the shapes.\r\n * @param {string} shape - The shape of the symbols.\r\n * @param {PathOption} options - The options for drawing the shapes.\r\n * @param {string} url - The URL of the image symbols.\r\n * @param {boolean} [isChart] - Indicates whether it is a chart.\r\n * @param {BulletChart} [control] - The bullet chart control.\r\n * @returns {IShapes} - The calculated shapes.\r\n */\nexport function calculateShapes(location, size, shape, options, url, isChart, control) {\n  var dir;\n  var functionName = 'Path';\n  var isBulletChart = isChart;\n  var width = isBulletChart && shape === 'Circle' ? size.width - 2 : size.width;\n  var height = isBulletChart && shape === 'Circle' ? size.height - 2 : size.height;\n  var sizeBullet = isBulletChart ? control.targetWidth : 0;\n  var lx = location.x;\n  var ly = location.y;\n  var y = location.y + -height / 2;\n  var x = location.x + -width / 2;\n  var eq = 72;\n  var xVal;\n  var yVal;\n  switch (shape) {\n    case 'Bubble':\n    case 'Circle':\n      functionName = 'Ellipse';\n      merge(options, {\n        'rx': width / 2,\n        'ry': height / 2,\n        'cx': lx,\n        'cy': ly\n      });\n      break;\n    case 'Plus':\n      dir = 'M' + ' ' + x + ' ' + ly + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + ly + ' ' + 'M' + ' ' + lx + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + lx + ' ' + (ly + -height / 2);\n      merge(options, {\n        'd': dir\n      });\n      break;\n    case 'Cross':\n      dir = 'M' + ' ' + x + ' ' + (ly + -height / 2) + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + (ly + height / 2) + ' ' + 'M' + ' ' + x + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + (ly + -height / 2);\n      merge(options, {\n        'd': dir\n      });\n      break;\n    case 'Multiply':\n      dir = 'M ' + (lx - sizeBullet) + ' ' + (ly - sizeBullet) + ' L ' + (lx + sizeBullet) + ' ' + (ly + sizeBullet) + ' M ' + (lx - sizeBullet) + ' ' + (ly + sizeBullet) + ' L ' + (lx + sizeBullet) + ' ' + (ly - sizeBullet);\n      merge(options, {\n        'd': dir,\n        stroke: options.fill\n      });\n      break;\n    case 'HorizontalLine':\n      dir = 'M' + ' ' + x + ' ' + ly + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + ly;\n      merge(options, {\n        'd': dir\n      });\n      break;\n    case 'VerticalLine':\n      dir = 'M' + ' ' + lx + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + lx + ' ' + (ly + -height / 2);\n      merge(options, {\n        'd': dir\n      });\n      break;\n    case 'Diamond':\n      dir = 'M' + ' ' + x + ' ' + ly + ' ' + 'L' + ' ' + lx + ' ' + (ly + -height / 2) + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + ly + ' ' + 'L' + ' ' + lx + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + x + ' ' + ly + ' z';\n      merge(options, {\n        'd': dir\n      });\n      break;\n    case 'ActualRect':\n      dir = 'M' + ' ' + x + ' ' + (ly + -height / 8) + ' ' + 'L' + ' ' + (lx + sizeBullet) + ' ' + (ly + -height / 8) + ' ' + 'L' + ' ' + (lx + sizeBullet) + ' ' + (ly + height / 8) + ' ' + 'L' + ' ' + x + ' ' + (ly + height / 8) + ' ' + 'L' + ' ' + x + ' ' + (ly + -height / 8) + ' z';\n      merge(options, {\n        'd': dir\n      });\n      break;\n    case 'TargetRect':\n      dir = 'M' + ' ' + (x + sizeBullet) + ' ' + (ly + -height / 2) + ' ' + 'L' + ' ' + (lx + sizeBullet / 2) + ' ' + (ly + -height / 2) + ' ' + 'L' + ' ' + (lx + sizeBullet / 2) + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + (x + sizeBullet) + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + (x + sizeBullet) + ' ' + (ly + -height / 2) + ' z';\n      merge(options, {\n        'd': dir\n      });\n      break;\n    case 'Rectangle':\n    case 'Hilo':\n    case 'HiloOpenClose':\n    case 'Candle':\n    case 'Waterfall':\n    case 'BoxAndWhisker':\n    case 'StepArea':\n    case 'RangeStepArea':\n    case 'StackingStepArea':\n    case 'Square':\n    case 'Flag':\n      dir = 'M' + ' ' + x + ' ' + (ly + -height / 2) + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + (ly + -height / 2) + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + x + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + x + ' ' + (ly + -height / 2) + ' z';\n      merge(options, {\n        'd': dir\n      });\n      break;\n    case 'Pyramid':\n    case 'Triangle':\n      dir = 'M' + ' ' + x + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + lx + ' ' + (ly + -height / 2) + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + x + ' ' + (ly + height / 2) + ' z';\n      merge(options, {\n        'd': dir\n      });\n      break;\n    case 'Funnel':\n    case 'InvertedTriangle':\n      dir = 'M' + ' ' + (lx + width / 2) + ' ' + (ly - height / 2) + ' ' + 'L' + ' ' + lx + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + (lx - width / 2) + ' ' + (ly - height / 2) + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + (ly - height / 2) + ' z';\n      merge(options, {\n        'd': dir\n      });\n      break;\n    case 'Pentagon':\n      for (var i = 0; i <= 5; i++) {\n        xVal = width / 2 * Math.cos(Math.PI / 180 * (i * eq));\n        yVal = height / 2 * Math.sin(Math.PI / 180 * (i * eq));\n        if (i === 0) {\n          dir = 'M' + ' ' + (lx + xVal) + ' ' + (ly + yVal) + ' ';\n        } else {\n          dir = dir.concat('L' + ' ' + (lx + xVal) + ' ' + (ly + yVal) + ' ');\n        }\n      }\n      dir = dir.concat('Z');\n      merge(options, {\n        'd': dir\n      });\n      break;\n    case 'Image':\n      functionName = 'Image';\n      merge(options, {\n        'href': url,\n        'height': height,\n        'width': width,\n        x: x,\n        y: y\n      });\n      break;\n  }\n  options = calculateLegendShapes(location, new Size(width, height), shape, options).renderOption;\n  return {\n    renderOption: options,\n    functionName: functionName\n  };\n}\n/**\r\n * Gets the location of the rectangle based on the specified start and end locations and the outer rectangle.\r\n *\r\n * @param {ChartLocation} startLocation - The start location.\r\n * @param {ChartLocation} endLocation - The end location.\r\n * @param {Rect} outerRect - The outer rectangle.\r\n * @returns {Rect} - The location of the rectangle.\r\n */\nexport function getRectLocation(startLocation, endLocation, outerRect) {\n  var x = endLocation.x < outerRect.x ? outerRect.x : endLocation.x > outerRect.x + outerRect.width ? outerRect.x + outerRect.width : endLocation.x;\n  var y = endLocation.y < outerRect.y ? outerRect.y : endLocation.y > outerRect.y + outerRect.height ? outerRect.y + outerRect.height : endLocation.y;\n  return new Rect(x > startLocation.x ? startLocation.x : x, y > startLocation.y ? startLocation.y : y, Math.abs(x - startLocation.x), Math.abs(y - startLocation.y));\n}\n/**\r\n * Returns the value constrained within the specified minimum and maximum limits.\r\n *\r\n * @param {number} value - The input value.\r\n * @param {number} min - The minimum limit.\r\n * @param {number} max - The maximum limit.\r\n * @returns {number} - The constrained value.\r\n */\nexport function minMax(value, min, max) {\n  return value > max ? max : value < min ? min : value;\n}\n/**\r\n * Retrieves the DOM element with the specified ID.\r\n *\r\n * @param {string} id - The ID of the element to retrieve.\r\n * @returns {Element} - The DOM element.\r\n */\nexport function getElement(id) {\n  return document.getElementById(id);\n}\n/**\r\n * Gets the template function from the provided template string or function.\r\n *\r\n * @param {string | Function} template - The template string or function.\r\n * @returns {Function} - The template function.\r\n */\nexport function getTemplateFunction(template) {\n  var templateFn = null;\n  try {\n    if (typeof template !== 'function' && document.querySelectorAll(template).length) {\n      templateFn = templateComplier(document.querySelector(template).innerHTML.trim());\n    } else {\n      templateFn = templateComplier(template);\n    }\n  } catch (e) {\n    templateFn = templateComplier(template);\n  }\n  return templateFn;\n}\n/**\r\n * Renders the accumulation chart data labels using template.\r\n *\r\n * @param {HTMLElement} childElement - The child element.\r\n * @param {AccumulationChart} chart - The accumulation chart instance.\r\n * @param {boolean} isTemplate - Defines whether the template is applied or not.\r\n * @param {AccPoints[]} points - The accumulation chart points.\r\n * @param {IAccTextRenderEventArgs} argsData - The accumulation chart text render event arguments.\r\n * @param {AccPoints} [point] - The accumulation chart point.\r\n * @param {Element} [datalabelGroup] - The data label group element.\r\n * @param {string} [id] - The id of the element.\r\n * @param {AccumulationDataLabelSettingsModel} [dataLabel] - The accumulation chart data label settings.\r\n * @param {boolean} [redraw] - Defines whether to redraw the chart or not.\r\n * @returns {void}\r\n */\nexport function accReactTemplate(childElement, chart, isTemplate, points, argsData, point, datalabelGroup, id, dataLabel, redraw) {\n  var clientRect = childElement.getBoundingClientRect();\n  chart.accumulationDataLabelModule.calculateLabelSize(isTemplate, childElement, point, points, argsData, datalabelGroup, id, dataLabel, redraw, clientRect, true);\n}\n/**\r\n * Renders the chart data labels using template.\r\n *\r\n * @param {HTMLElement} childElement - The child element.\r\n * @param {Chart} chart - The chart instance.\r\n * @param {Points} point - The chart point.\r\n * @param {Series} series - The chart series.\r\n * @param {number} labelIndex - The index of the label.\r\n * @param {boolean} [redraw] - Defines whether to redraw the chart or not.\r\n * @returns {void}\r\n */\nexport function chartReactTemplate(childElement, chart, point, series, labelIndex, redraw) {\n  var parentElement = document.getElementById(chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index) + '_DataLabelCollections');\n  if (parentElement) {\n    if (point.index === 0) {\n      chart.dataLabelCollections = []; // clear old datalabel bounds for react callback\n    }\n    chart.dataLabelModule.calculateTemplateLabelSize(parentElement, childElement, point, series, series.marker.dataLabel, labelIndex, series.clipRect, redraw, true);\n  }\n}\n/**\r\n * Creates a template.\r\n *\r\n * @param {HTMLElement} childElement - The child element of the template.\r\n * @param {number} pointIndex - The index of the point.\r\n * @param {string | Function} content - The content of the template.\r\n * @param {Chart | AccumulationChart | RangeNavigator} chart - The chart instance.\r\n * @param {Points | AccPoints} point - The chart or accumulation point.\r\n * @param {Series | AccumulationSeries} series - The chart or accumulation series.\r\n * @param {string} dataLabelId - The id of the data label.\r\n * @param {number} labelIndex - The index of the label.\r\n * @param {IAccTextRenderEventArgs} argsData - The event arguments for text rendering.\r\n * @param {boolean} isTemplate - Indicates whether it is a template.\r\n * @param {AccPoints[]} points - The accumulation points.\r\n * @param {Element} datalabelGroup - The group element of the data label.\r\n * @param {string} id - The id of the element.\r\n * @param {AccumulationDataLabelSettingsModel} dataLabel - The data label settings.\r\n * @param {boolean} redraw - Indicates whether to redraw.\r\n * @returns {HTMLElement} - The created template element.\r\n * @private\r\n */\nexport function createTemplate(childElement, pointIndex, content, chart, point, series, dataLabelId, labelIndex, argsData, isTemplate, points, datalabelGroup, id, dataLabel, redraw) {\n  var templateFn = getTemplateFunction(content);\n  var templateElement;\n  try {\n    var blazor = 'Blazor';\n    var tempObject = window[blazor] ? dataLabelId ? point : {\n      point: point\n    } : {\n      chart: chart,\n      series: series,\n      point: point\n    };\n    var templateId = dataLabelId ? dataLabelId + '_template' : 'template';\n    var elementData = templateFn ? templateFn(tempObject, chart, templateId, dataLabelId || childElement.id.replace(/[^a-zA-Z0-9]/g, '')) : [];\n    if (elementData.length) {\n      templateElement = Array.prototype.slice.call(elementData);\n      var len = templateElement.length;\n      for (var i = 0; i < len; i++) {\n        childElement.appendChild(templateElement[i]);\n      }\n    }\n    var reactCallback = void 0;\n    if (chart.getModuleName() === 'accumulationchart') {\n      reactCallback = accReactTemplate.bind(this, childElement, chart, isTemplate, points, argsData, points[pointIndex], datalabelGroup, id, dataLabel, redraw);\n      if (chart.isReact) {\n        chart.renderReactTemplates(reactCallback);\n      }\n    } else if (chart.getModuleName() === 'chart') {\n      reactCallback = point && series ? chartReactTemplate.bind(this, childElement, chart, point, series, labelIndex, redraw) : reactCallback;\n      if (chart.isReact) {\n        chart.renderReactTemplates(reactCallback);\n      }\n    }\n  } catch (e) {\n    return childElement;\n  }\n  return childElement;\n}\n/**\r\n * Gets the font style.\r\n *\r\n * @param {FontModel} font - The font settings.\r\n * @returns {string} - The font style.\r\n * @private\r\n */\nexport function getFontStyle(font, themeFontStyle) {\n  var style = '';\n  style = 'font-size:' + (font.size || themeFontStyle.size) + '; font-style:' + (font.fontStyle || themeFontStyle.fontStyle) + '; font-weight:' + (font.fontWeight || themeFontStyle.fontWeight) + '; font-family:' + font.fontFamily + ';opacity:' + font.opacity + '; color:' + font.color + ';';\n  return style;\n}\n/**\r\n * Measures the bounding rectangle of an HTML element.\r\n *\r\n * @param {HTMLElement} element - The HTML element to measure.\r\n * @param {boolean} redraw - Indicates whether to redraw.\r\n * @param {boolean} isReactCallback - Indicates whether it's a React callback.\r\n * @returns {ClientRect} - The bounding rectangle of the element.\r\n * @private\r\n */\nexport function measureElementRect(element, redraw, isReactCallback) {\n  if (redraw === void 0) {\n    redraw = false;\n  }\n  if (!isReactCallback) {\n    // If the element is already in DOM, no need to append in the body.\n    document.body.appendChild(element);\n  }\n  var bounds = element.getBoundingClientRect();\n  if (redraw) {\n    remove(element);\n  } else if (!isReactCallback) {\n    // for react chart data label template - (callback function)\n    removeElement(element.id);\n  }\n  return bounds;\n}\n/**\r\n * Finds an element in a NodeList based on its id.\r\n *\r\n * @param {NodeList} elements - The NodeList to search.\r\n * @param {string} id - The id of the element to find.\r\n * @returns {Element} - The found element.\r\n * @private\r\n */\nexport function findlElement(elements, id) {\n  var element;\n  for (var i = 0, length_1 = elements.length; i < length_1; i++) {\n    if (elements[i].id.indexOf(id) > -1) {\n      element = elements[i];\n      continue;\n    }\n  }\n  return element;\n}\n/**\r\n * Gets the point on the chart based on the provided coordinates and axes.\r\n *\r\n * @param {number} x - The x-coordinate of the point.\r\n * @param {number} y - The y-coordinate of the point.\r\n * @param {Axis} xAxis - The x-axis of the chart.\r\n * @param {Axis} yAxis - The y-axis of the chart.\r\n * @param {boolean} isInverted - Indicates whether the chart is inverted.\r\n * @returns {ChartLocation} - The calculated point.\r\n * @private\r\n */\nexport function getPoint(x, y, xAxis, yAxis, isInverted) {\n  x = xAxis.valueType === 'Logarithmic' ? logBase(x > 0 ? x : Math.pow(xAxis.logBase, xAxis.visibleRange.min), xAxis.logBase) : x;\n  y = yAxis.valueType === 'Logarithmic' ? logBase(y > 0 ? y : Math.pow(yAxis.logBase, yAxis.visibleRange.min), yAxis.logBase) : y;\n  x = valueToCoefficient(x, xAxis);\n  y = valueToCoefficient(y, yAxis);\n  var xLength = isInverted ? xAxis.rect.height : xAxis.rect.width;\n  var yLength = isInverted ? yAxis.rect.width : yAxis.rect.height;\n  var locationX = isInverted ? y * yLength : x * xLength;\n  var locationY = isInverted ? (1 - x) * xLength : (1 - y) * yLength;\n  return new ChartLocation(locationX, locationY);\n}\n/**\r\n * Appends an element to a parent element.\r\n *\r\n * @param {Element} child - The child element to be appended.\r\n * @param {Element} parent - The parent element to which the child element will be appended.\r\n * @param {boolean} [redraw=false] - A boolean value indicating whether to redraw. Default is false.\r\n * @param {boolean} [animate=false] - A boolean value indicating whether to animate the appending operation. Default is false.\r\n * @param {string} [x='x'] - The x-coordinate for the position of the child element. Default is 'x'.\r\n * @param {string} [y='y'] - The y-coordinate for the position of the child element. Default is 'y'.\r\n * @param {number} duration - duration of the animation\r\n * @returns {void}\r\n * @private\r\n */\nexport function appendElement(child, parent, redraw, animate, x, y, duration) {\n  if (redraw === void 0) {\n    redraw = false;\n  }\n  if (animate === void 0) {\n    animate = false;\n  }\n  if (x === void 0) {\n    x = 'x';\n  }\n  if (y === void 0) {\n    y = 'y';\n  }\n  if (child && child.hasChildNodes() && parent) {\n    appendChildElement(false, parent, child, redraw, animate, x, y, undefined, undefined, undefined, undefined, undefined, duration);\n  } else {\n    return null;\n  }\n}\n/**\r\n * Method to append child element.\r\n *\r\n * @param {boolean} isCanvas - canvas mode value\r\n * @param {Element | HTMLElement} parent - parent element\r\n * @param {Element | HTMLElement} childElement - childElement element\r\n * @param {boolean} redraw - chart redraw value\r\n * @param {boolean} isAnimate - animation value\r\n * @param {string} x - x position\r\n * @param {string} y - y position\r\n * @param {ChartLocation} start - start location value\r\n * @param {string} direction - direction of the element\r\n * @param {boolean} forceAnimate - forceAnimate\r\n * @param {boolean} isRect - isRect\r\n * @param {Rect} previousRect - previousRect\r\n * @param {number} animateDuration - duration of the animation\r\n * @param {boolean} scatterElement - The scatter element.\r\n * @param {number} angle - The angle of the element.\r\n * @param {ChartLocation} currentTransform - The current transform of the element.\r\n * @returns {void}\r\n */\nexport function appendChildElement(isCanvas, parent, childElement, redraw, isAnimate, x, y, start, direction, forceAnimate, isRect, previousRect, animateDuration, scatterElement, angle, currentTransform) {\n  if (isAnimate === void 0) {\n    isAnimate = false;\n  }\n  if (x === void 0) {\n    x = 'x';\n  }\n  if (y === void 0) {\n    y = 'y';\n  }\n  if (forceAnimate === void 0) {\n    forceAnimate = false;\n  }\n  if (isRect === void 0) {\n    isRect = false;\n  }\n  if (previousRect === void 0) {\n    previousRect = null;\n  }\n  if (scatterElement === void 0) {\n    scatterElement = false;\n  }\n  if (angle === void 0) {\n    angle = 0;\n  }\n  if (isCanvas) {\n    return null;\n  }\n  var existChild = scatterElement ? null : parent.querySelector('#' + childElement.id);\n  var element = existChild || getElement(childElement.id);\n  var child = childElement;\n  var duration = !isNullOrUndefined(animateDuration) ? animateDuration : 300;\n  if (redraw && isAnimate && element) {\n    start = start || (element.tagName === 'DIV' ? new ChartLocation(+element.style[x].split('px')[0], +element.style[y].split('px')[0]) : new ChartLocation(+element.getAttribute(x), +element.getAttribute(y)));\n    if (direction && direction !== 'undefined') {\n      pathAnimation(childElement, childElement.getAttribute('d'), redraw, direction, duration);\n    } else if (isRect && previousRect) {\n      animateRectElement(child, 0, duration, new Rect(+element.getAttribute('x'), +element.getAttribute('y'), +element.getAttribute('width'), +element.getAttribute('height')), previousRect);\n    } else {\n      var end = child.tagName === 'DIV' ? new ChartLocation(+child.style[x].split('px')[0], +child.style[y].split('px')[0]) : new ChartLocation(+child.getAttribute(x), +child.getAttribute(y));\n      var previousTranform = element.getAttribute('transform');\n      animateRedrawElement(child, duration, start, end, x, y, angle, currentTransform, previousTranform ? new ChartLocation(parseFloat(previousTranform.split(',')[1]), parseFloat(previousTranform.split(',')[2])) : new ChartLocation(0, 0));\n    }\n  } else if (redraw && isAnimate && !element && forceAnimate) {\n    templateAnimate(child, 0, 600, 'FadeIn');\n  }\n  if (existChild) {\n    parent.replaceChild(child, element);\n  } else {\n    parent.appendChild(child);\n  }\n}\n/**\r\n * Calculates the location of the dragged rectangle.\r\n *\r\n * @param {number} x1 - The x-coordinate of the starting point.\r\n * @param {number} y1 - The y-coordinate of the starting point.\r\n * @param {number} x2 - The x-coordinate of the ending point.\r\n * @param {number} y2 - The y-coordinate of the ending point.\r\n * @param {Rect} outerRect - The outer rectangle containing the dragged rectangle.\r\n * @returns {Rect} - The location of the dragged rectangle.\r\n * @private\r\n */\nexport function getDraggedRectLocation(x1, y1, x2, y2, outerRect) {\n  var width = Math.abs(x1 - x2);\n  var height = Math.abs(y1 - y2);\n  var x = Math.max(checkBounds(Math.min(x1, x2), width, outerRect.x, outerRect.width), outerRect.x);\n  var y = Math.max(checkBounds(Math.min(y1, y2), height, outerRect.y, outerRect.height), outerRect.y);\n  return new Rect(x, y, Math.min(width, outerRect.width), Math.min(height, outerRect.height));\n}\n/**\r\n * Checks if a value is within bounds defined by minimum and maximum values.\r\n *\r\n * @param {number} start - The start value.\r\n * @param {number} size - The size of the value.\r\n * @param {number} min - The minimum value of the bound.\r\n * @param {number} max - The maximum value of the bound.\r\n * @returns {number} - The adjusted value within the bounds.\r\n * @private\r\n */\nexport function checkBounds(start, size, min, max) {\n  if (start < min) {\n    start = min;\n  } else if (start + size > max + min) {\n    start = max + min - size;\n  }\n  return start;\n}\n/**\r\n * Retrieves label text for a data point.\r\n *\r\n * @param {Points} currentPoint - The current data point.\r\n * @param {Series} series - The series to which the data point belongs.\r\n * @param {Chart} chart - The chart instance.\r\n * @returns {string[]} - The label text.\r\n * @private\r\n */\nexport function getLabelText(currentPoint, series, chart) {\n  var labelFormat = series.marker.dataLabel.format ? series.marker.dataLabel.format : series.yAxis.labelFormat;\n  var text = [];\n  var customLabelFormat = labelFormat.match('{value}') !== null;\n  switch (series.seriesType) {\n    case 'XY':\n      /**\r\n       * I255790\r\n       * For Polar radar series, the dataLabel appears out of range when axis range is given for yaxis\r\n       * Cause: Since symbol location for the points which did not lies in within range, lies outside of seriesRect.\r\n       * Fix: DataLabel rendered after checking WithIn for the points\r\n       */\n      if (series.chart.chartAreaType === 'PolarRadar') {\n        if (series.drawType.indexOf('Stacking') !== -1) {\n          if (series.yAxis.valueType === 'Logarithmic' && logWithIn(series.stackedValues.endValues[currentPoint.index], series.yAxis) || withIn(series.stackedValues.endValues[currentPoint.index], series.yAxis.visibleRange)) {\n            text.push(currentPoint.text || currentPoint.yValue.toString());\n          }\n        } else {\n          if (series.yAxis.valueType === 'Logarithmic' && logWithIn(currentPoint.yValue, series.yAxis) || withIn(currentPoint.yValue, series.yAxis.visibleRange)) {\n            text.push(currentPoint.text || currentPoint.yValue.toString());\n          }\n        }\n      } else {\n        text.push(currentPoint.text || currentPoint.yValue.toString());\n      }\n      break;\n    case 'HighLow':\n      text.push(currentPoint.text || Math.max(currentPoint.high, currentPoint.low).toString());\n      text.push(currentPoint.text || Math.min(currentPoint.high, currentPoint.low).toString());\n      break;\n    case 'HighLowOpenClose':\n      text.push(currentPoint.text || Math.max(currentPoint.high, currentPoint.low).toString());\n      text.push(currentPoint.text || Math.min(currentPoint.high, currentPoint.low).toString());\n      text.push(currentPoint.text || Math.max(currentPoint.open, currentPoint.close).toString());\n      text.push(currentPoint.text || Math.min(currentPoint.open, currentPoint.close).toString());\n      break;\n    case 'BoxPlot':\n      text.push(currentPoint.text || currentPoint.median.toString());\n      text.push(currentPoint.text || currentPoint.maximum.toString());\n      text.push(currentPoint.text || currentPoint.minimum.toString());\n      text.push(currentPoint.text || currentPoint.upperQuartile.toString());\n      text.push(currentPoint.text || currentPoint.lowerQuartile.toString());\n      for (var _i = 0, _a = currentPoint.outliers; _i < _a.length; _i++) {\n        var liers = _a[_i];\n        text.push(currentPoint.text || liers.toString());\n      }\n      break;\n  }\n  if ((labelFormat || chart.useGroupingSeparator) && !currentPoint.text) {\n    series.yAxis.format = chart.intl.getNumberFormat({\n      format: customLabelFormat ? '' : labelFormat,\n      useGrouping: chart.useGroupingSeparator\n    });\n    for (var i = 0; i < text.length; i++) {\n      text[i] = customLabelFormat ? labelFormat.replace('{value}', series.yAxis.format(parseFloat(text[i]))) : series.yAxis.format(parseFloat(text[i]));\n    }\n  }\n  return text;\n}\n/**\r\n * Stops the specified timer.\r\n *\r\n * @param {number} timer - The timer to stop.\r\n * @returns {void}\r\n */\nexport function stopTimer(timer) {\n  window.clearInterval(timer);\n}\n/**\r\n * Checks if the specified rect collides with any of the rect in the collection within the given clip rect.\r\n *\r\n * @param {Rect} rect - The rect to check for collision.\r\n * @param {Rect[]} collections - The collection of rect to check against.\r\n * @param {Rect} clipRect - The clip rect.\r\n * @returns {boolean} - Returns true if collision occurs; otherwise, false.\r\n */\nexport function isCollide(rect, collections, clipRect) {\n  var currentRect = new Rect(rect.x + clipRect.x, rect.y + clipRect.y, rect.width, rect.height);\n  var isCollide = collections.some(function (rect) {\n    return currentRect.x < rect.x + rect.width && currentRect.x + currentRect.width > rect.x && currentRect.y < rect.y + rect.height && currentRect.height + currentRect.y > rect.y;\n  });\n  return isCollide;\n}\n/**\r\n * Checks if the specified rect overlap each other.\r\n *\r\n * @param {Rect} currentRect - The first rect.\r\n * @param {Rect} rect - The second rect.\r\n * @returns {boolean} - Returns true if the rect overlap; otherwise, false.\r\n */\nexport function isOverlap(currentRect, rect) {\n  return currentRect.x < rect.x + rect.width && currentRect.x + currentRect.width > rect.x && currentRect.y < rect.y + rect.height && currentRect.height + currentRect.y > rect.y;\n}\n/**\r\n * Checks if the specified rect is completely contained within another rect.\r\n *\r\n * @param {Rect} currentRect - The rect to check if it's contained.\r\n * @param {Rect} rect - The containing rect.\r\n * @returns {boolean} - Returns true if the specified rect is completely contained within the containing rect; otherwise, false.\r\n */\nexport function containsRect(currentRect, rect) {\n  return currentRect.x <= rect.x && currentRect.x + currentRect.width >= rect.x + rect.width && currentRect.y <= rect.y && currentRect.height + currentRect.y >= rect.y + rect.height;\n}\n/**\r\n * Calculates the rect based on the specified location, text size, and margin.\r\n *\r\n * @param {ChartLocation} location - The location of the rect.\r\n * @param {Size} textSize - The size of the text.\r\n * @param {MarginModel} margin - The margin to be applied around the text.\r\n * @returns {Rect} - Returns the calculated rect.\r\n */\nexport function calculateRect(location, textSize, margin) {\n  return new Rect(location.x - textSize.width / 2 - margin.left, location.y - textSize.height / 2 - margin.top, textSize.width + margin.left + margin.right, textSize.height + margin.top + margin.bottom);\n}\n/**\r\n * Converts the color value to hexadecimal code.\r\n *\r\n * @param {ColorValue} value - The color value to convert.\r\n * @returns {string} - Returns the hexadecimal representation of the color.\r\n */\nexport function convertToHexCode(value) {\n  return '#' + componentToHex(value.r) + componentToHex(value.g) + componentToHex(value.b);\n}\n/**\r\n * Converts a component value to its hexadecimal representation.\r\n *\r\n * @param {number} value - The component value to convert.\r\n * @returns {string} - Returns the hexadecimal representation of the component.\r\n * @private\r\n */\nexport function componentToHex(value) {\n  var hex = value.toString(16);\n  return hex.length === 1 ? '0' + hex : hex;\n}\n/**\r\n * Converts a hexadecimal color code to its RedGreenBlue representation.\r\n *\r\n * @param {string} hex - The hexadecimal color code to convert.\r\n * @returns {ColorValue} - Returns the RedGreenBlue representation of the hexadecimal color code.\r\n */\nexport function convertHexToColor(hex) {\n  var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return result ? new ColorValue(parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)) : new ColorValue(255, 255, 255);\n}\n/**\r\n * Converts a color name to its corresponding hexadecimal color code.\r\n *\r\n * @param {string} color - The color name to convert.\r\n * @returns {string} - Returns the hexadecimal color code.\r\n */\nexport function colorNameToHex(color) {\n  color = color === 'transparent' ? 'white' : color;\n  document.body.appendChild(createElement('text', {\n    id: 'chartmeasuretext'\n  }));\n  var element = document.getElementById('chartmeasuretext');\n  element.style.color = color;\n  color = window.getComputedStyle(element).color;\n  remove(element);\n  var isRGBValue;\n  if (color.indexOf('rgb') === 0 || color.indexOf('hsl') === 0) {\n    color = color.replace(/\\s/g, '').replace(/[()]/g, '');\n    isRGBValue = color.slice(3).split(',');\n  }\n  return convertToHexCode(new ColorValue(parseInt(isRGBValue[0], 10), parseInt(isRGBValue[1], 10), parseInt(isRGBValue[2], 10)));\n}\n/**\r\n * Checks if the provided color string is in a valid format.\r\n *\r\n * @param {string} color - The color string to check.\r\n * @returns {boolean} - Returns true if the color string is in a valid format, otherwise returns false.\r\n */\nexport function checkColorFormat(color) {\n  if (color.indexOf('rgba(') === 0 || color.indexOf('rgb(') === 0) {\n    var rgbaValues = color.substring(color.indexOf('(') + 1, color.lastIndexOf(')')).split(',');\n    if (rgbaValues.length === 3 || rgbaValues.length === 4) {\n      return rgbaValues.every(function (val) {\n        var num = parseFloat(val);\n        return !isNaN(num) && num >= 0 && num <= 255;\n      });\n    }\n  } else if (color.indexOf('#') === 0) {\n    var hex = color.substring(1);\n    return (hex.length === 3 || hex.length === 6) && /^[0-9A-Fa-f]{3,6}$/.test(hex);\n  }\n  return false;\n}\n/**\r\n * Gets the color with adjusted saturation.\r\n *\r\n * @param {string} color - The input color string.\r\n * @param {number} factor - The factor by which to adjust the saturation.\r\n * @returns {string} - The modified color string.\r\n */\nexport function getSaturationColor(color, factor) {\n  color = colorNameToHex(color);\n  color = color.replace(/[^0-9a-f]/gi, '');\n  if (color.length < 6) {\n    color = color[0] + color[0] + color[1] + color[1] + color[2] + color[2];\n  }\n  factor = factor || 0;\n  // convert to decimal and change luminosity\n  var rgb = '#';\n  var colorCode;\n  for (var i = 0; i < 3; i++) {\n    colorCode = parseInt(color.substr(i * 2, 2), 16);\n    colorCode = Math.round(Math.min(Math.max(0, colorCode + colorCode * factor), 255));\n    rgb += ('00' + colorCode.toString(16)).substr(colorCode.toString(16).length);\n  }\n  return rgb;\n}\n/**\r\n * Applies a lightness adjustment to the given color.\r\n *\r\n * @param {string} color - The input color string.\r\n * @param {number} value - The value by which to adjust the lightness.\r\n * @returns {string} - The modified color string.\r\n */\nexport function applyZLight(color, value) {\n  var RGB = convertHexToColor(color);\n  RGB.r = parseInt(Math.floor(RGB.r * value).toString(), 10);\n  RGB.g = parseInt(Math.floor(RGB.g * value).toString(), 10);\n  RGB.b = parseInt(Math.floor(RGB.b * value).toString(), 10);\n  return '#' + componentToHex(RGB.r).toUpperCase() + componentToHex(RGB.g).toUpperCase() + componentToHex(RGB.b).toUpperCase();\n}\n/**\r\n * Calculates the median value of an array of numbers.\r\n *\r\n * @param {number[]} values - The array of numbers.\r\n * @returns {number} - The median value.\r\n */\nexport function getMedian(values) {\n  var half = Math.floor(values.length / 2);\n  return values.length % 2 ? values[half] : (values[half - 1] + values[half]) / 2.0;\n}\n/**\r\n * Calculates the legend shapes based on the provided parameters.\r\n *\r\n * @param {ChartLocation} location - The location to position the legend shape.\r\n * @param {Size} size - The size of the legend shape.\r\n * @param {string} shape - The shape of the legend.\r\n * @param {PathOption} options - The options for drawing the legend shape.\r\n * @returns {IShapes} - The calculated legend shape.\r\n */\nexport function calculateLegendShapes(location, size, shape, options) {\n  var padding = 10;\n  var dir = '';\n  var space = 2;\n  var height = size.height;\n  var width = size.width;\n  var lx = location.x;\n  var ly = location.y;\n  switch (shape) {\n    case 'MultiColoredLine':\n    case 'Line':\n    case 'StackingLine':\n    case 'StackingLine100':\n      dir = 'M' + ' ' + (lx + -width * (3 / 4)) + ' ' + ly + ' ' + 'L' + ' ' + (lx + width * (3 / 4)) + ' ' + ly;\n      merge(options, {\n        'd': dir\n      });\n      break;\n    case 'StepLine':\n      options.fill = 'transparent';\n      dir = 'M' + ' ' + (lx + -width / 2 - padding / 4) + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + (lx + -width / 2 + width / 10) + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + (lx + -width / 2 + width / 10) + ' ' + ly + ' ' + 'L' + ' ' + (lx + -width / 10) + ' ' + ly + ' ' + 'L' + ' ' + (lx + -width / 10) + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + (lx + width / 5) + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + (lx + width / 5) + ' ' + (ly + -height / 2) + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + (ly + -height / 2) + 'L' + ' ' + (lx + width / 2) + ' ' + (ly + height / 2) + ' ' + 'L' + '' + (lx + width / 2 + padding / 4) + ' ' + (ly + height / 2);\n      merge(options, {\n        'd': dir\n      });\n      break;\n    case 'UpArrow':\n      options.fill = options.stroke;\n      options.stroke = 'transparent';\n      dir = 'M' + ' ' + (lx + -width / 2) + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + lx + ' ' + (ly - height / 2) + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + (ly + height / 2) + 'L' + ' ' + (lx + width / 2 - space) + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + lx + ' ' + (ly - height / 2 + 2 * space) + 'L' + (lx - width / 2 + space) + ' ' + (ly + height / 2) + ' Z';\n      merge(options, {\n        'd': dir\n      });\n      break;\n    case 'DownArrow':\n      dir = 'M' + ' ' + (lx - width / 2) + ' ' + (ly - height / 2) + ' ' + 'L' + ' ' + lx + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + (ly - height / 2) + 'L' + ' ' + (lx + width / 2 - space) + ' ' + (ly - height / 2) + ' ' + 'L' + ' ' + lx + ' ' + (ly + height / 2 - 2 * space) + 'L' + (lx - width / 2 + space) + ' ' + (ly - height / 2) + ' Z';\n      merge(options, {\n        'd': dir\n      });\n      break;\n    case 'RightArrow':\n      dir = 'M' + ' ' + (lx + -width / 2) + ' ' + (ly - height / 2) + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + ly + ' ' + 'L' + ' ' + (lx + -width / 2) + ' ' + (ly + height / 2) + ' L' + ' ' + (lx + -width / 2) + ' ' + (ly + height / 2 - space) + ' ' + 'L' + ' ' + (lx + width / 2 - 2 * space) + ' ' + ly + ' L' + (lx + -width / 2) + ' ' + (ly - height / 2 + space) + ' Z';\n      merge(options, {\n        'd': dir\n      });\n      break;\n    case 'LeftArrow':\n      options.fill = options.stroke;\n      options.stroke = 'transparent';\n      dir = 'M' + ' ' + (lx + width / 2) + ' ' + (ly - height / 2) + ' ' + 'L' + ' ' + (lx + -width / 2) + ' ' + ly + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + (lx + width / 2) + ' ' + (ly + height / 2 - space) + ' L' + ' ' + (lx + -width / 2 + 2 * space) + ' ' + ly + ' L' + (lx + width / 2) + ' ' + (ly - height / 2 + space) + ' Z';\n      merge(options, {\n        'd': dir\n      });\n      break;\n    case 'Column':\n    case 'Pareto':\n    case 'StackingColumn':\n    case 'StackingColumn100':\n    case 'RangeColumn':\n    case 'Histogram':\n      dir = 'M' + ' ' + (lx - 3 * (width / 5)) + ' ' + (ly - height / 5) + ' ' + 'L' + ' ' + (lx + 3 * (-width / 10)) + ' ' + (ly - height / 5) + ' ' + 'L' + ' ' + (lx + 3 * (-width / 10)) + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + (lx - 3 * (width / 5)) + ' ' + (ly + height / 2) + ' ' + 'Z' + ' ' + 'M' + ' ' + (lx + -width / 10 - width / 20) + ' ' + (ly - height / 4 - padding / 2) + ' ' + 'L' + ' ' + (lx + width / 10 + width / 20) + ' ' + (ly - height / 4 - padding / 2) + ' ' + 'L' + ' ' + (lx + width / 10 + width / 20) + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + (lx + -width / 10 - width / 20) + ' ' + (ly + height / 2) + ' ' + 'Z' + ' ' + 'M' + ' ' + (lx + 3 * (width / 10)) + ' ' + ly + ' ' + 'L' + ' ' + (lx + 3 * (width / 5)) + ' ' + ly + ' ' + 'L' + ' ' + (lx + 3 * (width / 5)) + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + (lx + 3 * (width / 10)) + ' ' + (ly + height / 2) + ' ' + 'Z';\n      merge(options, {\n        'd': dir\n      });\n      break;\n    case 'Bar':\n    case 'StackingBar':\n    case 'StackingBar100':\n      dir = 'M' + ' ' + (lx + -width / 2 + -padding / 4) + ' ' + (ly - 3 * (height / 5)) + ' ' + 'L' + ' ' + (lx + 3 * (width / 10)) + ' ' + (ly - 3 * (height / 5)) + ' ' + 'L' + ' ' + (lx + 3 * (width / 10)) + ' ' + (ly - 3 * (height / 10)) + ' ' + 'L' + ' ' + (lx - width / 2 + -padding / 4) + ' ' + (ly - 3 * (height / 10)) + ' ' + 'Z' + ' ' + 'M' + ' ' + (lx + -width / 2 + -padding / 4) + ' ' + (ly - height / 5 + padding / 20) + ' ' + 'L' + ' ' + (lx + width / 2 + padding / 4) + ' ' + (ly - height / 5 + padding / 20) + ' ' + 'L' + ' ' + (lx + width / 2 + padding / 4) + ' ' + (ly + height / 10 + padding / 20) + ' ' + 'L' + ' ' + (lx - width / 2 + -padding / 4) + ' ' + (ly + height / 10 + padding / 20) + ' ' + 'Z' + ' ' + 'M' + ' ' + (lx - width / 2 + -padding / 4) + ' ' + (ly + height / 5 + padding / 10) + ' ' + 'L' + ' ' + (lx + -width / 4) + ' ' + (ly + height / 5 + padding / 10) + ' ' + 'L' + ' ' + (lx + -width / 4) + ' ' + (ly + height / 2 + padding / 10) + ' ' + 'L' + ' ' + (lx - width / 2 + -padding / 4) + ' ' + (ly + height / 2 + padding / 10) + ' ' + 'Z';\n      merge(options, {\n        'd': dir\n      });\n      break;\n    case 'Spline':\n      options.fill = 'transparent';\n      dir = 'M' + ' ' + (lx - width / 2) + ' ' + (ly + height / 5) + ' ' + 'Q' + ' ' + lx + ' ' + (ly - height) + ' ' + lx + ' ' + (ly + height / 5) + ' ' + 'M' + ' ' + lx + ' ' + (ly + height / 5) + ' ' + 'Q' + ' ' + (lx + width / 2) + ' ' + (ly + height / 2) + ' ' + (lx + width / 2) + ' ' + (ly - height / 2);\n      merge(options, {\n        'd': dir\n      });\n      break;\n    case 'Area':\n    case 'MultiColoredArea':\n    case 'RangeArea':\n    case 'StackingArea':\n    case 'StackingArea100':\n      dir = 'M' + ' ' + (lx - width / 2 - padding / 4) + ' ' + (ly + height / 2) + ' ' + 'L' + ' ' + (lx + -width / 4 + -padding / 8) + ' ' + (ly - height / 2) + ' ' + 'L' + ' ' + lx + ' ' + (ly + height / 4) + ' ' + 'L' + ' ' + (lx + width / 4 + padding / 8) + ' ' + (ly + -height / 2 + height / 4) + ' ' + 'L' + ' ' + (lx + height / 2 + padding / 4) + ' ' + (ly + height / 2) + ' ' + 'Z';\n      merge(options, {\n        'd': dir\n      });\n      break;\n    case 'SplineArea':\n    case 'SplineRangeArea':\n      dir = 'M' + ' ' + (lx - width / 2) + ' ' + (ly + height / 5) + ' ' + 'Q' + ' ' + lx + ' ' + (ly - height) + ' ' + lx + ' ' + (ly + height / 5) + ' ' + 'Z' + ' ' + 'M' + ' ' + lx + ' ' + (ly + height / 5) + ' ' + 'Q' + ' ' + (lx + width / 2) + ' ' + (ly + height / 2) + ' ' + (lx + width / 2) + ' ' + (ly - height / 2) + ' ' + ' Z';\n      merge(options, {\n        'd': dir\n      });\n      break;\n    case 'Pie':\n    case 'Doughnut':\n      {\n        options.stroke = 'transparent';\n        var r = Math.min(height, width) / 2;\n        dir = getAccumulationLegend(lx, ly, r, height, width);\n        merge(options, {\n          'd': dir\n        });\n        break;\n      }\n  }\n  return {\n    renderOption: options\n  };\n}\n/**\r\n * Trims the text to fit within the specified maximum width.\r\n *\r\n * @param {number} maxWidth - The maximum width for the text.\r\n * @param {string} text - The text to be trimmed.\r\n * @param {FontModel} font - The font settings for the text.\r\n * @param {boolean} isRtlEnabled - Indicates whether right-to-left text rendering is enabled.\r\n * @param {FontModel} [themeFontStyle] - The font style to be used for theme-specific settings.\r\n * @returns {string} - The trimmed text.\r\n */\nexport function textTrim(maxWidth, text, font, isRtlEnabled, themeFontStyle) {\n  var label = text;\n  var size = measureText(text, font, themeFontStyle).width;\n  if (size > maxWidth) {\n    var textLength = text.length;\n    for (var i = textLength - 1; i >= 0; --i) {\n      label = isRtlEnabled ? '...' + text.substring(0, i) : text.substring(0, i) + '...';\n      size = measureText(label, font, themeFontStyle).width;\n      if (size <= maxWidth) {\n        return label;\n      }\n    }\n  }\n  return label;\n}\n/**\r\n * Trims the text and performs line breaks based on the maximum width and font settings.\r\n *\r\n * @param {number} maxWidth - The maximum width allowed for the text.\r\n * @param {string} text - The text to be trimmed.\r\n * @param {FontModel} font - The font settings for the text.\r\n * @param {FontModel} [themeFontStyle] - Optional. The font style based on the theme.\r\n * @returns {string[]} - An array of trimmed text lines with line breaks.\r\n */\nexport function lineBreakLabelTrim(maxWidth, text, font, themeFontStyle) {\n  var labelCollection = [];\n  var breakLabels = text.split('<br>');\n  for (var i = 0; i < breakLabels.length; i++) {\n    text = breakLabels[i];\n    var size = measureText(text, font, themeFontStyle).width;\n    if (size > maxWidth) {\n      var textLength = text.length;\n      for (var i_1 = textLength - 1; i_1 >= 0; --i_1) {\n        text = text.substring(0, i_1) + '...';\n        size = measureText(text, font, themeFontStyle).width;\n        if (size <= maxWidth) {\n          labelCollection.push(text);\n          break;\n        }\n      }\n    } else {\n      labelCollection.push(text);\n    }\n  }\n  return labelCollection;\n}\n/**\r\n * Converts a string value to a number, considering the container size for percentage values.\r\n *\r\n * @param {string} value - The string value to convert to a number.\r\n * @param {number} containerSize - The size of the container, used for percentage values.\r\n * @returns {number} - The converted numeric value.\r\n */\nexport function stringToNumber(value, containerSize) {\n  if (value !== null && value !== undefined) {\n    return value.indexOf('%') !== -1 ? containerSize / 100 * parseInt(value, 10) : parseInt(value, 10);\n  }\n  return null;\n}\n/**\r\n * Redraws the SVG or canvas element based on the provided options.\r\n *\r\n * @param {boolean} redraw - Specifies whether to redraw the element.\r\n * @param {string} id - The id of the element to redraw.\r\n * @param {PathAttributes | RectAttributes | CircleAttributes} [options] - The attributes of the element to redraw.\r\n * @param {SvgRenderer | CanvasRenderer} [renderer] - The renderer to use for redrawing.\r\n * @returns {Element} - The redrawn element.\r\n */\nexport function redrawElement(redraw, id, options, renderer) {\n  if (!redraw) {\n    return null;\n  }\n  var element = getElement(id);\n  if (element && options) {\n    renderer.setElementAttributes(options, element.tagName === 'clipPath' ? element.childNodes[0] : element);\n  }\n  return element;\n}\n/**\r\n * Animates the redrawn element from its start to end location over a specified duration.\r\n *\r\n * @param {Element | HTMLElement} element - The element to animate.\r\n * @param {number} duration - The duration of the animation in milliseconds.\r\n * @param {ChartLocation} start - The start location of the element.\r\n * @param {ChartLocation} end - The end location of the element.\r\n * @param {string} [x='x'] - The attribute representing the horizontal position of the element.\r\n * @param {string} [y='y'] - The attribute representing the vertical position of the element.\r\n * @param {number} [angle=0] - The angle of rotation for the element.\r\n * @param {ChartLocation} [newTransform=new ChartLocation(0, 0)] - The new transform location of the element.\r\n * @param {ChartLocation} [previousTransform=new ChartLocation(0, 0)] - The previous transform location of the element.\r\n * @returns {void}\r\n */\nexport function animateRedrawElement(element, duration, start, end, x, y, angle, newTransform, previousTransform) {\n  if (x === void 0) {\n    x = 'x';\n  }\n  if (y === void 0) {\n    y = 'y';\n  }\n  if (angle === void 0) {\n    angle = 0;\n  }\n  if (newTransform === void 0) {\n    newTransform = new ChartLocation(0, 0);\n  }\n  if (previousTransform === void 0) {\n    previousTransform = new ChartLocation(0, 0);\n  }\n  var isDiv = element.tagName === 'DIV';\n  var setStyle = function (xValue, yValue, rotateX, rotateY) {\n    if (isDiv) {\n      element.style[x] = xValue + 'px';\n      element.style[y] = yValue + 'px';\n    } else {\n      element.setAttribute(x, xValue + '');\n      element.setAttribute(y, yValue + '');\n      if (angle && newTransform.x && newTransform.y && previousTransform.x && previousTransform.y && rotateX && rotateY) {\n        element.setAttribute('transform', 'rotate(' + angle + ',' + rotateX + ',' + rotateY + ')');\n      }\n    }\n  };\n  setStyle(start.x, start.y, previousTransform.x, previousTransform.y);\n  new Animation({}).animate(createElement('div'), {\n    duration: duration,\n    progress: function (args) {\n      setStyle(linear(args.timeStamp, start.x, end.x - start.x, args.duration), linear(args.timeStamp, start.y, end.y - start.y, args.duration), linear(args.timeStamp, previousTransform.x, newTransform.x - previousTransform.x, args.duration), linear(args.timeStamp, previousTransform.y, newTransform.y - previousTransform.y, args.duration));\n    },\n    end: function () {\n      setStyle(end.x, end.y, newTransform.x, newTransform.y);\n    }\n  });\n}\n/**\r\n * Renders a text element using the specified renderer and options.\r\n *\r\n * @param {SvgRenderer | CanvasRenderer} renderer - The renderer used for rendering.\r\n * @param {TextOption} option - The options for the text element.\r\n * @param {FontModel} font - The font settings for the text.\r\n * @param {string} color - The color of the text.\r\n * @param {HTMLElement | Element} parent - The parent element to which the text element is appended.\r\n * @param {boolean} [isMinus=false] - Indicates whether the text represents a negative value.\r\n * @param {boolean} [redraw] - Indicates whether to redraw the element.\r\n * @param {boolean} [isAnimate] - Indicates whether to animate the element.\r\n * @param {boolean} [forceAnimate=false] - Indicates whether to force animation.\r\n * @param {number} [animateDuration] - The duration of the animation in milliseconds.\r\n * @param {Rect} [seriesClipRect] - The clipping rectangle for the series.\r\n * @param {Size} [labelSize] - The size of the label.\r\n * @param {boolean} [isRotatedLabelIntersect] - Indicates whether rotated labels intersect.\r\n * @param {boolean} [isCanvas] - Indicates whether the rendering is done on a canvas.\r\n * @param {boolean} [isDataLabelWrap] - Indicates whether data labels are wrapped.\r\n * @param {FontModel} [themeFontStyle] - The font settings based on the theme.\r\n * @param {ChartLocation} [transform] - The location to transform the text element.\r\n * @returns {Element} - The rendered text element.\r\n */\nexport function textElement(renderer, option, font, color, parent, isMinus, redraw, isAnimate, forceAnimate, animateDuration, seriesClipRect, labelSize, isRotatedLabelIntersect, isCanvas, isDataLabelWrap, themeFontStyle, transform) {\n  if (isMinus === void 0) {\n    isMinus = false;\n  }\n  if (forceAnimate === void 0) {\n    forceAnimate = false;\n  }\n  var renderOptions = {};\n  var tspanElement;\n  //let renderer: SvgRenderer = new SvgRenderer('');\n  var height;\n  var dy;\n  var label;\n  var width = 0;\n  var dx;\n  var maxWidth = 0;\n  if (option.text.length > 1 && isDataLabelWrap) {\n    for (var i = 0, len = option.text.length; i < len; i++) {\n      maxWidth = Math.max(maxWidth, measureText(option.text[i], font, themeFontStyle).width);\n    }\n    width = measureText(option.text[0], font, themeFontStyle).width;\n  }\n  dx = option.text.length > 1 && isDataLabelWrap ? option.x + maxWidth / 2 - width / 2 : option.x;\n  renderOptions = {\n    'id': option.id,\n    'x': dx,\n    'y': option.y,\n    'fill': color ? color : 'black',\n    'font-size': font.size || themeFontStyle.size,\n    'font-style': font.fontStyle || themeFontStyle.fontStyle,\n    'font-family': font.fontFamily || themeFontStyle.fontFamily,\n    'font-weight': font.fontWeight || themeFontStyle.fontWeight,\n    'text-anchor': option.anchor,\n    'labelRotation': option.labelRotation,\n    'transform': option.transform,\n    'opacity': font.opacity,\n    'dominant-baseline': option.baseLine\n  };\n  var text = typeof option.text === 'string' ? option.text : isMinus ? option.text[option.text.length - 1] : option.text[0];\n  var transX = seriesClipRect ? seriesClipRect.x : 0;\n  var transY = seriesClipRect ? seriesClipRect.y : 0;\n  var htmlObject = renderer.createText(renderOptions, text, transX, transY);\n  if (typeof option.text !== 'string' && option.text.length > 1) {\n    for (var i = 1, len = option.text.length; i < len; i++) {\n      height = measureText(option.text[i], font, themeFontStyle).height;\n      width = measureText(option.text[i], font, themeFontStyle).width;\n      dy = option.y + (isMinus ? -(i * height) : i * height);\n      dx = isDataLabelWrap ? option.x + maxWidth / 2 - width / 2 : option.x;\n      label = isMinus ? option.text[option.text.length - (i + 1)] : option.text[i];\n      if (isCanvas) {\n        tspanElement = renderer.createText(renderOptions, label, null, null, dy, true);\n      } else {\n        tspanElement = renderer.createTSpan({\n          'x': dx,\n          'id': option.id,\n          'y': dy\n        }, label);\n        htmlObject.appendChild(tspanElement);\n      }\n    }\n  }\n  if (!isRotatedLabelIntersect) {\n    appendChildElement(renderer instanceof CanvasRenderer, parent, htmlObject, redraw, isAnimate, 'x', 'y', null, null, forceAnimate, false, null, animateDuration, false, option.labelRotation, transform);\n  }\n  return htmlObject;\n}\n/**\r\n * Calculates the size of the chart.\r\n *\r\n * @param {Chart | AccumulationChart | RangeNavigator | StockChart | Chart3D | CircularChart3D} chart - The chart for which to calculate the size.\r\n * @returns {void}\r\n */\nexport function calculateSize(chart) {\n  // fix for Chart rendered with default width in IE issue\n  var containerWidth = chart.element.clientWidth || chart.element.offsetWidth;\n  var containerHeight = chart.element.clientHeight;\n  if (chart.stockChart) {\n    containerWidth = chart.stockChart.availableSize.width;\n    containerHeight = chart.stockChart.availableSize.height;\n  }\n  var height = 450;\n  var marginHeight;\n  if (chart.getModuleName() === 'rangeNavigator') {\n    var range = chart;\n    var tooltipSpace = range.tooltip.enable ? 35 : 0;\n    var periodHeight = range.periodSelectorSettings.periods.length ? range.periodSelectorSettings.height : 0;\n    marginHeight = range.margin.top + range.margin.bottom + tooltipSpace;\n    var labelSize = measureText('tempString', range.labelStyle, range.themeStyle.axisLabelFont).height;\n    var labelPadding = 15;\n    height = (chart.series.length ? Browser.isDevice ? 80 : 120 : (range.enableGrouping ? 40 + labelPadding + labelSize : 40) + marginHeight) + periodHeight;\n    if (range.disableRangeSelector) {\n      height = periodHeight;\n    }\n    if (chart.stockChart && chart.stockChart.chart.axisCollections[1].labelPosition === 'Outside') {\n      var padding = chart.stockChart.chart.axisCollections[1].labelPadding + chart.stockChart.chart.axisCollections[1].lineStyle.width * 0.5;\n      chart.width = (chart.stockChart.availableSize.width - (chart.stockChart.chart.axisCollections[1].maxLabelSize.width + padding)).toString();\n    }\n  }\n  chart.availableSize = new Size(stringToNumber(chart.width, containerWidth) || containerWidth || 600, stringToNumber(chart.height, containerHeight || height) || containerHeight || height);\n  if (chart.getModuleName() === 'chart') {\n    var scaleX = 1;\n    var scaleY = 1;\n    if (chart.width === '' || chart.width === null || chart.width === '100%') {\n      if (containerWidth && chart.element.parentElement.style.transform.indexOf('scale') > -1) {\n        scaleX = 1;\n      } else {\n        scaleX = chart.element.getBoundingClientRect().width > 0 ? chart.element.getBoundingClientRect().width / chart.availableSize.width : 1;\n      }\n      if (containerHeight && chart.element.parentElement.style.transform.indexOf('scale') > -1) {\n        scaleY = 1;\n      } else {\n        scaleY = chart.element.getBoundingClientRect().height > 0 ? chart.element.getBoundingClientRect().height / chart.availableSize.height : 1;\n      }\n      var transformValue = chart.element.style.transform;\n      if (transformValue) {\n        var scaleValue = parseFloat(transformValue.match(/scale\\((.*?)\\)/)[1]);\n        scaleX = scaleValue ? scaleX / scaleValue : scaleX;\n        scaleY = scaleValue ? scaleY / scaleValue : scaleY;\n      }\n      chart.availableSize.width = chart.availableSize.width * scaleX;\n      chart.availableSize.height = chart.availableSize.height * scaleY;\n    }\n    chart.scaleX = scaleX;\n    chart.scaleY = scaleY;\n  }\n}\n/**\r\n * Creates an SVG element for the specified chart or chart element.\r\n *\r\n * @param {Chart | AccumulationChart | RangeNavigator | Chart3D | CircularChart3D} chart - The chart or chart element for which to create the SVG element.\r\n * @returns {void}\r\n */\nexport function createSvg(chart) {\n  chart.canvasRender = new CanvasRenderer(chart.element.id);\n  chart.renderer = chart.enableCanvas ? chart.canvasRender : new SvgRenderer(chart.element.id);\n  calculateSize(chart);\n  if (chart.stockChart && chart.getModuleName() === 'chart') {\n    chart.svgObject = chart.stockChart.chartObject;\n  } else if (chart.stockChart && chart.getModuleName() === 'rangeNavigator') {\n    chart.svgObject = chart.stockChart.selectorObject;\n  } else {\n    if (chart.enableCanvas) {\n      chart.svgObject = chart.renderer.createCanvas({\n        id: chart.element.id + '_canvas',\n        width: chart.availableSize.width,\n        height: chart.availableSize.height\n      });\n    } else {\n      chart.svgObject = chart.renderer.createSvg({\n        id: chart.element.id + '_svg',\n        width: chart.availableSize.width,\n        height: chart.availableSize.height\n      });\n    }\n  }\n  if (chart.enableCanvas) {\n    chart.renderer.ctx.direction = chart.enableRtl ? 'rtl' : 'ltr';\n  }\n}\n/**\r\n * Gets the title text with specified style and width, and supports right-to-left rendering.\r\n *\r\n * @param {string} title - The title text.\r\n * @param {FontModel} style - The font style for the title.\r\n * @param {number} width - The width available for rendering the title.\r\n * @param {boolean} isRtlEnabled - Specifies whether right-to-left rendering is enabled.\r\n * @param {FontModel} [themeFontStyle] - The font style used for theme rendering.\r\n * @returns {string[]} An array of strings containing the title text with line breaks if needed.\r\n */\nexport function getTitle(title, style, width, isRtlEnabled, themeFontStyle) {\n  var titleCollection = [];\n  switch (style.textOverflow) {\n    case 'Wrap':\n      titleCollection = textWrap(title, width, style, isRtlEnabled, title.indexOf(' ') < 0 ? true : null, null, themeFontStyle);\n      break;\n    case 'Trim':\n      titleCollection.push(textTrim(width, title, style, isRtlEnabled, themeFontStyle));\n      break;\n    default:\n      titleCollection.push(title);\n      break;\n  }\n  return titleCollection;\n}\n/**\r\n * Calculates the x-coordinate position for rendering the title text within the specified rect.\r\n *\r\n * @param {Rect} rect - The rect within which the title text is to be rendered.\r\n * @param {FontModel} titleStyle - The font style used for rendering the title text.\r\n * @returns {number} The x-coordinate position for rendering the title text.\r\n */\nexport function titlePositionX(rect, titleStyle) {\n  var positionX;\n  if (titleStyle.textAlignment === 'Near') {\n    positionX = rect.x;\n  } else if (titleStyle.textAlignment === 'Center') {\n    positionX = rect.x + rect.width / 2;\n  } else {\n    positionX = rect.x + rect.width;\n  }\n  return positionX;\n}\n/**\r\n * Wraps the input text into multiple lines based on the specified maximum width and font style.\r\n *\r\n * @param {string} currentLabel - The text to be wrapped.\r\n * @param {number} maximumWidth - The maximum width allowed for each line of text.\r\n * @param {FontModel} font - The font style used for rendering the text.\r\n * @param {boolean} isRtlEnabled - Specifies whether right-to-left text direction is enabled.\r\n * @param {boolean} [wrapAnyWhere=false] - Indicates whether the text can be wrapped at any position.\r\n * @param {boolean} [clip=false] - Specifies whether text exceeding the maximum width should be clipped.\r\n * @param {FontModel} [themeFontStyle] - The font style used as the base for the text wrapping operation.\r\n * @returns {string[]} An array of strings representing the wrapped lines of text.\r\n */\nexport function textWrap(currentLabel, maximumWidth, font, isRtlEnabled, wrapAnyWhere, clip, themeFontStyle) {\n  if (wrapAnyWhere) {\n    return textWrapAnyWhere(currentLabel, maximumWidth, font, themeFontStyle);\n  } else {\n    var textCollection = currentLabel.split(' ');\n    var label = '';\n    var labelCollection = [];\n    var text = void 0;\n    for (var i = 0, len = textCollection.length; i < len; i++) {\n      text = textCollection[i];\n      if (measureText(label.concat(label === '' ? '' : ' ' + text), font, themeFontStyle).width < maximumWidth) {\n        label = label.concat((label === '' ? '' : ' ') + text);\n      } else {\n        if (label !== '') {\n          labelCollection.push(clip ? label : textTrim(maximumWidth, label, font, isRtlEnabled, themeFontStyle));\n          label = text;\n        } else {\n          labelCollection.push(clip ? text : textTrim(maximumWidth, text, font, isRtlEnabled, themeFontStyle));\n          text = '';\n        }\n      }\n      if (label && i === len - 1) {\n        labelCollection.push(clip ? label : textTrim(maximumWidth, label, font, isRtlEnabled, themeFontStyle));\n      }\n    }\n    return labelCollection;\n  }\n}\n/**\r\n * Wraps the input text into multiple lines, allowing wrapping at any position.\r\n *\r\n * @param {string} currentLabel - The text to be wrapped.\r\n * @param {number} maximumWidth - The maximum width allowed for each line of text.\r\n * @param {FontModel} font - The font style used for rendering the text.\r\n * @param {FontModel} [themeFontStyle] - The font style used as the base for the text wrapping operation.\r\n * @returns {string[]} An array of strings representing the wrapped lines of text.\r\n */\nexport function textWrapAnyWhere(currentLabel, maximumWidth, font, themeFontStyle) {\n  var size = measureText(currentLabel, font, themeFontStyle).width;\n  var labelCollection = [];\n  if (size > maximumWidth) {\n    var label = '';\n    var startIndex = 0;\n    var labelIndex = 1;\n    while (labelIndex < currentLabel.length) {\n      label = currentLabel.substring(startIndex, labelIndex);\n      size = measureText(label, font, themeFontStyle).width;\n      if (size < maximumWidth) {\n        labelIndex++;\n      } else if (size === maximumWidth) {\n        startIndex = labelIndex;\n        labelCollection.push(label);\n        labelIndex++;\n        label = '';\n      } else if (size > maximumWidth) {\n        label = label.slice(0, -1);\n        startIndex = labelIndex - 1;\n        labelCollection.push(label);\n        label = '';\n      }\n    }\n    if (label.length > 0) {\n      labelCollection.push(label);\n    }\n  } else {\n    labelCollection.push(currentLabel);\n  }\n  return labelCollection;\n}\n/**\r\n * Gets the Unicode text from the input string based on the provided regular expression.\r\n *\r\n * @param {string} text - The input string.\r\n * @param {RegExp} regexp - The regular expression pattern to match Unicode characters.\r\n * @returns {string} The Unicode text extracted from the input string.\r\n */\nexport function getUnicodeText(text, regexp) {\n  var title = text.replace(regexp, ' ');\n  var digit = text.match(regexp);\n  var digitSpecific = ' ';\n  var convertedText = ' ';\n  var k = 0;\n  var unicodeSub = {\n    '0': '\\u2080',\n    '1': '\\u2081',\n    '2': '\\u2082',\n    '3': '\\u2083',\n    '4': '\\u2084',\n    '5': '\\u2085',\n    '6': '\\u2086',\n    '7': '\\u2087',\n    '8': '\\u2088',\n    '9': '\\u2089'\n  };\n  var unicodeSup = {\n    '0': '\\u2070',\n    '1': '\\u00B9',\n    '2': '\\u00B2',\n    '3': '\\u00B3',\n    '4': '\\u2074',\n    '5': '\\u2075',\n    '6': '\\u2076',\n    '7': '\\u2077',\n    '8': '\\u2078',\n    '9': '\\u2079'\n  };\n  for (var i = 0; i <= title.length - 1; i++) {\n    if (title[i] === ' ') {\n      digitSpecific = regexp === regSub ? digit[k].replace(/~/g, '') : digit[k].replace(/\\^/g, '');\n      for (var j = 0; j < digitSpecific.length; j++) {\n        convertedText += regexp === regSub ? unicodeSub[digitSpecific[j]] : unicodeSup[digitSpecific[j]];\n      }\n      k++;\n    } else {\n      convertedText += title[i];\n    }\n  }\n  return convertedText.trim();\n}\n/**\r\n * Resets the Blazor templates of the given control (Chart or AccumulationChart).\r\n *\r\n * @param {Chart | AccumulationChart} control - The control to reset Blazor templates for.\r\n * @returns {void}\r\n */\nexport function blazorTemplatesReset(control) {\n  for (var i = 0; i < control.annotations.length; i++) {\n    resetBlazorTemplate((control.element.id + '_Annotation_' + i).replace(/[^a-zA-Z0-9]/g, ''), 'ContentTemplate');\n  }\n  //This reset the tooltip templates\n  resetBlazorTemplate(control.element.id + '_tooltipparent_template' + '_blazorTemplate', 'Template');\n  //Datalabel templates reset\n  resetBlazorTemplate(control.element.id + '_DataLabel');\n}\n/** @private */\nvar CustomizeOption = /** @class */function () {\n  function CustomizeOption(id) {\n    this.id = id;\n  }\n  return CustomizeOption;\n}();\nexport { CustomizeOption };\n/** @private */\nvar StackValues = /** @class */function () {\n  function StackValues(startValue, endValue) {\n    this.startValues = startValue;\n    this.endValues = endValue;\n  }\n  return StackValues;\n}();\nexport { StackValues };\n/** @private */\nvar RectOption = /** @class */function (_super) {\n  __extends(RectOption, _super);\n  function RectOption(id, fill, border, opacity, rect, rx, ry, transform, dashArray) {\n    var _this = _super.call(this, id, fill, border.width, border.color, opacity, dashArray) || this;\n    _this.y = rect.y;\n    _this.x = rect.x;\n    _this.height = rect.height;\n    _this.width = rect.width;\n    _this.rx = rx ? rx : 0;\n    _this.ry = ry ? ry : 0;\n    _this.transform = transform ? transform : '';\n    _this.stroke = border.width !== 0 && _this.stroke !== '' ? border.color === null ? '' : border.color : 'transparent';\n    return _this;\n  }\n  return RectOption;\n}(PathOption);\nexport { RectOption };\n/** @private */\nvar ImageOption = /** @class */function () {\n  function ImageOption(height, width, href, x, y, id, visibility, preserveAspectRatio) {\n    this.height = height;\n    this.width = width;\n    this.href = href;\n    this.x = x;\n    this.y = y;\n    this.id = id;\n    this.visibility = visibility;\n    this.preserveAspectRatio = preserveAspectRatio;\n  }\n  return ImageOption;\n}();\nexport { ImageOption };\n/** @private */\nvar CircleOption = /** @class */function (_super) {\n  __extends(CircleOption, _super);\n  function CircleOption(id, fill, border, opacity, cx, cy, r) {\n    var _this = _super.call(this, id, fill, border.width, border.color, opacity) || this;\n    _this.cy = cy;\n    _this.cx = cx;\n    _this.r = r;\n    return _this;\n  }\n  return CircleOption;\n}(PathOption);\nexport { CircleOption };\n/** @private */\nvar PolygonOption = /** @class */function () {\n  function PolygonOption(id, points, fill) {\n    this.id = id;\n    this.points = points;\n    this.fill = fill;\n  }\n  return PolygonOption;\n}();\nexport { PolygonOption };\n/** @private */\nvar ChartLocation = /** @class */function () {\n  function ChartLocation(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n  return ChartLocation;\n}();\nexport { ChartLocation };\n/** @private */\nvar LabelLocation = /** @class */function () {\n  function LabelLocation(x, y) {\n    this.x = 0;\n    this.y = 0;\n    this.x = x;\n    this.y = y;\n  }\n  return LabelLocation;\n}();\nexport { LabelLocation };\n/** @private */\nvar Thickness = /** @class */function () {\n  function Thickness(left, right, top, bottom) {\n    this.left = left;\n    this.right = right;\n    this.top = top;\n    this.bottom = bottom;\n  }\n  return Thickness;\n}();\nexport { Thickness };\n/** @private */\nvar ColorValue = /** @class */function () {\n  function ColorValue(r, g, b) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n  }\n  return ColorValue;\n}();\nexport { ColorValue };\n/** @private */\nvar PointData = /** @class */function () {\n  function PointData(point, series, index) {\n    if (index === void 0) {\n      index = 0;\n    }\n    this.point = point;\n    this.series = series;\n    this.lierIndex = index;\n  }\n  return PointData;\n}();\nexport { PointData };\n/** @private */\nvar AccPointData = /** @class */function () {\n  function AccPointData(point, series, index) {\n    if (index === void 0) {\n      index = 0;\n    }\n    this.point = point;\n    this.series = series;\n    this.index = index;\n  }\n  return AccPointData;\n}();\nexport { AccPointData };\n/** @private */\nvar Point3D = /** @class */function () {\n  /**\r\n   * Initializes a new instance of the Chart3DData class.\r\n   *\r\n   * @param {Chart3DPoint} point - The 3D point object.\r\n   * @param {Chart3DSeries} series - The 3D series object.\r\n   * @private\r\n   */\n  function Point3D(point, series) {\n    this.point = point;\n    this.series = series;\n  }\n  return Point3D;\n}();\nexport { Point3D };\n/** @private */\nvar ControlPoints = /** @class */function () {\n  function ControlPoints(controlPoint1, controlPoint2) {\n    this.controlPoint1 = controlPoint1;\n    this.controlPoint2 = controlPoint2;\n  }\n  return ControlPoints;\n}();\nexport { ControlPoints };\n/**\r\n * Gets the color from the range color setting model based on the specified value.\r\n *\r\n * @param {RangeColorSettingModel} colorMap - The range color setting model.\r\n * @param {number} value - The value for which to get the color.\r\n * @returns {string} - The color corresponding to the specified value.\r\n */\nexport function getColorByValue(colorMap, value) {\n  var color = '';\n  var rbgColorValue;\n  if (Number(value) === colorMap.start) {\n    color = colorMap.colors[0];\n  } else if (Number(value) === colorMap.end) {\n    color = colorMap.colors[colorMap.colors.length - 1];\n  } else {\n    rbgColorValue = getGradientColor(Number(value), colorMap);\n    color = convertToHexCode(rbgColorValue);\n  }\n  return color;\n}\n/**\r\n * Gets the gradient color from the range color setting model based on the specified value.\r\n *\r\n * @param {number} value - The value for which to get the gradient color.\r\n * @param {RangeColorSettingModel} colorMap - The range color setting model.\r\n * @returns {ColorValue} - The gradient color corresponding to the specified value.\r\n */\nexport function getGradientColor(value, colorMap) {\n  var previousOffset = colorMap.start;\n  var nextOffset = colorMap.end;\n  var percent = 0;\n  var full = nextOffset - previousOffset;\n  var midColor;\n  percent = (value - previousOffset) / full;\n  var previousColor;\n  var nextColor;\n  if (colorMap.colors.length <= 2) {\n    previousColor = colorMap.colors[0].charAt(0) === '#' ? colorMap.colors[0] : colorNameToHex(colorMap.colors[0]);\n    nextColor = colorMap.colors[colorMap.colors.length - 1].charAt(0) === '#' ? colorMap.colors[colorMap.colors.length - 1] : colorNameToHex(colorMap.colors[colorMap.colors.length - 1]);\n  } else {\n    previousColor = colorMap.colors[0].charAt(0) === '#' ? colorMap.colors[0] : colorNameToHex(colorMap.colors[0]);\n    nextColor = colorMap.colors[colorMap.colors.length - 1].charAt(0) === '#' ? colorMap.colors[colorMap.colors.length - 1] : colorNameToHex(colorMap.colors[colorMap.colors.length - 1]);\n    var a = full / (colorMap.colors.length - 1);\n    var b = void 0;\n    var c = void 0;\n    var length_2 = colorMap.colors.length - 1;\n    var splitColorValueOffset = [];\n    var splitColor = {};\n    for (var j = 1; j < length_2; j++) {\n      c = j * a;\n      b = previousOffset + c;\n      splitColor = {\n        b: b,\n        color: colorMap.colors[j]\n      };\n      splitColorValueOffset.push(splitColor);\n    }\n    for (var i = 0; i < splitColorValueOffset.length; i++) {\n      if (previousOffset <= value && value <= splitColorValueOffset[i]['b'] && i === 0) {\n        midColor = splitColorValueOffset[i]['color'].charAt(0) === '#' ? splitColorValueOffset[i]['color'] : colorNameToHex(splitColorValueOffset[i]['color']);\n        nextColor = midColor;\n        percent = value <= splitColorValueOffset[i]['b'] ? 1 - Math.abs((value - splitColorValueOffset[i]['b']) / a) : (value - splitColorValueOffset[i]['b']) / a;\n      } else if (splitColorValueOffset[i]['b'] <= value && value <= nextOffset && i === splitColorValueOffset.length - 1) {\n        midColor = splitColorValueOffset[i]['color'].charAt(0) === '#' ? splitColorValueOffset[i]['color'] : colorNameToHex(splitColorValueOffset[i]['color']);\n        previousColor = midColor;\n        percent = value < splitColorValueOffset[i]['b'] ? 1 - Math.abs((value - splitColorValueOffset[i]['b']) / a) : (value - splitColorValueOffset[i]['b']) / a;\n      }\n      if (i !== splitColorValueOffset.length - 1 && i < splitColorValueOffset.length) {\n        if (splitColorValueOffset[i]['b'] <= value && value <= splitColorValueOffset[i + 1]['b']) {\n          midColor = splitColorValueOffset[i]['color'].charAt(0) === '#' ? splitColorValueOffset[i]['color'] : colorNameToHex(splitColorValueOffset[i]['color']);\n          previousColor = midColor;\n          nextColor = splitColorValueOffset[i + 1]['color'].charAt(0) === '#' ? splitColorValueOffset[i + 1]['color'] : colorNameToHex(splitColorValueOffset[i + 1]['color']);\n          percent = Math.abs(value - splitColorValueOffset[i + 1]['b']) / a;\n        }\n      }\n    }\n  }\n  return getPercentageColor(percent, previousColor, nextColor);\n}\n/**\r\n * Calculates the color based on the percentage change between two values.\r\n *\r\n * @param {number} percent - The percentage change.\r\n * @param {string} previous - The color for the previous value.\r\n * @param {string} next - The color for the next value.\r\n * @returns {ColorValue} - The calculated color value.\r\n */\nexport function getPercentageColor(percent, previous, next) {\n  var nextColor = next.split('#')[1];\n  var prevColor = previous.split('#')[1];\n  var r = getPercentage(percent, parseInt(prevColor.substr(0, 2), 16), parseInt(nextColor.substr(0, 2), 16));\n  var g = getPercentage(percent, parseInt(prevColor.substr(2, 2), 16), parseInt(nextColor.substr(2, 2), 16));\n  var b = getPercentage(percent, parseInt(prevColor.substr(4, 2), 16), parseInt(nextColor.substr(4, 2), 16));\n  return new ColorValue(r, g, b);\n}\n/**\r\n * Calculates the percentage change between two values.\r\n *\r\n * @param {number} percent - The percentage to calculate.\r\n * @param {number} previous - The previous value.\r\n * @param {number} next - The next value.\r\n * @returns {number} - The calculated percentage change.\r\n */\nexport function getPercentage(percent, previous, next) {\n  var full = next - previous;\n  return Math.round(previous + full * percent);\n}\n/**\r\n * Gets the text anchor based on the specified alignment and Right-to-Left setting.\r\n *\r\n * @param {Alignment} alignment - The alignment of the text.\r\n * @param {boolean} enableRtl - Specifies whether Right-to-Left is enabled.\r\n * @returns {string} - The text anchor value.\r\n */\nexport function getTextAnchor(alignment, enableRtl) {\n  switch (alignment) {\n    case 'Near':\n      return enableRtl ? 'end' : 'start';\n    case 'Far':\n      return enableRtl ? 'start' : 'end';\n    default:\n      return 'middle';\n  }\n}","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","Animation","compile","templateComplier","Browser","merge","extend","isNullOrUndefined","resetBlazorTemplate","createElement","remove","Index","VisibleLabels","axisLabelRender","regSub","measureText","Rect","TextOption","Size","PathOption","SvgRenderer","CanvasRenderer","sort","data","fields","isDescending","sortData","i","length","j","Date","getTime","a","first","second","isBreakLabel","label","indexOf","getVisiblePoints","series","points","tempPoints","tempPoint","pointIndex","x","index","push","rotateTextSize","font","text","angle","chart","themeFontStyle","transformValue","element","style","transform","renderer","id","labelText","textCollection","height","dy","tspanElement","options","initialClipRect","y","size","fontStyle","fontFamily","fontWeight","split","htmlObject","createText","delayRedraw","redraw","stockChart","appendChild","svgObject","len","themeStyle","axisLabelFont","createTSpan","axisSvgObject","svgRenderer","createSvg","parentElement","document","body","box","getBoundingClientRect","pointsAdded","enableCanvas","textWidth","width","textHeight","angleInRadians","Math","PI","rotatedTextWidth","abs","cos","sin","rotatedTextHeight","right","left","bottom","top","removeElement","getElement","logBase","value","base","log","showTooltip","areaWidth","isTouch","isTitleOrLegendEnabled","bound","tooltip","getElementById","styles","toString","innerText","parseInt","replace","setTimeout","inside","range","max","min","withIn","logWithIn","axis","valueType","withInRange","previousPoint","currentPoint","nextPoint","mX2","xValue","xAxis","mX1","mX3","xStart","floor","visibleRange","xEnd","ceil","sum","values","_i","values_1","subArraySum","last","yName","subtractThickness","rect","thickness","subtractRect","degreeToLocation","degree","radius","center","radian","ChartLocation","degreeToRadian","getRotatedRectangleCoordinates","actualPoints","centerX","centerY","coordinatesAfterRotation","point","tempX","tempY","rotatedX","rotatedY","isRotatedRectIntersect","polygons","minA","maxA","projected","i1","minB","maxB","polygon","i2","p1","p2","normal","undefined","getAccumulationLegend","locX","locY","r","cartesianlarge","cartesiansmall","getAngle","atan2","subArray","valueToCoefficient","result","delta","isInverse","isChart","isAxisInverse","isInversed","TransformToVisible","yAxis","isInverted","labelPlacement","type","CoefficientToVector","valueToPolarCoefficient","primaryXAxis","startAngle","clipRect","indexFinder","isPoint","ids","coefficient","dateTimeInterval","interval","visibleLabels","Mean","verticalStandardMean","verticalSquareRoot","horizontalStandardMean","horizontalSquareRoot","verticalMean","horizontalMean","PolarArc","endAngle","innerRadius","currentXPosition","createTooltip","fontSize","innerHTML","setAttribute","createZoomingLabels","parent","isVertical","margin","opposedPosition","isAxisOpposedPosition","anchor","enableRtl","chartRect","availableSize","pathElement","rx","arrowLocation","direction","scrollBarHeight","scrollbarSettings","enable","zoomingScrollBar","isRtlEnabled","startLabel","endLabel","labelStyle","findCrosshairDirection","drawPath","crosshairFill","theme","shadowId","isIE","shadow","defElement","createDefs","textElement","color","crosshairLabelFont","rX","rY","arrowPadding","tipX","tipY","startX","startY","concat","withInBounds","bounds","getValueXByPoint","actualValue","getValueYByPoint","findClipRect","isCanvas","drawType","requireInvertedAxis","firstToLowerCase","str","substr","toLowerCase","getTransform","invertedAxis","getMinPointsDelta","seriesCollection","minDelta","Number","MAX_VALUE","xValues","minVal","seriesMin","stackingGroups","visible","name","xAxisName","stackingGroup","map","xMin","xMax","index_1","getAnimationFunction","effect","functionName","linear","currentTime","startValue","endValue","duration","markerAnimate","delay","isLabel","visibility","getAttribute","animate","progress","args","timeStamp","end","trigger","isBlazor","animateRectElement","currentRect","previousRect","setStyle","pathAnimation","previousDirection","animateDuration","startDirections","splitDirections","endDirections","currentDireciton","startPath","endPath","c","directions","animateAddPoints","removeDirection","currentDirection","startPathCommands","match","endPathCommands","maxLength","startPathCommand","endPathCommand","startCoords","trim","endCoords","interpolatedCoords","startCoord","parseFloat","endCoord","isNaN","interpolatedValue","join","appendClipElement","clipPath","clipElement","redrawElement","def","triggerLabelRender","tempInterval","argsData","cancel","isLineBreakLabels","text_1","enableTrim","lineBreakLabelTrim","maximumLabelWidth","textTrim","setRange","minimum","maximum","isZoomSet","zoomFactor","zoomPosition","getActualDesiredIntervalsCount","orientation","desiredIntervals","desiredIntervalsCount","maximumLabels","templateAnimate","isRemove","drawSymbol","location","shape","url","isChartControl","control","chartRenderer","shapeOption","calculateShapes","drawElement","renderOption","Int32Array","dir","isBulletChart","sizeBullet","targetWidth","lx","ly","eq","xVal","yVal","stroke","fill","calculateLegendShapes","getRectLocation","startLocation","endLocation","outerRect","minMax","getTemplateFunction","template","templateFn","querySelectorAll","querySelector","e","accReactTemplate","childElement","isTemplate","datalabelGroup","dataLabel","clientRect","accumulationDataLabelModule","calculateLabelSize","chartReactTemplate","labelIndex","category","dataLabelCollections","dataLabelModule","calculateTemplateLabelSize","marker","createTemplate","content","dataLabelId","templateElement","blazor","tempObject","window","templateId","elementData","slice","call","reactCallback","getModuleName","bind","isReact","renderReactTemplates","getFontStyle","opacity","measureElementRect","isReactCallback","findlElement","elements","length_1","getPoint","pow","xLength","yLength","locationX","locationY","appendElement","child","hasChildNodes","appendChildElement","isAnimate","start","forceAnimate","isRect","scatterElement","currentTransform","existChild","tagName","previousTranform","animateRedrawElement","replaceChild","getDraggedRectLocation","x1","y1","x2","y2","checkBounds","getLabelText","labelFormat","format","customLabelFormat","seriesType","chartAreaType","stackedValues","endValues","yValue","high","low","open","close","median","upperQuartile","lowerQuartile","_a","outliers","liers","useGroupingSeparator","intl","getNumberFormat","useGrouping","stopTimer","timer","clearInterval","isCollide","collections","some","isOverlap","containsRect","calculateRect","textSize","convertToHexCode","componentToHex","g","hex","convertHexToColor","exec","ColorValue","colorNameToHex","getComputedStyle","isRGBValue","checkColorFormat","rgbaValues","substring","lastIndexOf","every","val","num","test","getSaturationColor","factor","rgb","colorCode","round","applyZLight","RGB","toUpperCase","getMedian","half","padding","space","maxWidth","textLength","labelCollection","breakLabels","i_1","stringToNumber","containerSize","setElementAttributes","childNodes","newTransform","previousTransform","isDiv","rotateX","rotateY","option","isMinus","seriesClipRect","labelSize","isRotatedLabelIntersect","isDataLabelWrap","renderOptions","dx","labelRotation","baseLine","transX","transY","calculateSize","containerWidth","clientWidth","offsetWidth","containerHeight","clientHeight","marginHeight","tooltipSpace","periodHeight","periodSelectorSettings","periods","labelPadding","isDevice","enableGrouping","disableRangeSelector","axisCollections","labelPosition","lineStyle","maxLabelSize","scaleX","scaleY","scaleValue","canvasRender","chartObject","selectorObject","createCanvas","ctx","getTitle","title","titleCollection","textOverflow","textWrap","titlePositionX","titleStyle","positionX","textAlignment","currentLabel","maximumWidth","wrapAnyWhere","clip","textWrapAnyWhere","startIndex","getUnicodeText","regexp","digit","digitSpecific","convertedText","k","unicodeSub","unicodeSup","blazorTemplatesReset","annotations","CustomizeOption","StackValues","startValues","RectOption","_super","border","ry","dashArray","_this","ImageOption","href","preserveAspectRatio","CircleOption","cx","cy","PolygonOption","LabelLocation","Thickness","PointData","lierIndex","AccPointData","Point3D","ControlPoints","controlPoint1","controlPoint2","getColorByValue","colorMap","rbgColorValue","colors","getGradientColor","previousOffset","nextOffset","percent","full","midColor","previousColor","nextColor","charAt","length_2","splitColorValueOffset","splitColor","getPercentageColor","previous","next","prevColor","getPercentage","getTextAnchor","alignment"],"sources":["C:/Users/wiliam/Desktop/indiec-nuevo/fronted-vue/node_modules/@syncfusion/ej2-charts/src/common/utils/helper.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nimport { Animation, compile as templateComplier, Browser } from '@syncfusion/ej2-base';\r\nimport { merge, extend, isNullOrUndefined, resetBlazorTemplate } from '@syncfusion/ej2-base';\r\nimport { createElement, remove } from '@syncfusion/ej2-base';\r\nimport { Index } from '../../common/model/base';\r\nimport { VisibleLabels } from '../../chart/axis/axis';\r\nimport { axisLabelRender, regSub } from '../model/constants';\r\nimport { measureText, Rect, TextOption, Size, PathOption, SvgRenderer, CanvasRenderer } from '@syncfusion/ej2-svg-base';\r\n/**\r\n * Function to sort the dataSource, by default it sort the data in ascending order.\r\n *\r\n * @param  {Object} data chart data\r\n * @param  {string} fields date fields\r\n * @param  {boolean} isDescending boolean values of descending\r\n * @returns {Object[]} It returns chart data which be sorted.\r\n */\r\nexport function sort(data, fields, isDescending) {\r\n    var sortData = extend([], data, null);\r\n    for (var i = 0; i < sortData.length; i++) {\r\n        for (var j = 0; j < fields.length; j++) {\r\n            if (sortData[i][fields[j]] instanceof Date) {\r\n                sortData[i][fields[j]] = sortData[i][fields[j]].getTime();\r\n            }\r\n        }\r\n    }\r\n    sortData.sort(function (a, b) {\r\n        var first = 0;\r\n        var second = 0;\r\n        for (var i = 0; i < fields.length; i++) {\r\n            first += a[fields[i]];\r\n            second += b[fields[i]];\r\n        }\r\n        if ((!isDescending && first < second) || (isDescending && first > second)) {\r\n            return -1;\r\n        }\r\n        else if (first === second) {\r\n            return 0;\r\n        }\r\n        return 1;\r\n    });\r\n    return sortData;\r\n}\r\n/**\r\n * Checks if a label contains a line break.\r\n *\r\n * @param {string} label - The label to check.\r\n * @returns {boolean} - True if the label contains a line break, otherwise false.\r\n */\r\nexport function isBreakLabel(label) {\r\n    return label.indexOf('<br>') !== -1;\r\n}\r\n/**\r\n * Retrieves the visible data points from a series.\r\n *\r\n * @param {Series | Chart3DSeries} series - The series to retrieve the visible data points.\r\n * @returns {Points[]} - An array containing the visible data points.\r\n */\r\nexport function getVisiblePoints(series) {\r\n    var points = extend([], series.points, null, true);\r\n    var tempPoints = [];\r\n    var tempPoint;\r\n    var pointIndex = 0;\r\n    for (var i = 0; i < points.length; i++) {\r\n        tempPoint = points[i];\r\n        if (isNullOrUndefined(tempPoint.x)) {\r\n            continue;\r\n        }\r\n        else {\r\n            tempPoint.index = pointIndex++;\r\n            tempPoints.push(tempPoint);\r\n        }\r\n    }\r\n    return tempPoints;\r\n}\r\n/**\r\n * Rotates the size of text based on the provided angle.\r\n *\r\n * @param {FontModel} font - The font style of the text.\r\n * @param {string} text - The text to be rotated.\r\n * @param {number} angle - The angle of rotation.\r\n * @param {Chart | Chart3D} chart - The chart instance.\r\n * @param {FontModel} themeFontStyle - The font style based on the theme.\r\n * @returns {Size} - The rotated size of the text.\r\n */\r\nexport function rotateTextSize(font, text, angle, chart, themeFontStyle) {\r\n    var transformValue = chart.element.style.transform;\r\n    if (transformValue) {\r\n        chart.element.style.transform = '';\r\n    }\r\n    var renderer = new SvgRenderer(chart.element.id);\r\n    var labelText;\r\n    var textCollection = [];\r\n    var height;\r\n    var dy;\r\n    var label;\r\n    var tspanElement;\r\n    var options = {\r\n        id: 'rotate_text',\r\n        x: chart.initialClipRect.x,\r\n        y: chart.initialClipRect.y,\r\n        'font-size': font.size || themeFontStyle.size,\r\n        'font-style': font.fontStyle || themeFontStyle.fontStyle,\r\n        'font-family': font.fontFamily,\r\n        'font-weight': font.fontWeight || themeFontStyle.fontWeight,\r\n        'transform': 'rotate(' + angle + ', 0, 0)',\r\n        'text-anchor': 'middle'\r\n    };\r\n    if (isBreakLabel(text)) {\r\n        textCollection = text.split('<br>');\r\n        labelText = textCollection[0];\r\n    }\r\n    else {\r\n        labelText = text;\r\n    }\r\n    var htmlObject = renderer.createText(options, labelText);\r\n    if (!chart.delayRedraw && !chart.redraw && !chart.stockChart) {\r\n        chart.element.appendChild(chart.svgObject);\r\n    }\r\n    // for line break label\r\n    if (typeof textCollection !== 'string' && textCollection.length > 1) {\r\n        for (var i = 1, len = textCollection.length; i < len; i++) {\r\n            height = (measureText(textCollection[i], font, chart.themeStyle.axisLabelFont).height);\r\n            dy = (options.y) + ((i * height));\r\n            label = textCollection[i];\r\n            tspanElement = renderer.createTSpan({\r\n                'x': options.x, 'id': options.id,\r\n                'y': dy\r\n            }, label);\r\n            htmlObject.appendChild(tspanElement);\r\n        }\r\n    }\r\n    var axisSvgObject = chart.svgRenderer.createSvg({ id: 'AxisLabelMax_svg' });\r\n    if (chart.element.parentElement.style.transform.indexOf('scale') > -1) {\r\n        document.body.appendChild(axisSvgObject);\r\n        axisSvgObject.appendChild(htmlObject);\r\n    }\r\n    else {\r\n        chart.svgObject.appendChild(htmlObject);\r\n    }\r\n    var box = htmlObject.getBoundingClientRect();\r\n    if (transformValue) {\r\n        chart.element.style.transform = transformValue;\r\n    }\r\n    if (chart.element.parentElement.style.transform.indexOf('scale') > -1) {\r\n        remove(axisSvgObject);\r\n    }\r\n    else {\r\n        remove(htmlObject);\r\n    }\r\n    if (!chart.delayRedraw && !chart.redraw && !chart.stockChart && !chart.pointsAdded) {\r\n        remove(chart.svgObject);\r\n    }\r\n    if (chart.enableCanvas) {\r\n        var textWidth = measureText(text, font, chart.themeStyle.axisLabelFont).width;\r\n        var textHeight = measureText(text, font, chart.themeStyle.axisLabelFont).height;\r\n        var angleInRadians = (angle * Math.PI) / 180; // Convert the rotation angle to radians\r\n        var rotatedTextWidth = Math.abs(Math.cos(angleInRadians) * textWidth) + Math.abs(Math.sin(angleInRadians) * textHeight);\r\n        var rotatedTextHeight = Math.abs(Math.sin(angleInRadians) * textWidth) + Math.abs(Math.cos(angleInRadians) * textHeight);\r\n        return new Size(rotatedTextWidth, rotatedTextHeight);\r\n    }\r\n    return new Size((box.right - box.left), (box.bottom - box.top));\r\n}\r\n/**\r\n * Removes the specified element.\r\n *\r\n * @param {string | Element} id - The id or reference of the element to be removed.\r\n * @returns {void}\r\n */\r\nexport function removeElement(id) {\r\n    if (!id) {\r\n        return null;\r\n    }\r\n    var element = typeof id === 'string' ? getElement(id) : id;\r\n    if (element) {\r\n        remove(element);\r\n    }\r\n}\r\n/**\r\n * Calculates the logarithm of a specified value with respect to a specified base.\r\n *\r\n * @param {number} value - The value for which to calculate the logarithm.\r\n * @param {number} base - The base of the logarithm.\r\n * @returns {number} - The logarithm of the value with respect to the specified base.\r\n */\r\nexport function logBase(value, base) {\r\n    return Math.log(value) / Math.log(base);\r\n}\r\n/**\r\n * Displays a tooltip at the specified coordinates with the given text.\r\n *\r\n * @param {string} text - The text content of the tooltip.\r\n * @param {number} x - The x-coordinate where the tooltip should be displayed.\r\n * @param {number} y - The y-coordinate where the tooltip should be displayed.\r\n * @param {number} areaWidth - The width of the area where the tooltip is displayed.\r\n * @param {string} id - The id of the tooltip element.\r\n * @param {Element} element - The element to which the tooltip is appended.\r\n * @param {boolean} isTouch - Indicates whether the tooltip is displayed on a touch device.\r\n * @param {boolean} isTitleOrLegendEnabled - Indicates whether the tooltip is enabled for title or legend.\r\n * @returns {void}\r\n */\r\nexport function showTooltip(text, x, y, areaWidth, id, element, isTouch, isTitleOrLegendEnabled, bound) {\r\n    //let id1: string = 'EJ2_legend_tooltip';\r\n    var tooltip = document.getElementById(id);\r\n    var size = measureText(text, {\r\n        fontFamily: 'Segoe UI', size: '12px',\r\n        fontStyle: 'Normal', fontWeight: 'Regular'\r\n    });\r\n    var width = size.width + 5;\r\n    x = (x + width > areaWidth) ? x - (width + 15) : x;\r\n    if (bound && x < bound.x) {\r\n        x = bound.x;\r\n    }\r\n    y = isTitleOrLegendEnabled ? (y - size.height / 2) : y + 15;\r\n    if (!tooltip) {\r\n        tooltip = createElement('div', {\r\n            id: id,\r\n            styles: 'top:' + (y).toString() + 'px;left:' + (x + 15).toString() +\r\n                'px;background-color: rgb(255, 255, 255) !important; color:black !important; ' +\r\n                'position:absolute;border:1px solid rgb(112, 112, 112); padding-left : 3px; padding-right : 2px;' +\r\n                'padding-bottom : 2px; padding-top : 2px; font-size:12px; font-family: \"Segoe UI\"'\r\n        });\r\n        tooltip.innerText = text;\r\n        element.appendChild(tooltip);\r\n        var left = parseInt(tooltip.style.left.replace('px', ''), 10);\r\n        if (left < 0) {\r\n            tooltip.style.left = '0px';\r\n        }\r\n    }\r\n    else {\r\n        tooltip.innerText = text;\r\n        tooltip.style.top = (y).toString() + 'px';\r\n        tooltip.style.left = (x + 15).toString() + 'px';\r\n    }\r\n    if (isTouch) {\r\n        setTimeout(function () { removeElement(id); }, 1500);\r\n    }\r\n}\r\n/**\r\n * Checks if a value is within the specified range.\r\n *\r\n * @param {number} value - The value to check.\r\n * @param {VisibleRangeModel} range - The range to check against.\r\n * @returns {boolean} - True if the value is inside the range, otherwise false.\r\n */\r\nexport function inside(value, range) {\r\n    return (value < range.max) && (value > range.min);\r\n}\r\n/**\r\n * Checks if a value is within the specified range.\r\n *\r\n * @param {number} value - The value to check.\r\n * @param {VisibleRangeModel} range - The range to check against.\r\n * @returns {boolean} - True if the value is inside the range, otherwise false.\r\n */\r\nexport function withIn(value, range) {\r\n    return (value <= range.max) && (value >= range.min);\r\n}\r\n/**\r\n * Adjusts the value based on the axis type.\r\n *\r\n * @param {number} value - The value to adjust.\r\n * @param {Axis} axis - The axis used for adjustment.\r\n * @returns {number} - The adjusted value.\r\n */\r\nexport function logWithIn(value, axis) {\r\n    return axis.valueType === 'Logarithmic' ? logBase(value, axis.logBase) : value;\r\n}\r\n/**\r\n * Checks if a point is within the range of the previous and next points in a series.\r\n *\r\n * @param {Points} previousPoint - The previous point in the series.\r\n * @param {Points} currentPoint - The current point to check.\r\n * @param {Points} nextPoint - The next point in the series.\r\n * @param {Series} series - The series to which the points belong.\r\n * @returns {boolean} - A boolean indicating if the point is within the range.\r\n */\r\nexport function withInRange(previousPoint, currentPoint, nextPoint, series) {\r\n    var mX2 = logWithIn(currentPoint.xValue, series.xAxis);\r\n    var mX1 = previousPoint ? logWithIn(previousPoint.xValue, series.xAxis) : mX2;\r\n    var mX3 = nextPoint ? logWithIn(nextPoint.xValue, series.xAxis) : mX2;\r\n    var xStart = Math.floor(series.xAxis.visibleRange.min);\r\n    var xEnd = Math.ceil(series.xAxis.visibleRange.max);\r\n    return ((mX1 >= xStart && mX1 <= xEnd) || (mX2 >= xStart && mX2 <= xEnd) ||\r\n        (mX3 >= xStart && mX3 <= xEnd) || (xStart >= mX1 && xStart <= mX3));\r\n}\r\n/**\r\n * Calculates the sum of an array of numbers.\r\n *\r\n * @param {number[]} values - An array of numbers.\r\n * @returns {number} - The sum of the numbers in the array.\r\n */\r\nexport function sum(values) {\r\n    var sum = 0;\r\n    for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\r\n        var value = values_1[_i];\r\n        sum += value;\r\n    }\r\n    return sum;\r\n}\r\n/**\r\n * Calculates the sum of elements in a subarray.\r\n *\r\n * @param {Object[]} values - The array containing elements.\r\n * @param {number} first - The index of the first element in the subarray.\r\n * @param {number} last - The index of the last element in the subarray.\r\n * @param {number[]} index - The array of indices.\r\n * @param {Series} series - The series object.\r\n * @returns {number} - The sum of elements in the subarray.\r\n */\r\nexport function subArraySum(values, first, last, index, series) {\r\n    var sum = 0;\r\n    if (index !== null) {\r\n        for (var i = (first + 1); i < last; i++) {\r\n            if (index.indexOf(i) === -1) {\r\n                sum += values[i][series.yName];\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        for (var i = (first + 1); i < last; i++) {\r\n            if (!isNullOrUndefined(values[i][series.yName])) {\r\n                sum += values[i][series.yName];\r\n            }\r\n        }\r\n    }\r\n    return sum;\r\n}\r\n/**\r\n * Subtracts thickness from the given rectangle.\r\n *\r\n * @param {Rect} rect - The rectangle from which to subtract thickness.\r\n * @param {Thickness} thickness - The thickness to subtract.\r\n * @returns {Rect} - The resulting rectangle after subtracting thickness.\r\n */\r\nexport function subtractThickness(rect, thickness) {\r\n    rect.x += thickness.left;\r\n    rect.y += thickness.top;\r\n    rect.width -= thickness.left + thickness.right;\r\n    rect.height -= thickness.top + thickness.bottom;\r\n    return rect;\r\n}\r\n/**\r\n * Subtracts a rectangle representing thickness from the given rectangle.\r\n *\r\n * @param {Rect} rect - The rectangle from which to subtract the thickness rectangle.\r\n * @param {Thickness} thickness - The rectangle representing the thickness to subtract.\r\n * @returns {Rect} - The resulting rectangle after subtracting the thickness rectangle.\r\n */\r\nexport function subtractRect(rect, thickness) {\r\n    rect.x += thickness.x;\r\n    rect.y += thickness.y;\r\n    rect.width -= thickness.x + thickness.width;\r\n    rect.height -= thickness.y + thickness.height;\r\n    return rect;\r\n}\r\n/**\r\n * Converts a degree value to a location on the chart based on the provided radius and center point.\r\n *\r\n * @param {number} degree - The degree value to convert.\r\n * @param {number} radius - The radius from the center point.\r\n * @param {ChartLocation} center - The center point of the chart.\r\n * @returns {ChartLocation} - The location on the chart corresponding to the degree value.\r\n */\r\nexport function degreeToLocation(degree, radius, center) {\r\n    var radian = (degree * Math.PI) / 180;\r\n    return new ChartLocation(Math.cos(radian) * radius + center.x, Math.sin(radian) * radius + center.y);\r\n}\r\n/**\r\n * Converts a degree value to radians.\r\n *\r\n * @param {number} degree - The degree value to convert.\r\n * @returns {number} - The equivalent value in radians.\r\n */\r\nexport function degreeToRadian(degree) {\r\n    return degree * (Math.PI / 180);\r\n}\r\n/**\r\n * Get the coordinates of a rotated rectangle.\r\n *\r\n * @param {ChartLocation[]} actualPoints - The coordinates of the original rectangle.\r\n * @param {number} centerX - The x-coordinate of the center of rotation.\r\n * @param {number} centerY - The y-coordinate of the center of rotation.\r\n * @param {number} angle - The angle of rotation in degrees.\r\n * @returns {ChartLocation[]} - The coordinates of the rotated rectangle.\r\n */\r\nexport function getRotatedRectangleCoordinates(actualPoints, centerX, centerY, angle) {\r\n    var coordinatesAfterRotation = [];\r\n    for (var i = 0; i < 4; i++) {\r\n        var point = actualPoints[i];\r\n        // translate point to origin\r\n        var tempX = point.x - centerX;\r\n        var tempY = point.y - centerY;\r\n        // now apply rotation\r\n        var rotatedX = tempX * Math.cos(degreeToRadian(angle)) - tempY * Math.sin(degreeToRadian(angle));\r\n        var rotatedY = tempX * Math.sin(degreeToRadian(angle)) + tempY * Math.cos(degreeToRadian(angle));\r\n        // translate back\r\n        point.x = rotatedX + centerX;\r\n        point.y = rotatedY + centerY;\r\n        coordinatesAfterRotation.push(new ChartLocation(point.x, point.y));\r\n    }\r\n    return coordinatesAfterRotation;\r\n}\r\n/**\r\n * Helper function to determine whether there is an intersection between the two polygons described\r\n * by the lists of vertices. Uses the Separating Axis Theorem.\r\n *\r\n * @param {ChartLocation[]} a an array of connected points [{x:, y:}, {x:, y:},...] that form a closed polygon\r\n * @param {ChartLocation[]} b an array of connected points [{x:, y:}, {x:, y:},...] that form a closed polygon\r\n * @returns {boolean} if there is any intersection between the 2 polygons, false otherwise\r\n */\r\nexport function isRotatedRectIntersect(a, b) {\r\n    var polygons = [a, b];\r\n    var minA;\r\n    var maxA;\r\n    var projected;\r\n    var i;\r\n    var i1;\r\n    var j;\r\n    var minB;\r\n    var maxB;\r\n    for (i = 0; i < polygons.length; i++) {\r\n        // for each polygon, look at each edge of the polygon, and determine if it separates\r\n        // the two shapes\r\n        var polygon = polygons[i];\r\n        for (i1 = 0; i1 < polygon.length; i1++) {\r\n            // grab 2 vertices to create an edge\r\n            var i2 = (i1 + 1) % polygon.length;\r\n            var p1 = polygon[i1];\r\n            var p2 = polygon[i2];\r\n            // find the line perpendicular to this edge\r\n            var normal = new ChartLocation(p2.y - p1.y, p1.x - p2.x);\r\n            minA = maxA = undefined;\r\n            // for each vertex in the first shape, project it onto the line perpendicular to the edge\r\n            // and keep track of the min and max of these values\r\n            for (j = 0; j < a.length; j++) {\r\n                projected = normal.x * a[j].x + normal.y * a[j].y;\r\n                if (isNullOrUndefined(minA) || projected < minA) {\r\n                    minA = projected;\r\n                }\r\n                if (isNullOrUndefined(maxA) || projected > maxA) {\r\n                    maxA = projected;\r\n                }\r\n            }\r\n            // for each vertex in the second shape, project it onto the line perpendicular to the edge\r\n            // and keep track of the min and max of these values\r\n            minB = maxB = undefined;\r\n            for (j = 0; j < b.length; j++) {\r\n                projected = normal.x * b[j].x + normal.y * b[j].y;\r\n                if (isNullOrUndefined(minB) || projected < minB) {\r\n                    minB = projected;\r\n                }\r\n                if (isNullOrUndefined(maxB) || projected > maxB) {\r\n                    maxB = projected;\r\n                }\r\n            }\r\n            // if there is no overlap between the projects, the edge we are looking at separates the two\r\n            // polygons, and we know there is no overlap\r\n            if (maxA < minB || maxB < minA) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Generates the legend for accumulation chart.\r\n *\r\n * @param {number} locX - The x-coordinate of the legend position.\r\n * @param {number} locY - The y-coordinate of the legend position.\r\n * @param {number} r - The radius of the chart.\r\n * @param {number} height - The height of the legend.\r\n * @param {number} width - The width of the legend.\r\n * @returns {string} - The generated legend.\r\n */\r\nfunction getAccumulationLegend(locX, locY, r, height, width) {\r\n    var cartesianlarge = degreeToLocation(270, r, new ChartLocation(locX, locY));\r\n    var cartesiansmall = degreeToLocation(270, r, new ChartLocation(locX + (width / 10), locY));\r\n    return 'M' + ' ' + locX + ' ' + locY + ' ' + 'L' + ' ' + (locX + r) + ' ' + (locY) + ' ' + 'A' + ' ' + (r) + ' ' + (r) +\r\n        ' ' + 0 + ' ' + 1 + ' ' + 1 + ' ' + cartesianlarge.x + ' ' + cartesianlarge.y + ' ' + 'Z' + ' ' + 'M' + ' ' + (locX +\r\n        (width / 10)) + ' ' + (locY - (height / 10)) + ' ' + 'L' + (locX + (r)) + ' ' + (locY - height / 10) + ' ' + 'A' + ' '\r\n        + (r) + ' ' + (r) + ' ' + 0 + ' ' + 0 + ' ' + 0 + ' ' + cartesiansmall.x + ' ' + cartesiansmall.y + ' ' + 'Z';\r\n}\r\n/**\r\n * Calculates the angle between two points.\r\n *\r\n * @param {ChartLocation} center - The center point.\r\n * @param {ChartLocation} point - The point to calculate the angle from the center.\r\n * @returns {number} - The angle in degrees.\r\n */\r\nexport function getAngle(center, point) {\r\n    var angle = Math.atan2((point.y - center.y), (point.x - center.x));\r\n    angle = angle < 0 ? (6.283 + angle) : angle;\r\n    return angle * (180 / Math.PI);\r\n}\r\n/**\r\n * Returns a sub-array of values starting from the specified index.\r\n *\r\n * @param {number[]} values - The array of numbers.\r\n * @param {number} index - The index from which the sub-array starts.\r\n * @returns {number[]} - The sub-array of values.\r\n */\r\nexport function subArray(values, index) {\r\n    var subArray = [];\r\n    for (var i = 0; i <= index - 1; i++) {\r\n        subArray.push(values[i]);\r\n    }\r\n    return subArray;\r\n}\r\n/**\r\n * Converts a value to its corresponding coefficient based on the axis range.\r\n *\r\n * @param {number} value - The value to be converted.\r\n * @param {Axis} axis - The axis object containing range information.\r\n * @returns {number} - The coefficient value corresponding to the input value.\r\n */\r\nexport function valueToCoefficient(value, axis) {\r\n    var range = axis.visibleRange;\r\n    var result = (value - range.min) / (range.delta);\r\n    var isInverse = axis.isChart ? axis.isAxisInverse : axis.isInversed;\r\n    return isInverse ? (1 - result) : result;\r\n}\r\n/**\r\n * Transforms a point to its visible position based on the axes range and inversion.\r\n *\r\n * @param {number} x - The x-coordinate of the point.\r\n * @param {number} y - The y-coordinate of the point.\r\n * @param {Axis} xAxis - The x-axis object containing range information.\r\n * @param {Axis} yAxis - The y-axis object containing range information.\r\n * @param {boolean} [isInverted=false] - Specifies if the chart is inverted.\r\n * @param {Series} [series] - The series object for additional information (optional).\r\n * @returns {ChartLocation} - The transformed visible position of the point.\r\n */\r\nexport function TransformToVisible(x, y, xAxis, yAxis, isInverted, series) {\r\n    x = (xAxis.valueType === 'Logarithmic' ? logBase(x > 1 ? x : 1, xAxis.logBase) : x);\r\n    y = (yAxis.valueType === 'Logarithmic' ?\r\n        logBase(y > 1 ? y : 1, yAxis.logBase) : y);\r\n    x += xAxis.valueType === 'Category' && xAxis.labelPlacement === 'BetweenTicks' && series.type !== 'Radar' ? 0.5 : 0;\r\n    var radius = series.chart.radius * valueToCoefficient(y, yAxis);\r\n    var point = CoefficientToVector(valueToPolarCoefficient(x, xAxis), series.chart.primaryXAxis.startAngle);\r\n    return {\r\n        x: (series.clipRect.width / 2 + series.clipRect.x) + radius * point.x,\r\n        y: (series.clipRect.height / 2 + series.clipRect.y) + radius * point.y\r\n    };\r\n}\r\n/**\r\n * Finds the index from the given id.\r\n *\r\n * @param {string} id - The id to search for.\r\n * @param {boolean} [isPoint=false] - Specifies if the id represents a data point (optional).\r\n * @returns {Index} - The index found from the id.\r\n */\r\nexport function indexFinder(id, isPoint) {\r\n    if (isPoint === void 0) { isPoint = false; }\r\n    var ids = ['NaN', 'NaN'];\r\n    if (id.indexOf('_Point_') > -1) {\r\n        ids = id.split('_Series_')[1].split('_Point_');\r\n    }\r\n    else if (id.indexOf('_shape_') > -1 && (!isPoint || (isPoint && id.indexOf('_legend_') === -1))) {\r\n        ids = id.split('_shape_');\r\n        ids[0] = '0';\r\n    }\r\n    else if (id.indexOf('_text_') > -1 && (!isPoint || (isPoint && id.indexOf('_legend_') === -1))) {\r\n        ids = id.split('_text_');\r\n        ids[0] = '0';\r\n    }\r\n    return new Index(parseInt(ids[0], 10), parseInt(ids[1], 10));\r\n}\r\n/**\r\n * Converts a coefficient value to a vector representing a point on the circumference of a circle.\r\n *\r\n * @param {number} coefficient - The coefficient value to convert.\r\n * @param {number} startAngle - The starting angle of the circle.\r\n * @returns {ChartLocation} - The vector representing the point on the circle.\r\n */\r\nexport function CoefficientToVector(coefficient, startAngle) {\r\n    startAngle = startAngle < 0 ? startAngle + 360 : startAngle;\r\n    var angle = Math.PI * (1.5 - 2 * coefficient);\r\n    angle = angle + (startAngle * Math.PI) / 180;\r\n    return { x: Math.cos(angle), y: Math.sin(angle) };\r\n}\r\n/**\r\n * Converts a value to a polar coefficient value based on the axis.\r\n *\r\n * @param {number} value - The value to convert.\r\n * @param {Axis} axis - The axis object.\r\n * @returns {number} - The polar coefficient value.\r\n */\r\nexport function valueToPolarCoefficient(value, axis) {\r\n    var range = axis.visibleRange;\r\n    var delta;\r\n    var length;\r\n    if (axis.valueType !== 'Category') {\r\n        delta = (range.max - (axis.valueType === 'DateTime' ? axis.dateTimeInterval : range.interval)) - range.min;\r\n        length = axis.visibleLabels.length - 1;\r\n        delta = delta === 0 ? 1 : delta;\r\n    }\r\n    else {\r\n        // To split an interval equally based on visible labels count\r\n        delta = axis.visibleLabels.length === 1 ? 1 :\r\n            (axis.visibleLabels[axis.visibleLabels.length - 1].value - axis.visibleLabels[0].value);\r\n        length = axis.visibleLabels.length;\r\n    }\r\n    return axis.isAxisInverse ? ((value - range.min) / delta) * (1 - 1 / (length)) :\r\n        1 - ((value - range.min) / delta) * (1 - 1 / (length));\r\n}\r\n/** @private */\r\nvar Mean = /** @class */ (function () {\r\n    function Mean(verticalStandardMean, verticalSquareRoot, horizontalStandardMean, horizontalSquareRoot, verticalMean, horizontalMean) {\r\n        this.verticalStandardMean = verticalStandardMean;\r\n        this.horizontalStandardMean = horizontalStandardMean;\r\n        this.verticalSquareRoot = verticalSquareRoot;\r\n        this.horizontalSquareRoot = horizontalSquareRoot;\r\n        this.verticalMean = verticalMean;\r\n        this.horizontalMean = horizontalMean;\r\n    }\r\n    return Mean;\r\n}());\r\nexport { Mean };\r\n/** @private */\r\nvar PolarArc = /** @class */ (function () {\r\n    function PolarArc(startAngle, endAngle, innerRadius, radius, currentXPosition) {\r\n        this.startAngle = startAngle;\r\n        this.endAngle = endAngle;\r\n        this.innerRadius = innerRadius;\r\n        this.radius = radius;\r\n        this.currentXPosition = currentXPosition;\r\n    }\r\n    return PolarArc;\r\n}());\r\nexport { PolarArc };\r\n/**\r\n * Creates a tooltip element with the specified id, text, position, and font size.\r\n *\r\n * @param {string} id - The id of the tooltip element.\r\n * @param {string} text - The text content of the tooltip.\r\n * @param {number} top - The top position of the tooltip.\r\n * @param {number} left - The left position of the tooltip.\r\n * @param {string} fontSize - The font size of the tooltip text.\r\n * @returns {void}\r\n */\r\nexport function createTooltip(id, text, top, left, fontSize) {\r\n    var tooltip = getElement(id);\r\n    var style = 'top:' + top.toString() + 'px;' +\r\n        'left:' + left.toString() + 'px;' +\r\n        'color:black !important; ' +\r\n        'background:#FFFFFF !important; ' +\r\n        'position:absolute;border:1px solid #707070;font-size:' + fontSize + ';border-radius:2px; z-index:1';\r\n    if (!tooltip) {\r\n        tooltip = createElement('div', {\r\n            id: id, innerHTML: '&nbsp;' + text + '&nbsp;', styles: style\r\n        });\r\n        document.body.appendChild(tooltip);\r\n    }\r\n    else {\r\n        tooltip.setAttribute('innerHTML', '&nbsp;' + text + '&nbsp;');\r\n        tooltip.setAttribute('styles', style);\r\n    }\r\n}\r\n/**\r\n * Creates zooming labels for the specified axis and adds them to the parent element.\r\n *\r\n * @param {Chart} chart - The chart instance.\r\n * @param {Axis} axis - The axis for which to create zooming labels.\r\n * @param {Element} parent - The parent element to which the labels will be appended.\r\n * @param {number} index - The index of the label.\r\n * @param {boolean} isVertical - Indicates whether the axis is vertical.\r\n * @param {Rect} rect - The bounding rectangle of the label.\r\n * @returns {Element} - The created zooming label element.\r\n */\r\nexport function createZoomingLabels(chart, axis, parent, index, isVertical, rect) {\r\n    var margin = 5;\r\n    var opposedPosition = axis.isAxisOpposedPosition;\r\n    var anchor = chart.enableRtl ? 'end' : isVertical ? 'start' : 'auto';\r\n    var size;\r\n    var chartRect = chart.availableSize.width;\r\n    var pathElement;\r\n    var x;\r\n    var y;\r\n    var rx = 3;\r\n    var arrowLocation;\r\n    var direction;\r\n    var scrollBarHeight = axis.scrollbarSettings.enable || (axis.zoomingScrollBar && axis.zoomingScrollBar.svgObject)\r\n        ? axis.scrollBarHeight : 0;\r\n    var isRtlEnabled = (chart.enableRtl && !isVertical && !axis.isInversed) ||\r\n        (axis.isInversed && !(chart.enableRtl && !isVertical));\r\n    for (var i = 0; i < 2; i++) {\r\n        size = measureText(i ? (isRtlEnabled ? axis.startLabel : axis.endLabel) : (isRtlEnabled ? axis.endLabel : axis.startLabel), axis.labelStyle, chart.themeStyle.axisLabelFont);\r\n        if (isVertical) {\r\n            arrowLocation = i ? new ChartLocation(rect.x - scrollBarHeight, rect.y + rx) :\r\n                new ChartLocation(axis.rect.x - scrollBarHeight, (rect.y + rect.height - rx));\r\n            x = (rect.x + (opposedPosition ? (rect.width + margin + scrollBarHeight) : -(size.width + margin + margin + scrollBarHeight)));\r\n            y = (rect.y + (i ? 0 : rect.height - size.height - margin));\r\n            x += (x < 0 || ((chartRect) < (x + size.width + margin))) ? (opposedPosition ? -(size.width / 2) : size.width / 2) : 0;\r\n            direction = findCrosshairDirection(rx, rx, new Rect(x, y, size.width + margin, size.height + margin), arrowLocation, margin, false, false, !opposedPosition, arrowLocation.x, arrowLocation.y + (i ? -rx : rx));\r\n        }\r\n        else {\r\n            arrowLocation = i ? new ChartLocation((rect.x + rect.width - rx), (rect.y + rect.height + scrollBarHeight)) :\r\n                new ChartLocation(rect.x + rx, (rect.y + rect.height + scrollBarHeight));\r\n            x = (rect.x + (i ? (rect.width - size.width - margin) : 0));\r\n            y = (opposedPosition ? (rect.y - size.height - 10 - scrollBarHeight) : (rect.y + rect.height + margin + scrollBarHeight));\r\n            direction = findCrosshairDirection(rx, rx, new Rect(x, y, size.width + margin, size.height + margin), arrowLocation, margin, opposedPosition, !opposedPosition, false, arrowLocation.x + (i ? rx : -rx), arrowLocation.y);\r\n        }\r\n        x = x + (margin / 2);\r\n        y = y + (3 * (size.height / 4)) + (margin / 2);\r\n        pathElement = chart.renderer.drawPath({\r\n            'id': chart.element.id + '_Zoom_' + index + '_AxisLabel_Shape_' + i,\r\n            'fill': chart.themeStyle.crosshairFill, 'width': 2, 'color': chart.themeStyle.crosshairFill,\r\n            'opacity': 1, 'stroke-dasharray': null, 'd': direction\r\n        }, null);\r\n        parent.appendChild(pathElement);\r\n        if (chart.theme === 'Fluent' || chart.theme === 'FluentDark') {\r\n            var shadowId = chart.element.id + '_shadow';\r\n            pathElement.setAttribute('filter', Browser.isIE ? '' : 'url(#' + shadowId + ')');\r\n            var shadow = '<filter id=\"' + shadowId + '\" height=\"130%\"><feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"3\"/>';\r\n            shadow += '<feOffset dx=\"3\" dy=\"3\" result=\"offsetblur\"/><feComponentTransfer><feFuncA type=\"linear\" slope=\"0.5\"/>';\r\n            shadow += '</feComponentTransfer><feMerge><feMergeNode/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\r\n            var defElement = chart.renderer.createDefs();\r\n            defElement.setAttribute('id', chart.element.id + 'SVG_tooltip_definition');\r\n            parent.appendChild(defElement);\r\n            defElement.innerHTML = shadow;\r\n            pathElement.setAttribute('stroke', '#cccccc');\r\n            pathElement.setAttribute('stroke-width', '0.5');\r\n        }\r\n        textElement(chart.renderer, new TextOption(chart.element.id + '_Zoom_' + index + '_AxisLabel_' + i, x, y, anchor, i ? (isRtlEnabled ? axis.startLabel : axis.endLabel) : (isRtlEnabled ? axis.endLabel : axis.startLabel)), { color: chart.themeStyle.crosshairLabelFont.color, fontFamily: 'Segoe UI', fontWeight: 'Regular', size: '11px' }, chart.themeStyle.crosshairLabelFont.color, parent, null, null, null, null, null, null, null, null, null, null, chart.themeStyle.crosshairLabelFont);\r\n    }\r\n    return parent;\r\n}\r\n/**\r\n * Finds the direction of the crosshair based on the provided parameters.\r\n *\r\n * @param {number} rX - The x-coordinate of the crosshair line.\r\n * @param {number} rY - The y-coordinate of the crosshair line.\r\n * @param {Rect} rect - The bounding rectangle of the crosshair.\r\n * @param {ChartLocation} arrowLocation - The location of the arrow in the crosshair.\r\n * @param {number} arrowPadding - The padding for the arrow.\r\n * @param {boolean} top - Indicates whether the crosshair is positioned at the top.\r\n * @param {boolean} bottom - Indicates whether the crosshair is positioned at the bottom.\r\n * @param {boolean} left - Indicates whether the crosshair is positioned at the left.\r\n * @param {number} tipX - The x-coordinate of the crosshair tip.\r\n * @param {number} tipY - The y-coordinate of the crosshair tip.\r\n * @returns {string} - The direction of the crosshair ('Top', 'Bottom', 'Left', 'Right', 'Center').\r\n */\r\nexport function findCrosshairDirection(rX, rY, rect, arrowLocation, arrowPadding, top, bottom, left, tipX, tipY) {\r\n    var direction = '';\r\n    var startX = rect.x;\r\n    var startY = rect.y;\r\n    var width = rect.x + rect.width;\r\n    var height = rect.y + rect.height;\r\n    if (top) {\r\n        direction = direction.concat('M' + ' ' + (startX) + ' ' + (startY + rY) + ' Q ' + startX + ' '\r\n            + startY + ' ' + (startX + rX) + ' ' + startY);\r\n        direction = direction.concat(' L' + ' ' + (width - rX) + ' ' + (startY) + ' Q ' + width + ' '\r\n            + startY + ' ' + (width) + ' ' + (startY + rY));\r\n        direction = direction.concat(' L' + ' ' + (width) + ' ' + (height - rY) + ' Q ' + width + ' '\r\n            + (height) + ' ' + (width - rX) + ' ' + (height));\r\n        if (arrowPadding !== 0) {\r\n            direction = direction.concat(' L' + ' ' + (arrowLocation.x + arrowPadding / 2) + ' ' + (height));\r\n            direction = direction.concat(' L' + ' ' + (tipX) + ' ' + (height + arrowPadding)\r\n                + ' L' + ' ' + (arrowLocation.x - arrowPadding / 2) + ' ' + height);\r\n        }\r\n        if ((arrowLocation.x - arrowPadding / 2) > startX) {\r\n            direction = direction.concat(' L' + ' ' + (startX + rX) + ' ' + height + ' Q ' + startX + ' '\r\n                + height + ' ' + (startX) + ' ' + (height - rY) + ' z');\r\n        }\r\n        else {\r\n            if (arrowPadding === 0) {\r\n                direction = direction.concat(' L' + ' ' + (startX + rX) + ' ' + height + ' Q ' + startX + ' '\r\n                    + height + ' ' + (startX) + ' ' + (height - rY) + ' z');\r\n            }\r\n            else {\r\n                direction = direction.concat(' L' + ' ' + (startX) + ' ' + (height + rY) + ' z');\r\n            }\r\n        }\r\n    }\r\n    else if (bottom) {\r\n        direction = direction.concat('M' + ' ' + (startX) + ' ' + (startY + rY) + ' Q ' + startX + ' '\r\n            + (startY) + ' ' + (startX + rX) + ' ' + (startY) + ' L' + ' ' + (arrowLocation.x - arrowPadding / 2) + ' ' + (startY));\r\n        direction = direction.concat(' L' + ' ' + (tipX) + ' ' + (arrowLocation.y));\r\n        direction = direction.concat(' L' + ' ' + (arrowLocation.x + arrowPadding / 2) + ' ' + (startY));\r\n        direction = direction.concat(' L' + ' ' + (width - rX) + ' ' + (startY)\r\n            + ' Q ' + (width) + ' ' + (startY) + ' ' + (width) + ' ' + (startY + rY));\r\n        direction = direction.concat(' L' + ' ' + (width) + ' ' + (height - rY) + ' Q ' + (width) + ' '\r\n            + (height) + ' ' + (width - rX) + ' ' + (height));\r\n        direction = direction.concat(' L' + ' ' + (startX + rX) + ' ' + (height) + ' Q ' + (startX) + ' '\r\n            + (height) + ' ' + (startX) + ' ' + (height - rY) + ' z');\r\n    }\r\n    else if (left) {\r\n        direction = direction.concat('M' + ' ' + (startX) + ' ' + (startY + rY) + ' Q ' + startX + ' '\r\n            + (startY) + ' ' + (startX + rX) + ' ' + (startY));\r\n        direction = direction.concat(' L' + ' ' + (width - rX) + ' ' + (startY) + ' Q ' + (width) + ' '\r\n            + (startY) + ' ' + (width) + ' ' + (startY + rY) + ' L' + ' ' + (width) + ' ' + (arrowLocation.y - arrowPadding / 2));\r\n        direction = direction.concat(' L' + ' ' + (width + arrowPadding) + ' ' + (tipY));\r\n        direction = direction.concat(' L' + ' ' + (width) + ' ' + (arrowLocation.y + arrowPadding / 2));\r\n        direction = direction.concat(' L' + ' ' + (width) + ' ' + (height - rY) + ' Q ' + width + ' ' + (height) + ' ' + (width - rX) + ' ' + (height));\r\n        direction = direction.concat(' L' + ' ' + (startX + rX) + ' ' + (height) + ' Q ' + startX + ' '\r\n            + (height) + ' ' + (startX) + ' ' + (height - rY) + ' z');\r\n    }\r\n    else {\r\n        direction = direction.concat('M' + ' ' + (startX + rX) + ' ' + (startY) + ' Q ' + (startX) + ' '\r\n            + (startY) + ' ' + (startX) + ' ' + (startY + rY) + ' L' + ' ' + (startX) + ' ' + (arrowLocation.y - arrowPadding / 2));\r\n        direction = direction.concat(' L' + ' ' + (startX - arrowPadding) + ' ' + (tipY));\r\n        direction = direction.concat(' L' + ' ' + (startX) + ' ' + (arrowLocation.y + arrowPadding / 2));\r\n        direction = direction.concat(' L' + ' ' + (startX) + ' ' + (height - rY) + ' Q ' + startX + ' '\r\n            + (height) + ' ' + (startX + rX) + ' ' + (height));\r\n        direction = direction.concat(' L' + ' ' + (width - rX) + ' ' + (height) + ' Q ' + width + ' '\r\n            + (height) + ' ' + (width) + ' ' + (height - rY));\r\n        direction = direction.concat(' L' + ' ' + (width) + ' ' + (startY + rY) + ' Q ' + width + ' '\r\n            + (startY) + ' ' + (width - rX) + ' ' + (startY) + ' z');\r\n    }\r\n    return direction;\r\n}\r\n//Within bounds\r\n/**\r\n * Checks if the provided coordinates are within the bounds of the rectangle.\r\n *\r\n * @param {number} x - The x-coordinate to check.\r\n * @param {number} y - The y-coordinate to check.\r\n * @param {Rect} bounds - The bounding rectangle.\r\n * @param {number} width - The width of the area to include in the bounds check.\r\n * @param {number} height - The height of the area to include in the bounds check.\r\n * @returns {boolean} - Returns true if the coordinates are within the bounds; otherwise, false.\r\n */\r\nexport function withInBounds(x, y, bounds, width, height) {\r\n    if (width === void 0) { width = 0; }\r\n    if (height === void 0) { height = 0; }\r\n    return (x >= bounds.x - width && x <= bounds.x + bounds.width + width && y >= bounds.y - height\r\n        && y <= bounds.y + bounds.height + height);\r\n}\r\n/**\r\n * Gets the x-coordinate value for a given point value on the axis.\r\n *\r\n * @param {number} value - The point value.\r\n * @param {number} size - The size of the axis.\r\n * @param {Axis} axis - The axis.\r\n * @returns {number} - Returns the x-coordinate value.\r\n */\r\nexport function getValueXByPoint(value, size, axis) {\r\n    var actualValue = !axis.isAxisInverse ? value / size : (1 - (value / size));\r\n    return actualValue * (axis.visibleRange.delta) + axis.visibleRange.min;\r\n}\r\n/**\r\n * Gets the y-coordinate value for a given point value on the axis.\r\n *\r\n * @param {number} value - The point value.\r\n * @param {number} size - The size of the axis.\r\n * @param {Axis} axis - The axis.\r\n * @returns {number} - Returns the y-coordinate value.\r\n */\r\nexport function getValueYByPoint(value, size, axis) {\r\n    var actualValue = axis.isAxisInverse ? value / size : (1 - (value / size));\r\n    return actualValue * (axis.visibleRange.delta) + axis.visibleRange.min;\r\n}\r\n/**\r\n * Finds the clip rectangle for a series.\r\n *\r\n * @param {Series} series - The series for which to find the clip rectangle.\r\n * @param {boolean} isCanvas - Indicates whether the rendering is on a canvas.\r\n * @returns {void}\r\n */\r\nexport function findClipRect(series, isCanvas) {\r\n    if (isCanvas === void 0) { isCanvas = false; }\r\n    var rect = series.clipRect;\r\n    if (isCanvas && (series.type === 'Polar' || series.type === 'Radar')) {\r\n        if (series.drawType === 'Scatter') {\r\n            rect.x = series.xAxis.rect.x;\r\n            rect.y = series.yAxis.rect.y;\r\n            rect.width = series.xAxis.rect.width;\r\n            rect.height = series.yAxis.rect.height;\r\n        }\r\n        else {\r\n            rect.x = series.xAxis.rect.x / 2;\r\n            rect.y = series.yAxis.rect.y / 2;\r\n            rect.width = series.xAxis.rect.width;\r\n            rect.height = series.yAxis.rect.height;\r\n        }\r\n    }\r\n    else {\r\n        if (series.chart.requireInvertedAxis) {\r\n            rect.x = series.yAxis.rect.x;\r\n            rect.y = series.xAxis.rect.y;\r\n            rect.width = series.yAxis.rect.width;\r\n            rect.height = series.xAxis.rect.height;\r\n        }\r\n        else {\r\n            rect.x = series.xAxis.rect.x;\r\n            rect.y = series.yAxis.rect.y;\r\n            rect.width = series.xAxis.rect.width;\r\n            rect.height = series.yAxis.rect.height;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Converts the first character of a string to lowercase.\r\n *\r\n * @param {string} str - The string to convert.\r\n * @returns {string} The converted string.\r\n */\r\nexport function firstToLowerCase(str) {\r\n    return str.substr(0, 1).toLowerCase() + str.substr(1);\r\n}\r\n/**\r\n * Gets the transformation of the chart area based on the provided axes and inverted axis state.\r\n *\r\n * @param {Axis} xAxis - The X-axis of the chart.\r\n * @param {Axis} yAxis - The Y-axis of the chart.\r\n * @param {boolean} invertedAxis - Indicates whether the chart axis is inverted.\r\n * @returns {Rect} The transformed chart area.\r\n */\r\nexport function getTransform(xAxis, yAxis, invertedAxis) {\r\n    var x;\r\n    var y;\r\n    var width;\r\n    var height;\r\n    if (invertedAxis) {\r\n        x = yAxis.rect.x;\r\n        y = xAxis.rect.y;\r\n        width = yAxis.rect.width;\r\n        height = xAxis.rect.height;\r\n    }\r\n    else {\r\n        x = xAxis.rect.x;\r\n        y = yAxis.rect.y;\r\n        width = xAxis.rect.width;\r\n        height = yAxis.rect.height;\r\n    }\r\n    return new Rect(x, y, width, height);\r\n}\r\n/**\r\n * Calculates the minimum points delta between data points on the provided axis.\r\n *\r\n * @param {Axis | Chart3DAxis} axis - The axis for which to calculate the minimum points delta.\r\n * @param {Series[]} seriesCollection - The collection of series in the chart.\r\n * @returns {number} The minimum points delta.\r\n */\r\nexport function getMinPointsDelta(axis, seriesCollection) {\r\n    var minDelta = Number.MAX_VALUE;\r\n    var xValues;\r\n    var minVal;\r\n    var seriesMin;\r\n    var stackingGroups = [];\r\n    for (var index = 0; index < seriesCollection.length; index++) {\r\n        var series = seriesCollection[index];\r\n        xValues = [];\r\n        if (series.visible &&\r\n            (axis.name === series.xAxisName || (axis.name === 'primaryXAxis' && series.xAxisName === null)\r\n                || (axis.name === series.chart.primaryXAxis.name && !series.xAxisName))) {\r\n            if (series.type.indexOf('Stacking') > -1 && stackingGroups.indexOf(series.stackingGroup) === -1) {\r\n                stackingGroups.push(series.stackingGroup);\r\n            }\r\n            xValues = series.points.map(function (point) {\r\n                return point.xValue;\r\n            });\r\n            xValues.sort(function (first, second) { return first - second; });\r\n            if (xValues.length === 1) {\r\n                seriesMin = (axis.valueType === 'DateTime' && series.xMin === series.xMax) ? (series.xMin - 25920000) : series.xMin;\r\n                minVal = xValues[0] - (!isNullOrUndefined(seriesMin) ?\r\n                    seriesMin : axis.visibleRange.min);\r\n                if (minVal !== 0) {\r\n                    minDelta = Math.min(minDelta, minVal);\r\n                }\r\n            }\r\n            else {\r\n                for (var index_1 = 0; index_1 < xValues.length; index_1++) {\r\n                    var value = xValues[index_1];\r\n                    if (index_1 > 0 && value) {\r\n                        minVal = series.type.indexOf('Stacking') > -1 && axis.valueType === 'Category' ? stackingGroups.length : value - xValues[index_1 - 1];\r\n                        if (minVal !== 0) {\r\n                            minDelta = Math.min(minDelta, minVal);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (minDelta === Number.MAX_VALUE) {\r\n        minDelta = 1;\r\n    }\r\n    return minDelta;\r\n}\r\n/**\r\n * Retrieves the animation function based on the specified effect.\r\n *\r\n * @param {string} effect - The name of the animation effect.\r\n * @returns {Function} The animation function corresponding to the effect.\r\n */\r\nexport function getAnimationFunction(effect) {\r\n    var functionName;\r\n    switch (effect) {\r\n        case 'Linear':\r\n            functionName = linear;\r\n            break;\r\n    }\r\n    return functionName;\r\n}\r\n/**\r\n * Linear animation function.\r\n *\r\n * @param {number} currentTime - The current time of the animation.\r\n * @param {number} startValue - The starting value of the animation.\r\n * @param {number} endValue - The ending value of the animation.\r\n * @param {number} duration - The duration of the animation.\r\n * @returns {number} The interpolated value at the current time.\r\n */\r\nexport function linear(currentTime, startValue, endValue, duration) {\r\n    return -endValue * Math.cos(currentTime / duration * (Math.PI / 2)) + endValue + startValue;\r\n}\r\n/**\r\n * Animates the marker element.\r\n *\r\n * @param {Element} element - The marker element to animate.\r\n * @param {number} delay - The delay before starting the animation.\r\n * @param {number} duration - The duration of the animation.\r\n * @param {Series | AccumulationSeries} series - The series associated with the marker.\r\n * @param {number} pointIndex - The index of the point in the series.\r\n * @param {ChartLocation} point - The location of the point.\r\n * @param {boolean} isLabel - Specifies whether the marker is a data label.\r\n * @returns {void}\r\n */\r\nexport function markerAnimate(element, delay, duration, series, pointIndex, point, isLabel) {\r\n    var centerX = point.x;\r\n    var centerY = point.y;\r\n    var height = 0;\r\n    element.style.visibility = 'hidden';\r\n    var transform = element.getAttribute('transform');\r\n    new Animation({}).animate(element, {\r\n        duration: duration,\r\n        delay: delay,\r\n        progress: function (args) {\r\n            if (args.timeStamp > args.delay) {\r\n                args.element.style.visibility = 'visible';\r\n                height = ((args.timeStamp - args.delay) / args.duration);\r\n                element.setAttribute('transform', 'translate(' + centerX\r\n                    + ' ' + centerY + ') scale(' + height + ') translate(' + (-centerX) + ' ' + (-centerY) + ')');\r\n            }\r\n        },\r\n        end: function () {\r\n            element.style.visibility = '';\r\n            element.setAttribute('transform', transform ? transform : '');\r\n            if ((series.type === 'Scatter' || series.type === 'Bubble') && !isLabel && (pointIndex === series.points.length - 1)) {\r\n                series.chart.trigger('animationComplete', { series: series.chart.isBlazor ? {} : series });\r\n            }\r\n        }\r\n    });\r\n}\r\n/**\r\n * Animates the rectangle element.\r\n *\r\n * @param {Element} element - The rectangle element to animate.\r\n * @param {number} delay - The delay before starting the animation.\r\n * @param {number} duration - The duration of the animation.\r\n * @param {Rect} currentRect - The current rectangle dimensions.\r\n * @param {Rect} previousRect - The previous rectangle dimensions.\r\n * @returns {void}\r\n */\r\nexport function animateRectElement(element, delay, duration, currentRect, previousRect) {\r\n    var setStyle = function (rect) {\r\n        element.setAttribute('x', rect.x + '');\r\n        element.setAttribute('y', rect.y + '');\r\n        element.setAttribute('width', rect.width + '');\r\n        element.setAttribute('height', rect.height + '');\r\n    };\r\n    new Animation({}).animate(createElement('div'), {\r\n        duration: duration,\r\n        delay: delay,\r\n        //name: name,\r\n        progress: function (args) {\r\n            setStyle(new Rect(linear(args.timeStamp, previousRect.x, currentRect.x - previousRect.x, args.duration), linear(args.timeStamp, previousRect.y, currentRect.y - previousRect.y, args.duration), linear(args.timeStamp, previousRect.width, currentRect.width - previousRect.width, args.duration), linear(args.timeStamp, previousRect.height, currentRect.height - previousRect.height, args.duration)));\r\n        },\r\n        end: function () {\r\n            setStyle(currentRect);\r\n        }\r\n    });\r\n}\r\n/**\r\n * Animation after legend click a path.\r\n *\r\n * @param {Element} element - element to be animated\r\n * @param {string} direction - current direction of the path\r\n * @param {boolean} redraw - chart redraw\r\n * @param {string} previousDirection - previous direction of the path\r\n * @param {number} animateDuration - animateDuration of the path\r\n * @returns {void}\r\n */\r\nexport function pathAnimation(element, direction, redraw, previousDirection, animateDuration) {\r\n    if (!redraw || (!previousDirection && !element)) {\r\n        return null;\r\n    }\r\n    var duration = 300;\r\n    if (!isNullOrUndefined(animateDuration)) {\r\n        duration = animateDuration;\r\n    }\r\n    var startDirections = previousDirection || element.getAttribute('d');\r\n    var splitDirections = startDirections.split(/(?=[LMCZAQ])/);\r\n    var endDirections = direction.split(/(?=[LMCZAQ])/);\r\n    var currentDireciton;\r\n    var startPath = [];\r\n    var endPath = [];\r\n    var c;\r\n    var end;\r\n    element.setAttribute('d', startDirections);\r\n    new Animation({}).animate(createElement('div'), {\r\n        duration: duration,\r\n        progress: function (args) {\r\n            currentDireciton = '';\r\n            splitDirections.map(function (directions, index) {\r\n                startPath = directions.split(' ');\r\n                endPath = endDirections[index] ? endDirections[index].split(' ') : startPath;\r\n                if (startPath[0] === 'Z') {\r\n                    currentDireciton += 'Z' + ' ';\r\n                }\r\n                else if (startPath[0] === '') {\r\n                    currentDireciton = '';\r\n                }\r\n                else {\r\n                    currentDireciton += startPath[0] + ' ' +\r\n                        linear(args.timeStamp, +startPath[1], (+endPath[1] - +startPath[1]), args.duration) + ' ' +\r\n                        linear(args.timeStamp, +startPath[2], (+endPath[2] - +startPath[2]), args.duration) + ' ';\r\n                }\r\n                if (startPath[0] === 'C' || startPath[0] === 'Q') {\r\n                    c = 3;\r\n                    end = startPath[0] === 'Q' ? 4 : 6;\r\n                    while (c < end) {\r\n                        currentDireciton += linear(args.timeStamp, +startPath[c], (+endPath[c] - +startPath[c]), args.duration) + ' ' +\r\n                            linear(args.timeStamp, +startPath[++c], (+endPath[c] - +startPath[c]), args.duration) + ' ';\r\n                        ++c;\r\n                    }\r\n                }\r\n                if (startPath[0] === 'A') {\r\n                    currentDireciton += 0 + ' ' + 0 + ' ' + 1 + ' ' +\r\n                        linear(args.timeStamp, +startPath[6], (+endPath[6] - +startPath[6]), args.duration) + ' ' +\r\n                        linear(args.timeStamp, +startPath[7], (+endPath[7] - +startPath[7]), args.duration) + ' ';\r\n                }\r\n            });\r\n            element.setAttribute('d', currentDireciton);\r\n        },\r\n        end: function () {\r\n            element.setAttribute('d', direction);\r\n        }\r\n    });\r\n}\r\n/**\r\n * Point based animation in chart series.\r\n *\r\n * @param {Element} element element to be animated.\r\n * @param {string} direction current direction of the path.\r\n * @param {boolean} redraw chart redraw.\r\n * @param {string} previousDirection previous direction of the path.\r\n * @param {number} animateDuration animateDuration of the path.\r\n * @param {string} removeDirection removeDirection of the path.\r\n * @returns {void}\r\n */\r\nexport function animateAddPoints(element, direction, redraw, previousDirection, animateDuration, removeDirection) {\r\n    if (!redraw || (!previousDirection && !element)) {\r\n        return null;\r\n    }\r\n    var duration = 300;\r\n    if (!isNullOrUndefined(animateDuration)) {\r\n        duration = animateDuration;\r\n    }\r\n    var startDirections = previousDirection || element.getAttribute('d');\r\n    var endDirections = direction;\r\n    var currentDirection = '';\r\n    element.setAttribute('d', startDirections);\r\n    new Animation({}).animate(createElement('div'), {\r\n        duration: duration,\r\n        progress: function (args) {\r\n            currentDirection = '';\r\n            var startPathCommands = startDirections.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\r\n            var endPathCommands = endDirections.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/g);\r\n            var maxLength = Math.max(startPathCommands.length, endPathCommands.length);\r\n            for (var i = 0; i < maxLength; i++) {\r\n                var startPathCommand = startPathCommands[i] || '';\r\n                var endPathCommand = endPathCommands[i] || '';\r\n                var startCoords = startPathCommand.trim().split(/\\s+/);\r\n                var endCoords = endPathCommand.trim().split(/\\s+/);\r\n                var interpolatedCoords = [];\r\n                for (var j = 1; j < startCoords.length; j++) {\r\n                    var startCoord = parseFloat(startCoords[j]);\r\n                    var endCoord = parseFloat(endCoords[j]);\r\n                    if (!isNaN(startCoord) && !isNaN(endCoord) && startCoords.length === endCoords.length) {\r\n                        var interpolatedValue = linear(args.timeStamp, startCoord, (endCoord - startCoord), duration);\r\n                        if (i === maxLength - 1) {\r\n                            interpolatedCoords.push(interpolatedValue);\r\n                        }\r\n                        else {\r\n                            interpolatedCoords.push(interpolatedValue);\r\n                        }\r\n                    }\r\n                }\r\n                if (startCoords.length !== endCoords.length) {\r\n                    currentDirection += 'L';\r\n                }\r\n                else {\r\n                    currentDirection += startCoords[0];\r\n                }\r\n                currentDirection += ' ' + interpolatedCoords.join(' ');\r\n                currentDirection += ' ';\r\n            }\r\n            element.setAttribute('d', currentDirection);\r\n        },\r\n        end: function () {\r\n            element.setAttribute('d', removeDirection || direction);\r\n        }\r\n    });\r\n}\r\n/**\r\n * To append the clip rect element.\r\n *\r\n * @param {boolean} redraw - chart redraw value.\r\n * @param {BaseAttibutes} options - element options.\r\n * @param {SvgRenderer} renderer - svg renderer values.\r\n * @param {string} clipPath - clipPath of the element.\r\n * @returns {Element} - Returns clip rect element.\r\n */\r\nexport function appendClipElement(redraw, options, renderer, clipPath) {\r\n    if (clipPath === void 0) { clipPath = 'drawClipPath'; }\r\n    var clipElement = redrawElement(redraw, options.id, options, renderer);\r\n    if (clipElement) {\r\n        var def = renderer.createDefs();\r\n        def.appendChild(clipElement);\r\n        return def;\r\n    }\r\n    else {\r\n        return renderer[clipPath](options);\r\n    }\r\n}\r\n/**\r\n * Triggers the label render event.\r\n *\r\n * @param {Chart | RangeNavigator | Chart3D} chart - The chart or range navigator instance.\r\n * @param {number} tempInterval - The temporary interval value.\r\n * @param {string} text - The label text.\r\n * @param {FontModel} labelStyle - The style of the label.\r\n * @param {Axis | Chart3DAxis} axis - The axis associated with the label.\r\n * @returns {void}\r\n */\r\nexport function triggerLabelRender(chart, tempInterval, text, labelStyle, axis) {\r\n    var argsData = {\r\n        cancel: false, name: axisLabelRender, axis: axis,\r\n        text: text, value: tempInterval, labelStyle: labelStyle\r\n    };\r\n    chart.trigger(axisLabelRender, argsData);\r\n    if (!argsData.cancel) {\r\n        var isLineBreakLabels = argsData.text.indexOf('<br>') !== -1;\r\n        var text_1 = (axis.enableTrim) ? (isLineBreakLabels ?\r\n            lineBreakLabelTrim(axis.maximumLabelWidth, argsData.text, axis.labelStyle, chart.themeStyle.axisLabelFont) :\r\n            textTrim(axis.maximumLabelWidth, argsData.text, axis.labelStyle, chart.enableRtl, chart.themeStyle.axisLabelFont))\r\n            : argsData.text;\r\n        axis.visibleLabels.push(new VisibleLabels(text_1, argsData.value, argsData.labelStyle, argsData.text));\r\n    }\r\n}\r\n/**\r\n * The function used to find whether the range is set.\r\n *\r\n * @param {Axis | Chart3DAxis} axis - The axis to check.\r\n * @returns {boolean} - It returns true if the axis range is set otherwise false.\r\n * @private\r\n */\r\nexport function setRange(axis) {\r\n    return (axis.minimum != null && axis.maximum != null);\r\n}\r\n/**\r\n * Checks if zooming is enabled for the axis.\r\n *\r\n * @param {Axis} axis - The axis to check for zooming.\r\n * @returns {boolean} - Returns true if zooming is enabled for the axis, otherwise false.\r\n */\r\nexport function isZoomSet(axis) {\r\n    return (axis.zoomFactor < 1 && axis.zoomPosition >= 0);\r\n}\r\n/**\r\n * Calculates the actual desired intervals count based on the available size and axis.\r\n *\r\n * @param {Size} availableSize - The available size for rendering.\r\n * @param {Axis | Chart3DAxis} axis - The axis for which to calculate the intervals count.\r\n * @returns {number} - The actual desired intervals count.\r\n */\r\nexport function getActualDesiredIntervalsCount(availableSize, axis) {\r\n    var size = axis.orientation === 'Horizontal' ? availableSize.width : availableSize.height;\r\n    if (isNullOrUndefined(axis.desiredIntervals)) {\r\n        var desiredIntervalsCount = (axis.orientation === 'Horizontal' ? 0.533 : 1) * axis.maximumLabels;\r\n        desiredIntervalsCount = Math.max((size * (desiredIntervalsCount / 100)), 1);\r\n        return desiredIntervalsCount;\r\n    }\r\n    else {\r\n        return axis.desiredIntervals;\r\n    }\r\n}\r\n/**\r\n * Animates the template element.\r\n *\r\n * @param {Element} element - The element to animate.\r\n * @param {number} delay - The delay before starting the animation.\r\n * @param {number} duration - The duration of the animation.\r\n * @param {Effect} name - The name of the animation effect.\r\n * @param {boolean} [isRemove] - Indicates whether to remove the element after animation completion.\r\n * @returns {void}\r\n */\r\nexport function templateAnimate(element, delay, duration, name, isRemove) {\r\n    new Animation({}).animate(element, {\r\n        duration: duration,\r\n        delay: delay,\r\n        name: name,\r\n        progress: function (args) {\r\n            args.element.style.visibility = 'visible';\r\n        },\r\n        end: function (args) {\r\n            if (isRemove) {\r\n                remove(args.element);\r\n            }\r\n            else {\r\n                args.element.style.visibility = 'visible';\r\n            }\r\n        }\r\n    });\r\n}\r\n/**\r\n * Draws a symbol at the specified location.\r\n *\r\n * @param {ChartLocation} location - The location to draw the symbol.\r\n * @param {string} shape - The shape of the symbol.\r\n * @param {Size} size - The size of the symbol.\r\n * @param {string} url - The URL of the image symbol.\r\n * @param {PathOption} options - The options for drawing the symbol.\r\n * @param {string} label - The label for the symbol.\r\n * @param {SvgRenderer | CanvasRenderer} [renderer] - The renderer for drawing the symbol.\r\n * @param {Rect} [clipRect] - The clipping rectangle.\r\n * @param {boolean} [isChartControl] - Indicates whether it is a chart control.\r\n * @param {BulletChart} [control] - The bullet chart control.\r\n * @returns {Element} - The element representing the drawn symbol.\r\n */\r\nexport function drawSymbol(location, shape, size, url, options, label, renderer, clipRect, isChartControl, control) {\r\n    var chartRenderer = renderer ? renderer : new SvgRenderer('');\r\n    var shapeOption = calculateShapes(location, size, shape, options, url, isChartControl, control);\r\n    var drawElement = chartRenderer['draw' + shapeOption.functionName](shapeOption.renderOption, clipRect ? new Int32Array([clipRect.x, clipRect.y]) : null);\r\n    //drawElement.setAttribute('aria-label', label);\r\n    return drawElement;\r\n}\r\n/**\r\n * Calculates the shapes based on the specified parameters.\r\n *\r\n * @param {ChartLocation} location - The location for the shapes.\r\n * @param {Size} size - The size of the shapes.\r\n * @param {string} shape - The shape of the symbols.\r\n * @param {PathOption} options - The options for drawing the shapes.\r\n * @param {string} url - The URL of the image symbols.\r\n * @param {boolean} [isChart] - Indicates whether it is a chart.\r\n * @param {BulletChart} [control] - The bullet chart control.\r\n * @returns {IShapes} - The calculated shapes.\r\n */\r\nexport function calculateShapes(location, size, shape, options, url, isChart, control) {\r\n    var dir;\r\n    var functionName = 'Path';\r\n    var isBulletChart = isChart;\r\n    var width = (isBulletChart && shape === 'Circle') ? (size.width - 2) : size.width;\r\n    var height = (isBulletChart && shape === 'Circle') ? (size.height - 2) : size.height;\r\n    var sizeBullet = (isBulletChart) ? control.targetWidth : 0;\r\n    var lx = location.x;\r\n    var ly = location.y;\r\n    var y = location.y + (-height / 2);\r\n    var x = location.x + (-width / 2);\r\n    var eq = 72;\r\n    var xVal;\r\n    var yVal;\r\n    switch (shape) {\r\n        case 'Bubble':\r\n        case 'Circle':\r\n            functionName = 'Ellipse';\r\n            merge(options, { 'rx': width / 2, 'ry': height / 2, 'cx': lx, 'cy': ly });\r\n            break;\r\n        case 'Plus':\r\n            dir = 'M' + ' ' + x + ' ' + ly + ' ' + 'L' + ' ' + (lx + (width / 2)) + ' ' + ly + ' ' +\r\n                'M' + ' ' + lx + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' + lx + ' ' +\r\n                (ly + (-height / 2));\r\n            merge(options, { 'd': dir });\r\n            break;\r\n        case 'Cross':\r\n            dir = 'M' + ' ' + x + ' ' + (ly + (-height / 2)) + ' ' + 'L' + ' ' + (lx + (width / 2)) + ' ' + (ly + (height / 2)) + ' ' +\r\n                'M' + ' ' + x + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' + (lx + (width / 2)) + ' ' + (ly + (-height / 2));\r\n            merge(options, { 'd': dir });\r\n            break;\r\n        case 'Multiply':\r\n            dir = 'M ' + (lx - sizeBullet) + ' ' + (ly - sizeBullet) + ' L ' +\r\n                (lx + sizeBullet) + ' ' + (ly + sizeBullet) + ' M ' +\r\n                (lx - sizeBullet) + ' ' + (ly + sizeBullet) + ' L ' + (lx + sizeBullet) + ' ' + (ly - sizeBullet);\r\n            merge(options, { 'd': dir, stroke: options.fill });\r\n            break;\r\n        case 'HorizontalLine':\r\n            dir = 'M' + ' ' + x + ' ' + ly + ' ' + 'L' + ' ' + (lx + (width / 2)) + ' ' + ly;\r\n            merge(options, { 'd': dir });\r\n            break;\r\n        case 'VerticalLine':\r\n            dir = 'M' + ' ' + lx + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' + lx + ' ' + (ly + (-height / 2));\r\n            merge(options, { 'd': dir });\r\n            break;\r\n        case 'Diamond':\r\n            dir = 'M' + ' ' + x + ' ' + ly + ' ' +\r\n                'L' + ' ' + lx + ' ' + (ly + (-height / 2)) + ' ' +\r\n                'L' + ' ' + (lx + (width / 2)) + ' ' + ly + ' ' +\r\n                'L' + ' ' + lx + ' ' + (ly + (height / 2)) + ' ' +\r\n                'L' + ' ' + x + ' ' + ly + ' z';\r\n            merge(options, { 'd': dir });\r\n            break;\r\n        case 'ActualRect':\r\n            dir = 'M' + ' ' + x + ' ' + (ly + (-height / 8)) + ' ' +\r\n                'L' + ' ' + (lx + (sizeBullet)) + ' ' + (ly + (-height / 8)) + ' ' +\r\n                'L' + ' ' + (lx + (sizeBullet)) + ' ' + (ly + (height / 8)) + ' ' +\r\n                'L' + ' ' + x + ' ' + (ly + (height / 8)) + ' ' +\r\n                'L' + ' ' + x + ' ' + (ly + (-height / 8)) + ' z';\r\n            merge(options, { 'd': dir });\r\n            break;\r\n        case 'TargetRect':\r\n            dir = 'M' + ' ' + (x + (sizeBullet)) + ' ' + (ly + (-height / 2)) + ' ' +\r\n                'L' + ' ' + (lx + (sizeBullet / 2)) + ' ' + (ly + (-height / 2)) + ' ' +\r\n                'L' + ' ' + (lx + (sizeBullet / 2)) + ' ' + (ly + (height / 2)) + ' ' +\r\n                'L' + ' ' + (x + (sizeBullet)) + ' ' + (ly + (height / 2)) + ' ' +\r\n                'L' + ' ' + (x + (sizeBullet)) + ' ' + (ly + (-height / 2)) + ' z';\r\n            merge(options, { 'd': dir });\r\n            break;\r\n        case 'Rectangle':\r\n        case 'Hilo':\r\n        case 'HiloOpenClose':\r\n        case 'Candle':\r\n        case 'Waterfall':\r\n        case 'BoxAndWhisker':\r\n        case 'StepArea':\r\n        case 'RangeStepArea':\r\n        case 'StackingStepArea':\r\n        case 'Square':\r\n        case 'Flag':\r\n            dir = 'M' + ' ' + x + ' ' + (ly + (-height / 2)) + ' ' +\r\n                'L' + ' ' + (lx + (width / 2)) + ' ' + (ly + (-height / 2)) + ' ' +\r\n                'L' + ' ' + (lx + (width / 2)) + ' ' + (ly + (height / 2)) + ' ' +\r\n                'L' + ' ' + x + ' ' + (ly + (height / 2)) + ' ' +\r\n                'L' + ' ' + x + ' ' + (ly + (-height / 2)) + ' z';\r\n            merge(options, { 'd': dir });\r\n            break;\r\n        case 'Pyramid':\r\n        case 'Triangle':\r\n            dir = 'M' + ' ' + x + ' ' + (ly + (height / 2)) + ' ' +\r\n                'L' + ' ' + lx + ' ' + (ly + (-height / 2)) + ' ' +\r\n                'L' + ' ' + (lx + (width / 2)) + ' ' + (ly + (height / 2)) + ' ' +\r\n                'L' + ' ' + x + ' ' + (ly + (height / 2)) + ' z';\r\n            merge(options, { 'd': dir });\r\n            break;\r\n        case 'Funnel':\r\n        case 'InvertedTriangle':\r\n            dir = 'M' + ' ' + (lx + (width / 2)) + ' ' + (ly - (height / 2)) + ' ' +\r\n                'L' + ' ' + lx + ' ' + (ly + (height / 2)) + ' ' +\r\n                'L' + ' ' + (lx - (width / 2)) + ' ' + (ly - (height / 2)) + ' ' +\r\n                'L' + ' ' + (lx + (width / 2)) + ' ' + (ly - (height / 2)) + ' z';\r\n            merge(options, { 'd': dir });\r\n            break;\r\n        case 'Pentagon':\r\n            for (var i = 0; i <= 5; i++) {\r\n                xVal = (width / 2) * Math.cos((Math.PI / 180) * (i * eq));\r\n                yVal = (height / 2) * Math.sin((Math.PI / 180) * (i * eq));\r\n                if (i === 0) {\r\n                    dir = 'M' + ' ' + (lx + xVal) + ' ' + (ly + yVal) + ' ';\r\n                }\r\n                else {\r\n                    dir = dir.concat('L' + ' ' + (lx + xVal) + ' ' + (ly + yVal) + ' ');\r\n                }\r\n            }\r\n            dir = dir.concat('Z');\r\n            merge(options, { 'd': dir });\r\n            break;\r\n        case 'Image':\r\n            functionName = 'Image';\r\n            merge(options, { 'href': url, 'height': height, 'width': width, x: x, y: y });\r\n            break;\r\n    }\r\n    options = calculateLegendShapes(location, new Size(width, height), shape, options).renderOption;\r\n    return { renderOption: options, functionName: functionName };\r\n}\r\n/**\r\n * Gets the location of the rectangle based on the specified start and end locations and the outer rectangle.\r\n *\r\n * @param {ChartLocation} startLocation - The start location.\r\n * @param {ChartLocation} endLocation - The end location.\r\n * @param {Rect} outerRect - The outer rectangle.\r\n * @returns {Rect} - The location of the rectangle.\r\n */\r\nexport function getRectLocation(startLocation, endLocation, outerRect) {\r\n    var x = (endLocation.x < outerRect.x) ? outerRect.x :\r\n        (endLocation.x > (outerRect.x + outerRect.width)) ? outerRect.x + outerRect.width : endLocation.x;\r\n    var y = (endLocation.y < outerRect.y) ? outerRect.y :\r\n        (endLocation.y > (outerRect.y + outerRect.height)) ? outerRect.y + outerRect.height : endLocation.y;\r\n    return new Rect((x > startLocation.x ? startLocation.x : x), (y > startLocation.y ? startLocation.y : y), Math.abs(x - startLocation.x), Math.abs(y - startLocation.y));\r\n}\r\n/**\r\n * Returns the value constrained within the specified minimum and maximum limits.\r\n *\r\n * @param {number} value - The input value.\r\n * @param {number} min - The minimum limit.\r\n * @param {number} max - The maximum limit.\r\n * @returns {number} - The constrained value.\r\n */\r\nexport function minMax(value, min, max) {\r\n    return value > max ? max : (value < min ? min : value);\r\n}\r\n/**\r\n * Retrieves the DOM element with the specified ID.\r\n *\r\n * @param {string} id - The ID of the element to retrieve.\r\n * @returns {Element} - The DOM element.\r\n */\r\nexport function getElement(id) {\r\n    return document.getElementById(id);\r\n}\r\n/**\r\n * Gets the template function from the provided template string or function.\r\n *\r\n * @param {string | Function} template - The template string or function.\r\n * @returns {Function} - The template function.\r\n */\r\nexport function getTemplateFunction(template) {\r\n    var templateFn = null;\r\n    try {\r\n        if (typeof template !== 'function' && document.querySelectorAll(template).length) {\r\n            templateFn = templateComplier(document.querySelector(template).innerHTML.trim());\r\n        }\r\n        else {\r\n            templateFn = templateComplier(template);\r\n        }\r\n    }\r\n    catch (e) {\r\n        templateFn = templateComplier(template);\r\n    }\r\n    return templateFn;\r\n}\r\n/**\r\n * Renders the accumulation chart data labels using template.\r\n *\r\n * @param {HTMLElement} childElement - The child element.\r\n * @param {AccumulationChart} chart - The accumulation chart instance.\r\n * @param {boolean} isTemplate - Defines whether the template is applied or not.\r\n * @param {AccPoints[]} points - The accumulation chart points.\r\n * @param {IAccTextRenderEventArgs} argsData - The accumulation chart text render event arguments.\r\n * @param {AccPoints} [point] - The accumulation chart point.\r\n * @param {Element} [datalabelGroup] - The data label group element.\r\n * @param {string} [id] - The id of the element.\r\n * @param {AccumulationDataLabelSettingsModel} [dataLabel] - The accumulation chart data label settings.\r\n * @param {boolean} [redraw] - Defines whether to redraw the chart or not.\r\n * @returns {void}\r\n */\r\nexport function accReactTemplate(childElement, chart, isTemplate, points, argsData, point, datalabelGroup, id, dataLabel, redraw) {\r\n    var clientRect = childElement.getBoundingClientRect();\r\n    chart.accumulationDataLabelModule.calculateLabelSize(isTemplate, childElement, point, points, argsData, datalabelGroup, id, dataLabel, redraw, clientRect, true);\r\n}\r\n/**\r\n * Renders the chart data labels using template.\r\n *\r\n * @param {HTMLElement} childElement - The child element.\r\n * @param {Chart} chart - The chart instance.\r\n * @param {Points} point - The chart point.\r\n * @param {Series} series - The chart series.\r\n * @param {number} labelIndex - The index of the label.\r\n * @param {boolean} [redraw] - Defines whether to redraw the chart or not.\r\n * @returns {void}\r\n */\r\nexport function chartReactTemplate(childElement, chart, point, series, labelIndex, redraw) {\r\n    var parentElement = document.getElementById(chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index) + '_DataLabelCollections');\r\n    if (parentElement) {\r\n        if (point.index === 0) {\r\n            chart.dataLabelCollections = []; // clear old datalabel bounds for react callback\r\n        }\r\n        chart.dataLabelModule.calculateTemplateLabelSize(parentElement, childElement, point, series, series.marker.dataLabel, labelIndex, series.clipRect, redraw, true);\r\n    }\r\n}\r\n/**\r\n * Creates a template.\r\n *\r\n * @param {HTMLElement} childElement - The child element of the template.\r\n * @param {number} pointIndex - The index of the point.\r\n * @param {string | Function} content - The content of the template.\r\n * @param {Chart | AccumulationChart | RangeNavigator} chart - The chart instance.\r\n * @param {Points | AccPoints} point - The chart or accumulation point.\r\n * @param {Series | AccumulationSeries} series - The chart or accumulation series.\r\n * @param {string} dataLabelId - The id of the data label.\r\n * @param {number} labelIndex - The index of the label.\r\n * @param {IAccTextRenderEventArgs} argsData - The event arguments for text rendering.\r\n * @param {boolean} isTemplate - Indicates whether it is a template.\r\n * @param {AccPoints[]} points - The accumulation points.\r\n * @param {Element} datalabelGroup - The group element of the data label.\r\n * @param {string} id - The id of the element.\r\n * @param {AccumulationDataLabelSettingsModel} dataLabel - The data label settings.\r\n * @param {boolean} redraw - Indicates whether to redraw.\r\n * @returns {HTMLElement} - The created template element.\r\n * @private\r\n */\r\nexport function createTemplate(childElement, pointIndex, content, chart, point, series, dataLabelId, labelIndex, argsData, isTemplate, points, datalabelGroup, id, dataLabel, redraw) {\r\n    var templateFn = getTemplateFunction(content);\r\n    var templateElement;\r\n    try {\r\n        var blazor = 'Blazor';\r\n        var tempObject = window[blazor] ? (dataLabelId ? point : { point: point }) :\r\n            { chart: chart, series: series, point: point };\r\n        var templateId = dataLabelId ? dataLabelId + '_template' : 'template';\r\n        var elementData = templateFn ? templateFn(tempObject, chart, templateId, dataLabelId ||\r\n            childElement.id.replace(/[^a-zA-Z0-9]/g, '')) : [];\r\n        if (elementData.length) {\r\n            templateElement = Array.prototype.slice.call(elementData);\r\n            var len = templateElement.length;\r\n            for (var i = 0; i < len; i++) {\r\n                childElement.appendChild(templateElement[i]);\r\n            }\r\n        }\r\n        var reactCallback = void 0;\r\n        if (chart.getModuleName() === 'accumulationchart') {\r\n            reactCallback = accReactTemplate.bind(this, childElement, chart, isTemplate, points, argsData, points[pointIndex], datalabelGroup, id, dataLabel, redraw);\r\n            if (chart.isReact) {\r\n                chart.renderReactTemplates(reactCallback);\r\n            }\r\n        }\r\n        else if (chart.getModuleName() === 'chart') {\r\n            reactCallback = (point && series) ? chartReactTemplate.bind(this, childElement, chart, point, series, labelIndex, redraw) : reactCallback;\r\n            if (chart.isReact) {\r\n                chart.renderReactTemplates(reactCallback);\r\n            }\r\n        }\r\n    }\r\n    catch (e) {\r\n        return childElement;\r\n    }\r\n    return childElement;\r\n}\r\n/**\r\n * Gets the font style.\r\n *\r\n * @param {FontModel} font - The font settings.\r\n * @returns {string} - The font style.\r\n * @private\r\n */\r\nexport function getFontStyle(font, themeFontStyle) {\r\n    var style = '';\r\n    style = 'font-size:' + (font.size || themeFontStyle.size) +\r\n        '; font-style:' + (font.fontStyle || themeFontStyle.fontStyle) + '; font-weight:' + (font.fontWeight || themeFontStyle.fontWeight) +\r\n        '; font-family:' + font.fontFamily + ';opacity:' + font.opacity +\r\n        '; color:' + font.color + ';';\r\n    return style;\r\n}\r\n/**\r\n * Measures the bounding rectangle of an HTML element.\r\n *\r\n * @param {HTMLElement} element - The HTML element to measure.\r\n * @param {boolean} redraw - Indicates whether to redraw.\r\n * @param {boolean} isReactCallback - Indicates whether it's a React callback.\r\n * @returns {ClientRect} - The bounding rectangle of the element.\r\n * @private\r\n */\r\nexport function measureElementRect(element, redraw, isReactCallback) {\r\n    if (redraw === void 0) { redraw = false; }\r\n    if (!isReactCallback) { // If the element is already in DOM, no need to append in the body.\r\n        document.body.appendChild(element);\r\n    }\r\n    var bounds = element.getBoundingClientRect();\r\n    if (redraw) {\r\n        remove(element);\r\n    }\r\n    else if (!isReactCallback) { // for react chart data label template - (callback function)\r\n        removeElement(element.id);\r\n    }\r\n    return bounds;\r\n}\r\n/**\r\n * Finds an element in a NodeList based on its id.\r\n *\r\n * @param {NodeList} elements - The NodeList to search.\r\n * @param {string} id - The id of the element to find.\r\n * @returns {Element} - The found element.\r\n * @private\r\n */\r\nexport function findlElement(elements, id) {\r\n    var element;\r\n    for (var i = 0, length_1 = elements.length; i < length_1; i++) {\r\n        if (elements[i].id.indexOf(id) > -1) {\r\n            element = elements[i];\r\n            continue;\r\n        }\r\n    }\r\n    return element;\r\n}\r\n/**\r\n * Gets the point on the chart based on the provided coordinates and axes.\r\n *\r\n * @param {number} x - The x-coordinate of the point.\r\n * @param {number} y - The y-coordinate of the point.\r\n * @param {Axis} xAxis - The x-axis of the chart.\r\n * @param {Axis} yAxis - The y-axis of the chart.\r\n * @param {boolean} isInverted - Indicates whether the chart is inverted.\r\n * @returns {ChartLocation} - The calculated point.\r\n * @private\r\n */\r\nexport function getPoint(x, y, xAxis, yAxis, isInverted) {\r\n    x = ((xAxis.valueType === 'Logarithmic') ?\r\n        logBase(((x > 0) ? x : Math.pow(xAxis.logBase, xAxis.visibleRange.min)), xAxis.logBase) : x);\r\n    y = ((yAxis.valueType === 'Logarithmic') ?\r\n        logBase(((y > 0) ? y : Math.pow(yAxis.logBase, yAxis.visibleRange.min)), yAxis.logBase) : y);\r\n    x = valueToCoefficient(x, xAxis);\r\n    y = valueToCoefficient(y, yAxis);\r\n    var xLength = (isInverted ? xAxis.rect.height : xAxis.rect.width);\r\n    var yLength = (isInverted ? yAxis.rect.width : yAxis.rect.height);\r\n    var locationX = isInverted ? y * (yLength) : x * (xLength);\r\n    var locationY = isInverted ? (1 - x) * (xLength) : (1 - y) * (yLength);\r\n    return new ChartLocation(locationX, locationY);\r\n}\r\n/**\r\n * Appends an element to a parent element.\r\n *\r\n * @param {Element} child - The child element to be appended.\r\n * @param {Element} parent - The parent element to which the child element will be appended.\r\n * @param {boolean} [redraw=false] - A boolean value indicating whether to redraw. Default is false.\r\n * @param {boolean} [animate=false] - A boolean value indicating whether to animate the appending operation. Default is false.\r\n * @param {string} [x='x'] - The x-coordinate for the position of the child element. Default is 'x'.\r\n * @param {string} [y='y'] - The y-coordinate for the position of the child element. Default is 'y'.\r\n * @param {number} duration - duration of the animation\r\n * @returns {void}\r\n * @private\r\n */\r\nexport function appendElement(child, parent, redraw, animate, x, y, duration) {\r\n    if (redraw === void 0) { redraw = false; }\r\n    if (animate === void 0) { animate = false; }\r\n    if (x === void 0) { x = 'x'; }\r\n    if (y === void 0) { y = 'y'; }\r\n    if (child && child.hasChildNodes() && parent) {\r\n        appendChildElement(false, parent, child, redraw, animate, x, y, undefined, undefined, undefined, undefined, undefined, duration);\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\n/**\r\n * Method to append child element.\r\n *\r\n * @param {boolean} isCanvas - canvas mode value\r\n * @param {Element | HTMLElement} parent - parent element\r\n * @param {Element | HTMLElement} childElement - childElement element\r\n * @param {boolean} redraw - chart redraw value\r\n * @param {boolean} isAnimate - animation value\r\n * @param {string} x - x position\r\n * @param {string} y - y position\r\n * @param {ChartLocation} start - start location value\r\n * @param {string} direction - direction of the element\r\n * @param {boolean} forceAnimate - forceAnimate\r\n * @param {boolean} isRect - isRect\r\n * @param {Rect} previousRect - previousRect\r\n * @param {number} animateDuration - duration of the animation\r\n * @param {boolean} scatterElement - The scatter element.\r\n * @param {number} angle - The angle of the element.\r\n * @param {ChartLocation} currentTransform - The current transform of the element.\r\n * @returns {void}\r\n */\r\nexport function appendChildElement(isCanvas, parent, childElement, redraw, isAnimate, x, y, start, direction, forceAnimate, isRect, previousRect, animateDuration, scatterElement, angle, currentTransform) {\r\n    if (isAnimate === void 0) { isAnimate = false; }\r\n    if (x === void 0) { x = 'x'; }\r\n    if (y === void 0) { y = 'y'; }\r\n    if (forceAnimate === void 0) { forceAnimate = false; }\r\n    if (isRect === void 0) { isRect = false; }\r\n    if (previousRect === void 0) { previousRect = null; }\r\n    if (scatterElement === void 0) { scatterElement = false; }\r\n    if (angle === void 0) { angle = 0; }\r\n    if (isCanvas) {\r\n        return null;\r\n    }\r\n    var existChild = scatterElement ? null : parent.querySelector('#' + childElement.id);\r\n    var element = (existChild || getElement(childElement.id));\r\n    var child = childElement;\r\n    var duration = !isNullOrUndefined(animateDuration) ? animateDuration : 300;\r\n    if (redraw && isAnimate && element) {\r\n        start = start || (element.tagName === 'DIV' ?\r\n            new ChartLocation(+(element.style[x].split('px')[0]), +(element.style[y].split('px')[0])) :\r\n            new ChartLocation(+element.getAttribute(x), +element.getAttribute(y)));\r\n        if (direction && direction !== 'undefined') {\r\n            pathAnimation(childElement, childElement.getAttribute('d'), redraw, direction, duration);\r\n        }\r\n        else if (isRect && previousRect) {\r\n            animateRectElement(child, 0, duration, new Rect(+element.getAttribute('x'), +element.getAttribute('y'), +element.getAttribute('width'), +element.getAttribute('height')), previousRect);\r\n        }\r\n        else {\r\n            var end = child.tagName === 'DIV' ?\r\n                new ChartLocation(+(child.style[x].split('px')[0]), +(child.style[y].split('px')[0])) :\r\n                new ChartLocation(+child.getAttribute(x), +child.getAttribute(y));\r\n            var previousTranform = element.getAttribute('transform');\r\n            animateRedrawElement(child, duration, start, end, x, y, angle, currentTransform, previousTranform ? new ChartLocation(parseFloat(previousTranform.split(',')[1]), parseFloat(previousTranform.split(',')[2])) : new ChartLocation(0, 0));\r\n        }\r\n    }\r\n    else if (redraw && isAnimate && !element && forceAnimate) {\r\n        templateAnimate(child, 0, 600, 'FadeIn');\r\n    }\r\n    if (existChild) {\r\n        parent.replaceChild(child, element);\r\n    }\r\n    else {\r\n        parent.appendChild(child);\r\n    }\r\n}\r\n/**\r\n * Calculates the location of the dragged rectangle.\r\n *\r\n * @param {number} x1 - The x-coordinate of the starting point.\r\n * @param {number} y1 - The y-coordinate of the starting point.\r\n * @param {number} x2 - The x-coordinate of the ending point.\r\n * @param {number} y2 - The y-coordinate of the ending point.\r\n * @param {Rect} outerRect - The outer rectangle containing the dragged rectangle.\r\n * @returns {Rect} - The location of the dragged rectangle.\r\n * @private\r\n */\r\nexport function getDraggedRectLocation(x1, y1, x2, y2, outerRect) {\r\n    var width = Math.abs(x1 - x2);\r\n    var height = Math.abs(y1 - y2);\r\n    var x = Math.max(checkBounds(Math.min(x1, x2), width, outerRect.x, outerRect.width), outerRect.x);\r\n    var y = Math.max(checkBounds(Math.min(y1, y2), height, outerRect.y, outerRect.height), outerRect.y);\r\n    return new Rect(x, y, Math.min(width, outerRect.width), Math.min(height, outerRect.height));\r\n}\r\n/**\r\n * Checks if a value is within bounds defined by minimum and maximum values.\r\n *\r\n * @param {number} start - The start value.\r\n * @param {number} size - The size of the value.\r\n * @param {number} min - The minimum value of the bound.\r\n * @param {number} max - The maximum value of the bound.\r\n * @returns {number} - The adjusted value within the bounds.\r\n * @private\r\n */\r\nexport function checkBounds(start, size, min, max) {\r\n    if (start < min) {\r\n        start = min;\r\n    }\r\n    else if ((start + size) > (max + min)) {\r\n        start = (max + min) - size;\r\n    }\r\n    return start;\r\n}\r\n/**\r\n * Retrieves label text for a data point.\r\n *\r\n * @param {Points} currentPoint - The current data point.\r\n * @param {Series} series - The series to which the data point belongs.\r\n * @param {Chart} chart - The chart instance.\r\n * @returns {string[]} - The label text.\r\n * @private\r\n */\r\nexport function getLabelText(currentPoint, series, chart) {\r\n    var labelFormat = series.marker.dataLabel.format ? series.marker.dataLabel.format : series.yAxis.labelFormat;\r\n    var text = [];\r\n    var customLabelFormat = labelFormat.match('{value}') !== null;\r\n    switch (series.seriesType) {\r\n        case 'XY':\r\n            /**\r\n             * I255790\r\n             * For Polar radar series, the dataLabel appears out of range when axis range is given for yaxis\r\n             * Cause: Since symbol location for the points which did not lies in within range, lies outside of seriesRect.\r\n             * Fix: DataLabel rendered after checking WithIn for the points\r\n             */\r\n            if (series.chart.chartAreaType === 'PolarRadar') {\r\n                if (series.drawType.indexOf('Stacking') !== -1) {\r\n                    if ((series.yAxis.valueType === 'Logarithmic' &&\r\n                        logWithIn(series.stackedValues.endValues[currentPoint.index], series.yAxis)) ||\r\n                        withIn(series.stackedValues.endValues[currentPoint.index], series.yAxis.visibleRange)) {\r\n                        text.push(currentPoint.text || currentPoint.yValue.toString());\r\n                    }\r\n                }\r\n                else {\r\n                    if ((series.yAxis.valueType === 'Logarithmic' && logWithIn(currentPoint.yValue, series.yAxis)) ||\r\n                        withIn(currentPoint.yValue, series.yAxis.visibleRange)) {\r\n                        text.push(currentPoint.text || currentPoint.yValue.toString());\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                text.push(currentPoint.text || currentPoint.yValue.toString());\r\n            }\r\n            break;\r\n        case 'HighLow':\r\n            text.push(currentPoint.text || Math.max(currentPoint.high, currentPoint.low).toString());\r\n            text.push(currentPoint.text || Math.min(currentPoint.high, currentPoint.low).toString());\r\n            break;\r\n        case 'HighLowOpenClose':\r\n            text.push(currentPoint.text || Math.max(currentPoint.high, currentPoint.low).toString());\r\n            text.push(currentPoint.text || Math.min(currentPoint.high, currentPoint.low).toString());\r\n            text.push(currentPoint.text || Math.max(currentPoint.open, currentPoint.close).toString());\r\n            text.push(currentPoint.text || Math.min(currentPoint.open, currentPoint.close).toString());\r\n            break;\r\n        case 'BoxPlot':\r\n            text.push(currentPoint.text || currentPoint.median.toString());\r\n            text.push(currentPoint.text || currentPoint.maximum.toString());\r\n            text.push(currentPoint.text || currentPoint.minimum.toString());\r\n            text.push(currentPoint.text || currentPoint.upperQuartile.toString());\r\n            text.push(currentPoint.text || currentPoint.lowerQuartile.toString());\r\n            for (var _i = 0, _a = currentPoint.outliers; _i < _a.length; _i++) {\r\n                var liers = _a[_i];\r\n                text.push(currentPoint.text || liers.toString());\r\n            }\r\n            break;\r\n    }\r\n    if ((labelFormat || chart.useGroupingSeparator) && !currentPoint.text) {\r\n        series.yAxis.format = chart.intl.getNumberFormat({\r\n            format: customLabelFormat ? '' : labelFormat,\r\n            useGrouping: chart.useGroupingSeparator\r\n        });\r\n        for (var i = 0; i < text.length; i++) {\r\n            text[i] = customLabelFormat ? labelFormat.replace('{value}', series.yAxis.format(parseFloat(text[i]))) :\r\n                series.yAxis.format(parseFloat(text[i]));\r\n        }\r\n    }\r\n    return text;\r\n}\r\n/**\r\n * Stops the specified timer.\r\n *\r\n * @param {number} timer - The timer to stop.\r\n * @returns {void}\r\n */\r\nexport function stopTimer(timer) {\r\n    window.clearInterval(timer);\r\n}\r\n/**\r\n * Checks if the specified rect collides with any of the rect in the collection within the given clip rect.\r\n *\r\n * @param {Rect} rect - The rect to check for collision.\r\n * @param {Rect[]} collections - The collection of rect to check against.\r\n * @param {Rect} clipRect - The clip rect.\r\n * @returns {boolean} - Returns true if collision occurs; otherwise, false.\r\n */\r\nexport function isCollide(rect, collections, clipRect) {\r\n    var currentRect = new Rect(rect.x + clipRect.x, rect.y + clipRect.y, rect.width, rect.height);\r\n    var isCollide = collections.some(function (rect) {\r\n        return (currentRect.x < rect.x + rect.width && currentRect.x + currentRect.width > rect.x &&\r\n            currentRect.y < rect.y + rect.height && currentRect.height + currentRect.y > rect.y);\r\n    });\r\n    return isCollide;\r\n}\r\n/**\r\n * Checks if the specified rect overlap each other.\r\n *\r\n * @param {Rect} currentRect - The first rect.\r\n * @param {Rect} rect - The second rect.\r\n * @returns {boolean} - Returns true if the rect overlap; otherwise, false.\r\n */\r\nexport function isOverlap(currentRect, rect) {\r\n    return (currentRect.x < rect.x + rect.width && currentRect.x + currentRect.width > rect.x &&\r\n        currentRect.y < rect.y + rect.height && currentRect.height + currentRect.y > rect.y);\r\n}\r\n/**\r\n * Checks if the specified rect is completely contained within another rect.\r\n *\r\n * @param {Rect} currentRect - The rect to check if it's contained.\r\n * @param {Rect} rect - The containing rect.\r\n * @returns {boolean} - Returns true if the specified rect is completely contained within the containing rect; otherwise, false.\r\n */\r\nexport function containsRect(currentRect, rect) {\r\n    return (currentRect.x <= rect.x && currentRect.x + currentRect.width >= rect.x + rect.width &&\r\n        currentRect.y <= rect.y && currentRect.height + currentRect.y >= rect.y + rect.height);\r\n}\r\n/**\r\n * Calculates the rect based on the specified location, text size, and margin.\r\n *\r\n * @param {ChartLocation} location - The location of the rect.\r\n * @param {Size} textSize - The size of the text.\r\n * @param {MarginModel} margin - The margin to be applied around the text.\r\n * @returns {Rect} - Returns the calculated rect.\r\n */\r\nexport function calculateRect(location, textSize, margin) {\r\n    return new Rect((location.x - (textSize.width / 2) - margin.left), (location.y - (textSize.height / 2) - margin.top), textSize.width + margin.left + margin.right, textSize.height + margin.top + margin.bottom);\r\n}\r\n/**\r\n * Converts the color value to hexadecimal code.\r\n *\r\n * @param {ColorValue} value - The color value to convert.\r\n * @returns {string} - Returns the hexadecimal representation of the color.\r\n */\r\nexport function convertToHexCode(value) {\r\n    return '#' + componentToHex(value.r) + componentToHex(value.g) + componentToHex(value.b);\r\n}\r\n/**\r\n * Converts a component value to its hexadecimal representation.\r\n *\r\n * @param {number} value - The component value to convert.\r\n * @returns {string} - Returns the hexadecimal representation of the component.\r\n * @private\r\n */\r\nexport function componentToHex(value) {\r\n    var hex = value.toString(16);\r\n    return hex.length === 1 ? '0' + hex : hex;\r\n}\r\n/**\r\n * Converts a hexadecimal color code to its RedGreenBlue representation.\r\n *\r\n * @param {string} hex - The hexadecimal color code to convert.\r\n * @returns {ColorValue} - Returns the RedGreenBlue representation of the hexadecimal color code.\r\n */\r\nexport function convertHexToColor(hex) {\r\n    var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n    return result ? new ColorValue(parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)) :\r\n        new ColorValue(255, 255, 255);\r\n}\r\n/**\r\n * Converts a color name to its corresponding hexadecimal color code.\r\n *\r\n * @param {string} color - The color name to convert.\r\n * @returns {string} - Returns the hexadecimal color code.\r\n */\r\nexport function colorNameToHex(color) {\r\n    color = color === 'transparent' ? 'white' : color;\r\n    document.body.appendChild(createElement('text', { id: 'chartmeasuretext' }));\r\n    var element = document.getElementById('chartmeasuretext');\r\n    element.style.color = color;\r\n    color = window.getComputedStyle(element).color;\r\n    remove(element);\r\n    var isRGBValue;\r\n    if (color.indexOf('rgb') === 0 || color.indexOf('hsl') === 0) {\r\n        color = color.replace(/\\s/g, '').replace(/[()]/g, '');\r\n        isRGBValue = color.slice(3).split(',');\r\n    }\r\n    return convertToHexCode(new ColorValue(parseInt(isRGBValue[0], 10), parseInt(isRGBValue[1], 10), parseInt(isRGBValue[2], 10)));\r\n}\r\n/**\r\n * Checks if the provided color string is in a valid format.\r\n *\r\n * @param {string} color - The color string to check.\r\n * @returns {boolean} - Returns true if the color string is in a valid format, otherwise returns false.\r\n */\r\nexport function checkColorFormat(color) {\r\n    if (color.indexOf('rgba(') === 0 || color.indexOf('rgb(') === 0) {\r\n        var rgbaValues = color.substring(color.indexOf('(') + 1, color.lastIndexOf(')')).split(',');\r\n        if (rgbaValues.length === 3 || rgbaValues.length === 4) {\r\n            return rgbaValues.every(function (val) {\r\n                var num = parseFloat(val);\r\n                return !isNaN(num) && num >= 0 && num <= 255;\r\n            });\r\n        }\r\n    }\r\n    else if (color.indexOf('#') === 0) {\r\n        var hex = color.substring(1);\r\n        return (hex.length === 3 || hex.length === 6) && /^[0-9A-Fa-f]{3,6}$/.test(hex);\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Gets the color with adjusted saturation.\r\n *\r\n * @param {string} color - The input color string.\r\n * @param {number} factor - The factor by which to adjust the saturation.\r\n * @returns {string} - The modified color string.\r\n */\r\nexport function getSaturationColor(color, factor) {\r\n    color = colorNameToHex(color);\r\n    color = color.replace(/[^0-9a-f]/gi, '');\r\n    if (color.length < 6) {\r\n        color = color[0] + color[0] + color[1] + color[1] + color[2] + color[2];\r\n    }\r\n    factor = factor || 0;\r\n    // convert to decimal and change luminosity\r\n    var rgb = '#';\r\n    var colorCode;\r\n    for (var i = 0; i < 3; i++) {\r\n        colorCode = parseInt(color.substr(i * 2, 2), 16);\r\n        colorCode = Math.round(Math.min(Math.max(0, colorCode + (colorCode * factor)), 255));\r\n        rgb += ('00' + colorCode.toString(16)).substr(colorCode.toString(16).length);\r\n    }\r\n    return rgb;\r\n}\r\n/**\r\n * Applies a lightness adjustment to the given color.\r\n *\r\n * @param {string} color - The input color string.\r\n * @param {number} value - The value by which to adjust the lightness.\r\n * @returns {string} - The modified color string.\r\n */\r\nexport function applyZLight(color, value) {\r\n    var RGB = convertHexToColor(color);\r\n    RGB.r = parseInt(Math.floor(RGB.r * value).toString(), 10);\r\n    RGB.g = parseInt(Math.floor(RGB.g * value).toString(), 10);\r\n    RGB.b = parseInt(Math.floor(RGB.b * value).toString(), 10);\r\n    return '#' + componentToHex(RGB.r).toUpperCase() + componentToHex(RGB.g).toUpperCase() + componentToHex(RGB.b).toUpperCase();\r\n}\r\n/**\r\n * Calculates the median value of an array of numbers.\r\n *\r\n * @param {number[]} values - The array of numbers.\r\n * @returns {number} - The median value.\r\n */\r\nexport function getMedian(values) {\r\n    var half = Math.floor(values.length / 2);\r\n    return values.length % 2 ? values[half] : ((values[half - 1] + values[half]) / 2.0);\r\n}\r\n/**\r\n * Calculates the legend shapes based on the provided parameters.\r\n *\r\n * @param {ChartLocation} location - The location to position the legend shape.\r\n * @param {Size} size - The size of the legend shape.\r\n * @param {string} shape - The shape of the legend.\r\n * @param {PathOption} options - The options for drawing the legend shape.\r\n * @returns {IShapes} - The calculated legend shape.\r\n */\r\nexport function calculateLegendShapes(location, size, shape, options) {\r\n    var padding = 10;\r\n    var dir = '';\r\n    var space = 2;\r\n    var height = size.height;\r\n    var width = size.width;\r\n    var lx = location.x;\r\n    var ly = location.y;\r\n    switch (shape) {\r\n        case 'MultiColoredLine':\r\n        case 'Line':\r\n        case 'StackingLine':\r\n        case 'StackingLine100':\r\n            dir = 'M' + ' ' + (lx + (-width * (3 / 4))) + ' ' + (ly) + ' ' +\r\n                'L' + ' ' + (lx + (width * (3 / 4))) + ' ' + (ly);\r\n            merge(options, { 'd': dir });\r\n            break;\r\n        case 'StepLine':\r\n            options.fill = 'transparent';\r\n            dir = 'M' + ' ' + (lx + (-width / 2) - (padding / 4)) + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' + (lx +\r\n                (-width / 2) + (width / 10)) + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' + (lx + (-width / 2) + (width / 10))\r\n                + ' ' + (ly) + ' ' + 'L' + ' ' + (lx + (-width / 10)) + ' ' + (ly) + ' ' + 'L' + ' ' + (lx + (-width / 10))\r\n                + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' + (lx + (width / 5)) + ' ' + (ly + (height / 2)) + ' ' + 'L' +\r\n                ' ' + (lx + (width / 5)) + ' ' + (ly + (-height / 2)) + ' ' + 'L' + ' ' + (lx + (width / 2)) + ' ' + (ly +\r\n                (-height / 2)) + 'L' + ' ' + (lx + (width / 2)) + ' ' + (ly + (height / 2)) + ' ' + 'L' + '' + (lx + (width / 2)\r\n                + (padding / 4)) + ' ' + (ly + (height / 2));\r\n            merge(options, { 'd': dir });\r\n            break;\r\n        case 'UpArrow':\r\n            options.fill = options.stroke;\r\n            options.stroke = 'transparent';\r\n            dir = 'M' + ' ' + (lx + (-width / 2)) + ' ' + (ly + (height / 2)) + ' ' +\r\n                'L' + ' ' + (lx) + ' ' + (ly - (height / 2)) + ' ' +\r\n                'L' + ' ' + (lx + (width / 2)) + ' ' + (ly + (height / 2)) +\r\n                'L' + ' ' + (lx + (width / 2) - space) + ' ' + (ly + (height / 2)) + ' ' +\r\n                'L' + ' ' + (lx) + ' ' + (ly - (height / 2) + (2 * space)) +\r\n                'L' + (lx - (width / 2) + space) + ' ' + (ly + (height / 2)) + ' Z';\r\n            merge(options, { 'd': dir });\r\n            break;\r\n        case 'DownArrow':\r\n            dir = 'M' + ' ' + (lx - (width / 2)) + ' ' + (ly - (height / 2)) + ' ' +\r\n                'L' + ' ' + (lx) + ' ' + (ly + (height / 2)) + ' ' +\r\n                'L' + ' ' + (lx + (width / 2)) + ' ' + (ly - (height / 2)) +\r\n                'L' + ' ' + (lx + (width / 2) - space) + ' ' + (ly - (height / 2)) + ' ' +\r\n                'L' + ' ' + (lx) + ' ' + (ly + (height / 2) - (2 * space)) +\r\n                'L' + (lx - (width / 2) + space) + ' ' + (ly - (height / 2)) + ' Z';\r\n            merge(options, { 'd': dir });\r\n            break;\r\n        case 'RightArrow':\r\n            dir = 'M' + ' ' + (lx + (-width / 2)) + ' ' + (ly - (height / 2)) + ' ' +\r\n                'L' + ' ' + (lx + (width / 2)) + ' ' + (ly) + ' ' + 'L' + ' ' +\r\n                (lx + (-width / 2)) + ' ' + (ly + (height / 2)) + ' L' + ' ' + (lx + (-width / 2)) + ' ' +\r\n                (ly + (height / 2) - space) + ' ' + 'L' + ' ' + (lx + (width / 2) - (2 * space)) + ' ' + (ly) +\r\n                ' L' + (lx + (-width / 2)) + ' ' + (ly - (height / 2) + space) + ' Z';\r\n            merge(options, { 'd': dir });\r\n            break;\r\n        case 'LeftArrow':\r\n            options.fill = options.stroke;\r\n            options.stroke = 'transparent';\r\n            dir = 'M' + ' ' + (lx + (width / 2)) + ' ' + (ly - (height / 2)) + ' ' +\r\n                'L' + ' ' + (lx + (-width / 2)) + ' ' + (ly) + ' ' + 'L' + ' ' +\r\n                (lx + (width / 2)) + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' +\r\n                (lx + (width / 2)) + ' ' + (ly + (height / 2) - space) + ' L' + ' ' + (lx + (-width / 2) + (2 * space))\r\n                + ' ' + (ly) + ' L' + (lx + (width / 2)) + ' ' + (ly - (height / 2) + space) + ' Z';\r\n            merge(options, { 'd': dir });\r\n            break;\r\n        case 'Column':\r\n        case 'Pareto':\r\n        case 'StackingColumn':\r\n        case 'StackingColumn100':\r\n        case 'RangeColumn':\r\n        case 'Histogram':\r\n            dir = 'M' + ' ' + (lx - 3 * (width / 5)) + ' ' + (ly - (height / 5)) + ' ' + 'L' + ' ' +\r\n                (lx + 3 * (-width / 10)) + ' ' + (ly - (height / 5)) + ' ' + 'L' + ' ' +\r\n                (lx + 3 * (-width / 10)) + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' ' + (lx - 3 *\r\n                (width / 5)) + ' ' + (ly + (height / 2)) + ' ' + 'Z' + ' ' + 'M' + ' ' +\r\n                (lx + (-width / 10) - (width / 20)) + ' ' + (ly - (height / 4) - (padding / 2))\r\n                + ' ' + 'L' + ' ' + (lx + (width / 10) + (width / 20)) + ' ' + (ly - (height / 4) -\r\n                (padding / 2)) + ' ' + 'L' + ' ' + (lx + (width / 10) + (width / 20)) + ' ' + (ly\r\n                + (height / 2)) + ' ' + 'L' + ' ' + (lx + (-width / 10) - (width / 20)) + ' ' + (ly +\r\n                (height / 2)) + ' ' + 'Z' + ' ' + 'M' + ' ' + (lx + 3 * (width / 10)) + ' ' + (ly) + ' ' +\r\n                'L' + ' ' + (lx + 3 * (width / 5)) + ' ' + (ly) + ' ' + 'L' + ' '\r\n                + (lx + 3 * (width / 5)) + ' ' + (ly + (height / 2)) + ' ' + 'L' + ' '\r\n                + (lx + 3 * (width / 10)) + ' ' + (ly + (height / 2)) + ' ' + 'Z';\r\n            merge(options, { 'd': dir });\r\n            break;\r\n        case 'Bar':\r\n        case 'StackingBar':\r\n        case 'StackingBar100':\r\n            dir = 'M' + ' ' + (lx + (-width / 2) + (-padding / 4)) + ' ' + (ly - 3 * (height / 5)) + ' '\r\n                + 'L' + ' ' + (lx + 3 * (width / 10)) + ' ' + (ly - 3 * (height / 5)) + ' ' + 'L' + ' ' +\r\n                (lx + 3 * (width / 10)) + ' ' + (ly - 3 * (height / 10)) + ' ' + 'L' + ' ' +\r\n                (lx - (width / 2) + (-padding / 4)) + ' ' + (ly - 3 * (height / 10)) + ' ' + 'Z' + ' '\r\n                + 'M' + ' ' + (lx + (-width / 2) + (-padding / 4)) + ' ' + (ly - (height / 5)\r\n                + (padding / 20)) + ' ' + 'L' + ' ' + (lx + (width / 2) + (padding / 4)) + ' ' + (ly\r\n                - (height / 5) + (padding / 20)) + ' ' + 'L' + ' ' + (lx + (width / 2) + (padding / 4))\r\n                + ' ' + (ly + (height / 10) + (padding / 20)) + ' ' + 'L' + ' ' + (lx - (width / 2)\r\n                + (-padding / 4)) + ' ' + (ly + (height / 10) + (padding / 20)) + ' ' + 'Z' + ' ' + 'M'\r\n                + ' ' + (lx - (width / 2) + (-padding / 4)) + ' ' + (ly + (height / 5)\r\n                + (padding / 10)) + ' ' + 'L' + ' ' + (lx + (-width / 4)) + ' ' + (ly + (height / 5)\r\n                + (padding / 10)) + ' ' + 'L' + ' ' + (lx + (-width / 4)) + ' ' + (ly + (height / 2)\r\n                + (padding / 10)) + ' ' + 'L' + ' ' + (lx - (width / 2) + (-padding / 4))\r\n                + ' ' + (ly + (height / 2) + (padding / 10)) + ' ' + 'Z';\r\n            merge(options, { 'd': dir });\r\n            break;\r\n        case 'Spline':\r\n            options.fill = 'transparent';\r\n            dir = 'M' + ' ' + (lx - (width / 2)) + ' ' + (ly + (height / 5)) + ' ' + 'Q' + ' '\r\n                + lx + ' ' + (ly - height) + ' ' + lx + ' ' + (ly + (height / 5))\r\n                + ' ' + 'M' + ' ' + lx + ' ' + (ly + (height / 5)) + ' ' + 'Q' + ' ' + (lx\r\n                + (width / 2)) + ' ' + (ly + (height / 2)) + ' ' + (lx + (width / 2)) + ' '\r\n                + (ly - (height / 2));\r\n            merge(options, { 'd': dir });\r\n            break;\r\n        case 'Area':\r\n        case 'MultiColoredArea':\r\n        case 'RangeArea':\r\n        case 'StackingArea':\r\n        case 'StackingArea100':\r\n            dir = 'M' + ' ' + (lx - (width / 2) - (padding / 4)) + ' ' + (ly + (height / 2))\r\n                + ' ' + 'L' + ' ' + (lx + (-width / 4) + (-padding / 8)) + ' ' + (ly - (height / 2))\r\n                + ' ' + 'L' + ' ' + (lx) + ' ' + (ly + (height / 4)) + ' ' + 'L' + ' ' + (lx\r\n                + (width / 4) + (padding / 8)) + ' ' + (ly + (-height / 2) + (height / 4)) + ' '\r\n                + 'L' + ' ' + (lx + (height / 2) + (padding / 4)) + ' ' + (ly + (height / 2)) + ' ' + 'Z';\r\n            merge(options, { 'd': dir });\r\n            break;\r\n        case 'SplineArea':\r\n        case 'SplineRangeArea':\r\n            dir = 'M' + ' ' + (lx - (width / 2)) + ' ' + (ly + (height / 5)) + ' ' + 'Q' + ' ' + lx\r\n                + ' ' + (ly - height) + ' ' + lx + ' ' + (ly + (height / 5)) + ' ' + 'Z' + ' ' + 'M'\r\n                + ' ' + lx + ' ' + (ly + (height / 5)) + ' ' + 'Q' + ' ' + (lx + (width / 2)) + ' '\r\n                + (ly + (height / 2)) + ' ' + (lx + (width / 2)) + ' '\r\n                + (ly - (height / 2)) + ' ' + ' Z';\r\n            merge(options, { 'd': dir });\r\n            break;\r\n        case 'Pie':\r\n        case 'Doughnut': {\r\n            options.stroke = 'transparent';\r\n            var r = Math.min(height, width) / 2;\r\n            dir = getAccumulationLegend(lx, ly, r, height, width);\r\n            merge(options, { 'd': dir });\r\n            break;\r\n        }\r\n    }\r\n    return { renderOption: options };\r\n}\r\n/**\r\n * Trims the text to fit within the specified maximum width.\r\n *\r\n * @param {number} maxWidth - The maximum width for the text.\r\n * @param {string} text - The text to be trimmed.\r\n * @param {FontModel} font - The font settings for the text.\r\n * @param {boolean} isRtlEnabled - Indicates whether right-to-left text rendering is enabled.\r\n * @param {FontModel} [themeFontStyle] - The font style to be used for theme-specific settings.\r\n * @returns {string} - The trimmed text.\r\n */\r\nexport function textTrim(maxWidth, text, font, isRtlEnabled, themeFontStyle) {\r\n    var label = text;\r\n    var size = measureText(text, font, themeFontStyle).width;\r\n    if (size > maxWidth) {\r\n        var textLength = text.length;\r\n        for (var i = textLength - 1; i >= 0; --i) {\r\n            label = isRtlEnabled ? '...' + text.substring(0, i) : text.substring(0, i) + '...';\r\n            size = measureText(label, font, themeFontStyle).width;\r\n            if (size <= maxWidth) {\r\n                return label;\r\n            }\r\n        }\r\n    }\r\n    return label;\r\n}\r\n/**\r\n * Trims the text and performs line breaks based on the maximum width and font settings.\r\n *\r\n * @param {number} maxWidth - The maximum width allowed for the text.\r\n * @param {string} text - The text to be trimmed.\r\n * @param {FontModel} font - The font settings for the text.\r\n * @param {FontModel} [themeFontStyle] - Optional. The font style based on the theme.\r\n * @returns {string[]} - An array of trimmed text lines with line breaks.\r\n */\r\nexport function lineBreakLabelTrim(maxWidth, text, font, themeFontStyle) {\r\n    var labelCollection = [];\r\n    var breakLabels = text.split('<br>');\r\n    for (var i = 0; i < breakLabels.length; i++) {\r\n        text = breakLabels[i];\r\n        var size = measureText(text, font, themeFontStyle).width;\r\n        if (size > maxWidth) {\r\n            var textLength = text.length;\r\n            for (var i_1 = textLength - 1; i_1 >= 0; --i_1) {\r\n                text = text.substring(0, i_1) + '...';\r\n                size = measureText(text, font, themeFontStyle).width;\r\n                if (size <= maxWidth) {\r\n                    labelCollection.push(text);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            labelCollection.push(text);\r\n        }\r\n    }\r\n    return labelCollection;\r\n}\r\n/**\r\n * Converts a string value to a number, considering the container size for percentage values.\r\n *\r\n * @param {string} value - The string value to convert to a number.\r\n * @param {number} containerSize - The size of the container, used for percentage values.\r\n * @returns {number} - The converted numeric value.\r\n */\r\nexport function stringToNumber(value, containerSize) {\r\n    if (value !== null && value !== undefined) {\r\n        return value.indexOf('%') !== -1 ? (containerSize / 100) * parseInt(value, 10) : parseInt(value, 10);\r\n    }\r\n    return null;\r\n}\r\n/**\r\n * Redraws the SVG or canvas element based on the provided options.\r\n *\r\n * @param {boolean} redraw - Specifies whether to redraw the element.\r\n * @param {string} id - The id of the element to redraw.\r\n * @param {PathAttributes | RectAttributes | CircleAttributes} [options] - The attributes of the element to redraw.\r\n * @param {SvgRenderer | CanvasRenderer} [renderer] - The renderer to use for redrawing.\r\n * @returns {Element} - The redrawn element.\r\n */\r\nexport function redrawElement(redraw, id, options, renderer) {\r\n    if (!redraw) {\r\n        return null;\r\n    }\r\n    var element = getElement(id);\r\n    if (element && options) {\r\n        renderer.setElementAttributes(options, element.tagName === 'clipPath' ? element.childNodes[0] : element);\r\n    }\r\n    return element;\r\n}\r\n/**\r\n * Animates the redrawn element from its start to end location over a specified duration.\r\n *\r\n * @param {Element | HTMLElement} element - The element to animate.\r\n * @param {number} duration - The duration of the animation in milliseconds.\r\n * @param {ChartLocation} start - The start location of the element.\r\n * @param {ChartLocation} end - The end location of the element.\r\n * @param {string} [x='x'] - The attribute representing the horizontal position of the element.\r\n * @param {string} [y='y'] - The attribute representing the vertical position of the element.\r\n * @param {number} [angle=0] - The angle of rotation for the element.\r\n * @param {ChartLocation} [newTransform=new ChartLocation(0, 0)] - The new transform location of the element.\r\n * @param {ChartLocation} [previousTransform=new ChartLocation(0, 0)] - The previous transform location of the element.\r\n * @returns {void}\r\n */\r\nexport function animateRedrawElement(element, duration, start, end, x, y, angle, newTransform, previousTransform) {\r\n    if (x === void 0) { x = 'x'; }\r\n    if (y === void 0) { y = 'y'; }\r\n    if (angle === void 0) { angle = 0; }\r\n    if (newTransform === void 0) { newTransform = new ChartLocation(0, 0); }\r\n    if (previousTransform === void 0) { previousTransform = new ChartLocation(0, 0); }\r\n    var isDiv = element.tagName === 'DIV';\r\n    var setStyle = function (xValue, yValue, rotateX, rotateY) {\r\n        if (isDiv) {\r\n            element.style[x] = xValue + 'px';\r\n            element.style[y] = yValue + 'px';\r\n        }\r\n        else {\r\n            element.setAttribute(x, xValue + '');\r\n            element.setAttribute(y, yValue + '');\r\n            if (angle && newTransform.x && newTransform.y && previousTransform.x && previousTransform.y && rotateX && rotateY) {\r\n                element.setAttribute('transform', 'rotate(' + angle + ',' + rotateX + ',' + rotateY + ')');\r\n            }\r\n        }\r\n    };\r\n    setStyle(start.x, start.y, previousTransform.x, previousTransform.y);\r\n    new Animation({}).animate(createElement('div'), {\r\n        duration: duration,\r\n        progress: function (args) {\r\n            setStyle(linear(args.timeStamp, start.x, end.x - start.x, args.duration), linear(args.timeStamp, start.y, end.y - start.y, args.duration), linear(args.timeStamp, previousTransform.x, newTransform.x - previousTransform.x, args.duration), linear(args.timeStamp, previousTransform.y, newTransform.y - previousTransform.y, args.duration));\r\n        },\r\n        end: function () {\r\n            setStyle(end.x, end.y, newTransform.x, newTransform.y);\r\n        }\r\n    });\r\n}\r\n/**\r\n * Renders a text element using the specified renderer and options.\r\n *\r\n * @param {SvgRenderer | CanvasRenderer} renderer - The renderer used for rendering.\r\n * @param {TextOption} option - The options for the text element.\r\n * @param {FontModel} font - The font settings for the text.\r\n * @param {string} color - The color of the text.\r\n * @param {HTMLElement | Element} parent - The parent element to which the text element is appended.\r\n * @param {boolean} [isMinus=false] - Indicates whether the text represents a negative value.\r\n * @param {boolean} [redraw] - Indicates whether to redraw the element.\r\n * @param {boolean} [isAnimate] - Indicates whether to animate the element.\r\n * @param {boolean} [forceAnimate=false] - Indicates whether to force animation.\r\n * @param {number} [animateDuration] - The duration of the animation in milliseconds.\r\n * @param {Rect} [seriesClipRect] - The clipping rectangle for the series.\r\n * @param {Size} [labelSize] - The size of the label.\r\n * @param {boolean} [isRotatedLabelIntersect] - Indicates whether rotated labels intersect.\r\n * @param {boolean} [isCanvas] - Indicates whether the rendering is done on a canvas.\r\n * @param {boolean} [isDataLabelWrap] - Indicates whether data labels are wrapped.\r\n * @param {FontModel} [themeFontStyle] - The font settings based on the theme.\r\n * @param {ChartLocation} [transform] - The location to transform the text element.\r\n * @returns {Element} - The rendered text element.\r\n */\r\nexport function textElement(renderer, option, font, color, parent, isMinus, redraw, isAnimate, forceAnimate, animateDuration, seriesClipRect, labelSize, isRotatedLabelIntersect, isCanvas, isDataLabelWrap, themeFontStyle, transform) {\r\n    if (isMinus === void 0) { isMinus = false; }\r\n    if (forceAnimate === void 0) { forceAnimate = false; }\r\n    var renderOptions = {};\r\n    var tspanElement;\r\n    //let renderer: SvgRenderer = new SvgRenderer('');\r\n    var height;\r\n    var dy;\r\n    var label;\r\n    var width = 0;\r\n    var dx;\r\n    var maxWidth = 0;\r\n    if (option.text.length > 1 && isDataLabelWrap) {\r\n        for (var i = 0, len = option.text.length; i < len; i++) {\r\n            maxWidth = Math.max(maxWidth, measureText(option.text[i], font, themeFontStyle).width);\r\n        }\r\n        width = measureText(option.text[0], font, themeFontStyle).width;\r\n    }\r\n    dx = (option.text.length > 1 && isDataLabelWrap) ? (option.x + maxWidth / 2 - width / 2) : option.x;\r\n    renderOptions = {\r\n        'id': option.id,\r\n        'x': dx,\r\n        'y': option.y,\r\n        'fill': color ? color : 'black',\r\n        'font-size': font.size || themeFontStyle.size,\r\n        'font-style': font.fontStyle || themeFontStyle.fontStyle,\r\n        'font-family': font.fontFamily || themeFontStyle.fontFamily,\r\n        'font-weight': font.fontWeight || themeFontStyle.fontWeight,\r\n        'text-anchor': option.anchor,\r\n        'labelRotation': option.labelRotation,\r\n        'transform': option.transform,\r\n        'opacity': font.opacity,\r\n        'dominant-baseline': option.baseLine\r\n    };\r\n    var text = typeof option.text === 'string' ? option.text : isMinus ? option.text[option.text.length - 1] : option.text[0];\r\n    var transX = seriesClipRect ? seriesClipRect.x : 0;\r\n    var transY = seriesClipRect ? seriesClipRect.y : 0;\r\n    var htmlObject = renderer.createText(renderOptions, text, transX, transY);\r\n    if (typeof option.text !== 'string' && option.text.length > 1) {\r\n        for (var i = 1, len = option.text.length; i < len; i++) {\r\n            height = (measureText(option.text[i], font, themeFontStyle).height);\r\n            width = measureText(option.text[i], font, themeFontStyle).width;\r\n            dy = (option.y) + ((isMinus) ? -(i * height) : (i * height));\r\n            dx = isDataLabelWrap ? (option.x + maxWidth / 2 - width / 2) : option.x;\r\n            label = isMinus ? option.text[option.text.length - (i + 1)] : option.text[i];\r\n            if (isCanvas) {\r\n                tspanElement = renderer.createText(renderOptions, label, null, null, dy, true);\r\n            }\r\n            else {\r\n                tspanElement = renderer.createTSpan({\r\n                    'x': dx, 'id': option.id,\r\n                    'y': dy\r\n                }, label);\r\n                htmlObject.appendChild(tspanElement);\r\n            }\r\n        }\r\n    }\r\n    if (!isRotatedLabelIntersect) {\r\n        appendChildElement(renderer instanceof CanvasRenderer, parent, htmlObject, redraw, isAnimate, 'x', 'y', null, null, forceAnimate, false, null, animateDuration, false, option.labelRotation, transform);\r\n    }\r\n    return htmlObject;\r\n}\r\n/**\r\n * Calculates the size of the chart.\r\n *\r\n * @param {Chart | AccumulationChart | RangeNavigator | StockChart | Chart3D | CircularChart3D} chart - The chart for which to calculate the size.\r\n * @returns {void}\r\n */\r\nexport function calculateSize(chart) {\r\n    // fix for Chart rendered with default width in IE issue\r\n    var containerWidth = chart.element.clientWidth || chart.element.offsetWidth;\r\n    var containerHeight = chart.element.clientHeight;\r\n    if (chart.stockChart) {\r\n        containerWidth = chart.stockChart.availableSize.width;\r\n        containerHeight = chart.stockChart.availableSize.height;\r\n    }\r\n    var height = 450;\r\n    var marginHeight;\r\n    if (chart.getModuleName() === 'rangeNavigator') {\r\n        var range = chart;\r\n        var tooltipSpace = range.tooltip.enable ? 35 : 0;\r\n        var periodHeight = range.periodSelectorSettings.periods.length ?\r\n            range.periodSelectorSettings.height : 0;\r\n        marginHeight = range.margin.top + range.margin.bottom + tooltipSpace;\r\n        var labelSize = measureText('tempString', range.labelStyle, range.themeStyle.axisLabelFont).height;\r\n        var labelPadding = 15;\r\n        height = (chart.series.length ? (Browser.isDevice ? 80 : 120) : ((range.enableGrouping ? (40 + labelPadding + labelSize) : 40)\r\n            + marginHeight)) + periodHeight;\r\n        if (range.disableRangeSelector) {\r\n            height = periodHeight;\r\n        }\r\n        if (chart.stockChart && chart.stockChart.chart.axisCollections[1].labelPosition === 'Outside') {\r\n            var padding = chart.stockChart.chart.axisCollections[1].labelPadding + chart.stockChart.chart.axisCollections[1].lineStyle.width * 0.5;\r\n            chart.width = (chart.stockChart.availableSize.width - (chart.stockChart.chart.axisCollections[1].maxLabelSize.width + padding)).toString();\r\n        }\r\n    }\r\n    chart.availableSize = new Size(stringToNumber(chart.width, containerWidth) || containerWidth || 600, stringToNumber(chart.height, containerHeight || height) || containerHeight || height);\r\n    if (chart.getModuleName() === 'chart') {\r\n        var scaleX = 1;\r\n        var scaleY = 1;\r\n        if (chart.width === '' || chart.width === null || chart.width === '100%') {\r\n            if (containerWidth && chart.element.parentElement.style.transform.indexOf('scale') > -1) {\r\n                scaleX = 1;\r\n            }\r\n            else {\r\n                scaleX = chart.element.getBoundingClientRect().width > 0 ?\r\n                    chart.element.getBoundingClientRect().width / chart.availableSize.width : 1;\r\n            }\r\n            if (containerHeight && chart.element.parentElement.style.transform.indexOf('scale') > -1) {\r\n                scaleY = 1;\r\n            }\r\n            else {\r\n                scaleY = chart.element.getBoundingClientRect().height > 0 ?\r\n                    chart.element.getBoundingClientRect().height / chart.availableSize.height : 1;\r\n            }\r\n            var transformValue = chart.element.style.transform;\r\n            if (transformValue) {\r\n                var scaleValue = parseFloat(transformValue.match(/scale\\((.*?)\\)/)[1]);\r\n                scaleX = scaleValue ? scaleX / scaleValue : scaleX;\r\n                scaleY = scaleValue ? scaleY / scaleValue : scaleY;\r\n            }\r\n            chart.availableSize.width = chart.availableSize.width * scaleX;\r\n            chart.availableSize.height = chart.availableSize.height * scaleY;\r\n        }\r\n        chart.scaleX = scaleX;\r\n        chart.scaleY = scaleY;\r\n    }\r\n}\r\n/**\r\n * Creates an SVG element for the specified chart or chart element.\r\n *\r\n * @param {Chart | AccumulationChart | RangeNavigator | Chart3D | CircularChart3D} chart - The chart or chart element for which to create the SVG element.\r\n * @returns {void}\r\n */\r\nexport function createSvg(chart) {\r\n    chart.canvasRender = new CanvasRenderer(chart.element.id);\r\n    chart.renderer = chart.enableCanvas ? chart.canvasRender : new SvgRenderer(chart.element.id);\r\n    calculateSize(chart);\r\n    if (chart.stockChart && chart.getModuleName() === 'chart') {\r\n        chart.svgObject = chart.stockChart.chartObject;\r\n    }\r\n    else if (chart.stockChart && chart.getModuleName() === 'rangeNavigator') {\r\n        chart.svgObject = chart.stockChart.selectorObject;\r\n    }\r\n    else {\r\n        if (chart.enableCanvas) {\r\n            chart.svgObject = chart.renderer.createCanvas({\r\n                id: chart.element.id + '_canvas',\r\n                width: chart.availableSize.width,\r\n                height: chart.availableSize.height\r\n            });\r\n        }\r\n        else {\r\n            chart.svgObject = chart.renderer.createSvg({\r\n                id: chart.element.id + '_svg',\r\n                width: chart.availableSize.width,\r\n                height: chart.availableSize.height\r\n            });\r\n        }\r\n    }\r\n    if (chart.enableCanvas) {\r\n        chart.renderer.ctx.direction = chart.enableRtl ? 'rtl' : 'ltr';\r\n    }\r\n}\r\n/**\r\n * Gets the title text with specified style and width, and supports right-to-left rendering.\r\n *\r\n * @param {string} title - The title text.\r\n * @param {FontModel} style - The font style for the title.\r\n * @param {number} width - The width available for rendering the title.\r\n * @param {boolean} isRtlEnabled - Specifies whether right-to-left rendering is enabled.\r\n * @param {FontModel} [themeFontStyle] - The font style used for theme rendering.\r\n * @returns {string[]} An array of strings containing the title text with line breaks if needed.\r\n */\r\nexport function getTitle(title, style, width, isRtlEnabled, themeFontStyle) {\r\n    var titleCollection = [];\r\n    switch (style.textOverflow) {\r\n        case 'Wrap':\r\n            titleCollection = textWrap(title, width, style, isRtlEnabled, title.indexOf(' ') < 0 ? true : null, null, themeFontStyle);\r\n            break;\r\n        case 'Trim':\r\n            titleCollection.push(textTrim(width, title, style, isRtlEnabled, themeFontStyle));\r\n            break;\r\n        default:\r\n            titleCollection.push(title);\r\n            break;\r\n    }\r\n    return titleCollection;\r\n}\r\n/**\r\n * Calculates the x-coordinate position for rendering the title text within the specified rect.\r\n *\r\n * @param {Rect} rect - The rect within which the title text is to be rendered.\r\n * @param {FontModel} titleStyle - The font style used for rendering the title text.\r\n * @returns {number} The x-coordinate position for rendering the title text.\r\n */\r\nexport function titlePositionX(rect, titleStyle) {\r\n    var positionX;\r\n    if (titleStyle.textAlignment === 'Near') {\r\n        positionX = rect.x;\r\n    }\r\n    else if (titleStyle.textAlignment === 'Center') {\r\n        positionX = rect.x + rect.width / 2;\r\n    }\r\n    else {\r\n        positionX = rect.x + rect.width;\r\n    }\r\n    return positionX;\r\n}\r\n/**\r\n * Wraps the input text into multiple lines based on the specified maximum width and font style.\r\n *\r\n * @param {string} currentLabel - The text to be wrapped.\r\n * @param {number} maximumWidth - The maximum width allowed for each line of text.\r\n * @param {FontModel} font - The font style used for rendering the text.\r\n * @param {boolean} isRtlEnabled - Specifies whether right-to-left text direction is enabled.\r\n * @param {boolean} [wrapAnyWhere=false] - Indicates whether the text can be wrapped at any position.\r\n * @param {boolean} [clip=false] - Specifies whether text exceeding the maximum width should be clipped.\r\n * @param {FontModel} [themeFontStyle] - The font style used as the base for the text wrapping operation.\r\n * @returns {string[]} An array of strings representing the wrapped lines of text.\r\n */\r\nexport function textWrap(currentLabel, maximumWidth, font, isRtlEnabled, wrapAnyWhere, clip, themeFontStyle) {\r\n    if (wrapAnyWhere) {\r\n        return (textWrapAnyWhere(currentLabel, maximumWidth, font, themeFontStyle));\r\n    }\r\n    else {\r\n        var textCollection = currentLabel.split(' ');\r\n        var label = '';\r\n        var labelCollection = [];\r\n        var text = void 0;\r\n        for (var i = 0, len = textCollection.length; i < len; i++) {\r\n            text = textCollection[i];\r\n            if (measureText(label.concat(label === '' ? '' : ' ' + text), font, themeFontStyle).width < maximumWidth) {\r\n                label = label.concat((label === '' ? '' : ' ') + text);\r\n            }\r\n            else {\r\n                if (label !== '') {\r\n                    labelCollection.push(clip ? label : textTrim(maximumWidth, label, font, isRtlEnabled, themeFontStyle));\r\n                    label = text;\r\n                }\r\n                else {\r\n                    labelCollection.push(clip ? text : textTrim(maximumWidth, text, font, isRtlEnabled, themeFontStyle));\r\n                    text = '';\r\n                }\r\n            }\r\n            if (label && i === len - 1) {\r\n                labelCollection.push(clip ? label : textTrim(maximumWidth, label, font, isRtlEnabled, themeFontStyle));\r\n            }\r\n        }\r\n        return labelCollection;\r\n    }\r\n}\r\n/**\r\n * Wraps the input text into multiple lines, allowing wrapping at any position.\r\n *\r\n * @param {string} currentLabel - The text to be wrapped.\r\n * @param {number} maximumWidth - The maximum width allowed for each line of text.\r\n * @param {FontModel} font - The font style used for rendering the text.\r\n * @param {FontModel} [themeFontStyle] - The font style used as the base for the text wrapping operation.\r\n * @returns {string[]} An array of strings representing the wrapped lines of text.\r\n */\r\nexport function textWrapAnyWhere(currentLabel, maximumWidth, font, themeFontStyle) {\r\n    var size = measureText(currentLabel, font, themeFontStyle).width;\r\n    var labelCollection = [];\r\n    if (size > maximumWidth) {\r\n        var label = '';\r\n        var startIndex = 0;\r\n        var labelIndex = 1;\r\n        while (labelIndex < currentLabel.length) {\r\n            label = currentLabel.substring(startIndex, labelIndex);\r\n            size = measureText(label, font, themeFontStyle).width;\r\n            if (size < maximumWidth) {\r\n                labelIndex++;\r\n            }\r\n            else if (size === maximumWidth) {\r\n                startIndex = labelIndex;\r\n                labelCollection.push(label);\r\n                labelIndex++;\r\n                label = '';\r\n            }\r\n            else if (size > maximumWidth) {\r\n                label = label.slice(0, -1);\r\n                startIndex = labelIndex - 1;\r\n                labelCollection.push(label);\r\n                label = '';\r\n            }\r\n        }\r\n        if (label.length > 0) {\r\n            labelCollection.push(label);\r\n        }\r\n    }\r\n    else {\r\n        labelCollection.push(currentLabel);\r\n    }\r\n    return labelCollection;\r\n}\r\n/**\r\n * Gets the Unicode text from the input string based on the provided regular expression.\r\n *\r\n * @param {string} text - The input string.\r\n * @param {RegExp} regexp - The regular expression pattern to match Unicode characters.\r\n * @returns {string} The Unicode text extracted from the input string.\r\n */\r\nexport function getUnicodeText(text, regexp) {\r\n    var title = text.replace(regexp, ' ');\r\n    var digit = text.match(regexp);\r\n    var digitSpecific = ' ';\r\n    var convertedText = ' ';\r\n    var k = 0;\r\n    var unicodeSub = {\r\n        '0': '\\u2080', '1': '\\u2081', '2': '\\u2082', '3': '\\u2083', '4': '\\u2084',\r\n        '5': '\\u2085', '6': '\\u2086', '7': '\\u2087', '8': '\\u2088', '9': '\\u2089'\r\n    };\r\n    var unicodeSup = {\r\n        '0': '\\u2070', '1': '\\u00B9', '2': '\\u00B2', '3': '\\u00B3', '4': '\\u2074',\r\n        '5': '\\u2075', '6': '\\u2076', '7': '\\u2077', '8': '\\u2078', '9': '\\u2079'\r\n    };\r\n    for (var i = 0; i <= title.length - 1; i++) {\r\n        if (title[i] === ' ') {\r\n            digitSpecific = (regexp === regSub) ? digit[k].replace(/~/g, '') : digit[k].replace(/\\^/g, '');\r\n            for (var j = 0; j < digitSpecific.length; j++) {\r\n                convertedText += (regexp === regSub) ? unicodeSub[digitSpecific[j]] : unicodeSup[digitSpecific[j]];\r\n            }\r\n            k++;\r\n        }\r\n        else {\r\n            convertedText += title[i];\r\n        }\r\n    }\r\n    return convertedText.trim();\r\n}\r\n/**\r\n * Resets the Blazor templates of the given control (Chart or AccumulationChart).\r\n *\r\n * @param {Chart | AccumulationChart} control - The control to reset Blazor templates for.\r\n * @returns {void}\r\n */\r\nexport function blazorTemplatesReset(control) {\r\n    for (var i = 0; i < control.annotations.length; i++) {\r\n        resetBlazorTemplate((control.element.id + '_Annotation_' + i).replace(/[^a-zA-Z0-9]/g, ''), 'ContentTemplate');\r\n    }\r\n    //This reset the tooltip templates\r\n    resetBlazorTemplate(control.element.id + '_tooltipparent_template' + '_blazorTemplate', 'Template');\r\n    //Datalabel templates reset\r\n    resetBlazorTemplate(control.element.id + '_DataLabel');\r\n}\r\n/** @private */\r\nvar CustomizeOption = /** @class */ (function () {\r\n    function CustomizeOption(id) {\r\n        this.id = id;\r\n    }\r\n    return CustomizeOption;\r\n}());\r\nexport { CustomizeOption };\r\n/** @private */\r\nvar StackValues = /** @class */ (function () {\r\n    function StackValues(startValue, endValue) {\r\n        this.startValues = startValue;\r\n        this.endValues = endValue;\r\n    }\r\n    return StackValues;\r\n}());\r\nexport { StackValues };\r\n/** @private */\r\nvar RectOption = /** @class */ (function (_super) {\r\n    __extends(RectOption, _super);\r\n    function RectOption(id, fill, border, opacity, rect, rx, ry, transform, dashArray) {\r\n        var _this = _super.call(this, id, fill, border.width, border.color, opacity, dashArray) || this;\r\n        _this.y = rect.y;\r\n        _this.x = rect.x;\r\n        _this.height = rect.height;\r\n        _this.width = rect.width;\r\n        _this.rx = rx ? rx : 0;\r\n        _this.ry = ry ? ry : 0;\r\n        _this.transform = transform ? transform : '';\r\n        _this.stroke = (border.width !== 0 && _this.stroke !== '') ? border.color === null ? '' : border.color : 'transparent';\r\n        return _this;\r\n    }\r\n    return RectOption;\r\n}(PathOption));\r\nexport { RectOption };\r\n/** @private */\r\nvar ImageOption = /** @class */ (function () {\r\n    function ImageOption(height, width, href, x, y, id, visibility, preserveAspectRatio) {\r\n        this.height = height;\r\n        this.width = width;\r\n        this.href = href;\r\n        this.x = x;\r\n        this.y = y;\r\n        this.id = id;\r\n        this.visibility = visibility;\r\n        this.preserveAspectRatio = preserveAspectRatio;\r\n    }\r\n    return ImageOption;\r\n}());\r\nexport { ImageOption };\r\n/** @private */\r\nvar CircleOption = /** @class */ (function (_super) {\r\n    __extends(CircleOption, _super);\r\n    function CircleOption(id, fill, border, opacity, cx, cy, r) {\r\n        var _this = _super.call(this, id, fill, border.width, border.color, opacity) || this;\r\n        _this.cy = cy;\r\n        _this.cx = cx;\r\n        _this.r = r;\r\n        return _this;\r\n    }\r\n    return CircleOption;\r\n}(PathOption));\r\nexport { CircleOption };\r\n/** @private */\r\nvar PolygonOption = /** @class */ (function () {\r\n    function PolygonOption(id, points, fill) {\r\n        this.id = id;\r\n        this.points = points;\r\n        this.fill = fill;\r\n    }\r\n    return PolygonOption;\r\n}());\r\nexport { PolygonOption };\r\n/** @private */\r\nvar ChartLocation = /** @class */ (function () {\r\n    function ChartLocation(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    return ChartLocation;\r\n}());\r\nexport { ChartLocation };\r\n/** @private */\r\nvar LabelLocation = /** @class */ (function () {\r\n    function LabelLocation(x, y) {\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    return LabelLocation;\r\n}());\r\nexport { LabelLocation };\r\n/** @private */\r\nvar Thickness = /** @class */ (function () {\r\n    function Thickness(left, right, top, bottom) {\r\n        this.left = left;\r\n        this.right = right;\r\n        this.top = top;\r\n        this.bottom = bottom;\r\n    }\r\n    return Thickness;\r\n}());\r\nexport { Thickness };\r\n/** @private */\r\nvar ColorValue = /** @class */ (function () {\r\n    function ColorValue(r, g, b) {\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n    }\r\n    return ColorValue;\r\n}());\r\nexport { ColorValue };\r\n/** @private */\r\nvar PointData = /** @class */ (function () {\r\n    function PointData(point, series, index) {\r\n        if (index === void 0) { index = 0; }\r\n        this.point = point;\r\n        this.series = series;\r\n        this.lierIndex = index;\r\n    }\r\n    return PointData;\r\n}());\r\nexport { PointData };\r\n/** @private */\r\nvar AccPointData = /** @class */ (function () {\r\n    function AccPointData(point, series, index) {\r\n        if (index === void 0) { index = 0; }\r\n        this.point = point;\r\n        this.series = series;\r\n        this.index = index;\r\n    }\r\n    return AccPointData;\r\n}());\r\nexport { AccPointData };\r\n/** @private */\r\nvar Point3D = /** @class */ (function () {\r\n    /**\r\n     * Initializes a new instance of the Chart3DData class.\r\n     *\r\n     * @param {Chart3DPoint} point - The 3D point object.\r\n     * @param {Chart3DSeries} series - The 3D series object.\r\n     * @private\r\n     */\r\n    function Point3D(point, series) {\r\n        this.point = point;\r\n        this.series = series;\r\n    }\r\n    return Point3D;\r\n}());\r\nexport { Point3D };\r\n/** @private */\r\nvar ControlPoints = /** @class */ (function () {\r\n    function ControlPoints(controlPoint1, controlPoint2) {\r\n        this.controlPoint1 = controlPoint1;\r\n        this.controlPoint2 = controlPoint2;\r\n    }\r\n    return ControlPoints;\r\n}());\r\nexport { ControlPoints };\r\n/**\r\n * Gets the color from the range color setting model based on the specified value.\r\n *\r\n * @param {RangeColorSettingModel} colorMap - The range color setting model.\r\n * @param {number} value - The value for which to get the color.\r\n * @returns {string} - The color corresponding to the specified value.\r\n */\r\nexport function getColorByValue(colorMap, value) {\r\n    var color = '';\r\n    var rbgColorValue;\r\n    if (Number(value) === colorMap.start) {\r\n        color = colorMap.colors[0];\r\n    }\r\n    else if (Number(value) === colorMap.end) {\r\n        color = colorMap.colors[colorMap.colors.length - 1];\r\n    }\r\n    else {\r\n        rbgColorValue = getGradientColor(Number(value), colorMap);\r\n        color = convertToHexCode(rbgColorValue);\r\n    }\r\n    return color;\r\n}\r\n/**\r\n * Gets the gradient color from the range color setting model based on the specified value.\r\n *\r\n * @param {number} value - The value for which to get the gradient color.\r\n * @param {RangeColorSettingModel} colorMap - The range color setting model.\r\n * @returns {ColorValue} - The gradient color corresponding to the specified value.\r\n */\r\nexport function getGradientColor(value, colorMap) {\r\n    var previousOffset = colorMap.start;\r\n    var nextOffset = colorMap.end;\r\n    var percent = 0;\r\n    var full = nextOffset - previousOffset;\r\n    var midColor;\r\n    percent = (value - previousOffset) / full;\r\n    var previousColor;\r\n    var nextColor;\r\n    if (colorMap.colors.length <= 2) {\r\n        previousColor = colorMap.colors[0].charAt(0) === '#' ? colorMap.colors[0] : colorNameToHex(colorMap.colors[0]);\r\n        nextColor = colorMap.colors[colorMap.colors.length - 1].charAt(0) === '#' ?\r\n            colorMap.colors[colorMap.colors.length - 1] : colorNameToHex(colorMap.colors[colorMap.colors.length - 1]);\r\n    }\r\n    else {\r\n        previousColor = colorMap.colors[0].charAt(0) === '#' ? colorMap.colors[0] : colorNameToHex(colorMap.colors[0]);\r\n        nextColor = colorMap.colors[colorMap.colors.length - 1].charAt(0) === '#' ?\r\n            colorMap.colors[colorMap.colors.length - 1] : colorNameToHex(colorMap.colors[colorMap.colors.length - 1]);\r\n        var a = full / (colorMap.colors.length - 1);\r\n        var b = void 0;\r\n        var c = void 0;\r\n        var length_2 = colorMap.colors.length - 1;\r\n        var splitColorValueOffset = [];\r\n        var splitColor = {};\r\n        for (var j = 1; j < length_2; j++) {\r\n            c = j * a;\r\n            b = previousOffset + c;\r\n            splitColor = { b: b, color: colorMap.colors[j] };\r\n            splitColorValueOffset.push(splitColor);\r\n        }\r\n        for (var i = 0; i < splitColorValueOffset.length; i++) {\r\n            if (previousOffset <= value && value <= splitColorValueOffset[i]['b'] && i === 0) {\r\n                midColor = splitColorValueOffset[i]['color'].charAt(0) === '#' ?\r\n                    splitColorValueOffset[i]['color'] : colorNameToHex(splitColorValueOffset[i]['color']);\r\n                nextColor = midColor;\r\n                percent = value <= splitColorValueOffset[i]['b'] ? 1 - Math.abs((value - splitColorValueOffset[i]['b']) / a)\r\n                    : (value - splitColorValueOffset[i]['b']) / a;\r\n            }\r\n            else if (splitColorValueOffset[i]['b'] <= value && value <= nextOffset && i === (splitColorValueOffset.length - 1)) {\r\n                midColor = splitColorValueOffset[i]['color'].charAt(0) === '#' ?\r\n                    splitColorValueOffset[i]['color'] : colorNameToHex(splitColorValueOffset[i]['color']);\r\n                previousColor = midColor;\r\n                percent = value < splitColorValueOffset[i]['b'] ?\r\n                    1 - Math.abs((value - splitColorValueOffset[i]['b']) / a) : (value - splitColorValueOffset[i]['b']) / a;\r\n            }\r\n            if (i !== splitColorValueOffset.length - 1 && i < splitColorValueOffset.length) {\r\n                if (splitColorValueOffset[i]['b'] <= value && value <= splitColorValueOffset[i + 1]['b']) {\r\n                    midColor = splitColorValueOffset[i]['color'].charAt(0) === '#' ?\r\n                        splitColorValueOffset[i]['color'] : colorNameToHex(splitColorValueOffset[i]['color']);\r\n                    previousColor = midColor;\r\n                    nextColor = splitColorValueOffset[i + 1]['color'].charAt(0) === '#' ?\r\n                        splitColorValueOffset[i + 1]['color'] : colorNameToHex(splitColorValueOffset[i + 1]['color']);\r\n                    percent = Math.abs((value - splitColorValueOffset[i + 1]['b'])) / a;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return getPercentageColor(percent, previousColor, nextColor);\r\n}\r\n/**\r\n * Calculates the color based on the percentage change between two values.\r\n *\r\n * @param {number} percent - The percentage change.\r\n * @param {string} previous - The color for the previous value.\r\n * @param {string} next - The color for the next value.\r\n * @returns {ColorValue} - The calculated color value.\r\n */\r\nexport function getPercentageColor(percent, previous, next) {\r\n    var nextColor = next.split('#')[1];\r\n    var prevColor = previous.split('#')[1];\r\n    var r = getPercentage(percent, parseInt(prevColor.substr(0, 2), 16), parseInt(nextColor.substr(0, 2), 16));\r\n    var g = getPercentage(percent, parseInt(prevColor.substr(2, 2), 16), parseInt(nextColor.substr(2, 2), 16));\r\n    var b = getPercentage(percent, parseInt(prevColor.substr(4, 2), 16), parseInt(nextColor.substr(4, 2), 16));\r\n    return new ColorValue(r, g, b);\r\n}\r\n/**\r\n * Calculates the percentage change between two values.\r\n *\r\n * @param {number} percent - The percentage to calculate.\r\n * @param {number} previous - The previous value.\r\n * @param {number} next - The next value.\r\n * @returns {number} - The calculated percentage change.\r\n */\r\nexport function getPercentage(percent, previous, next) {\r\n    var full = next - previous;\r\n    return Math.round((previous + (full * percent)));\r\n}\r\n/**\r\n * Gets the text anchor based on the specified alignment and Right-to-Left setting.\r\n *\r\n * @param {Alignment} alignment - The alignment of the text.\r\n * @param {boolean} enableRtl - Specifies whether Right-to-Left is enabled.\r\n * @returns {string} - The text anchor value.\r\n */\r\nexport function getTextAnchor(alignment, enableRtl) {\r\n    switch (alignment) {\r\n        case 'Near':\r\n            return enableRtl ? 'end' : 'start';\r\n        case 'Far':\r\n            return enableRtl ? 'start' : 'end';\r\n        default:\r\n            return 'middle';\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}