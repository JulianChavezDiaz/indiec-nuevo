{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { withInBounds, PointData, getValueXByPoint, getValueYByPoint, sort } from '../../common/utils/helper';\nimport { Rect } from '@syncfusion/ej2-svg-base';\n/**\r\n * To get the data on mouse move.\r\n *\r\n * @private\r\n */\nvar ChartData = /** @class */function () {\n  /**\r\n   * Constructor for the data.\r\n   *\r\n   * @private\r\n   */\n  function ChartData(chart) {\n    /** @private */\n    this.currentPoints = [];\n    /** @private */\n    this.previousPoints = [];\n    this.insideRegion = false;\n    this.commonXvalues = [];\n    this.chart = chart;\n    this.lierIndex = 0;\n  }\n  /**\r\n   * Method to get the Data.\r\n   *\r\n   * @private\r\n   */\n  ChartData.prototype.getData = function () {\n    var chart = this.chart;\n    var point = null;\n    var series = null;\n    var width;\n    var height;\n    var mouseX;\n    var mouseY;\n    for (var len = chart.visibleSeries.length, i = len - 1; i >= 0; i--) {\n      series = chart.visibleSeries[i];\n      width = series.type === 'Scatter' || series.drawType === 'Scatter' || series.marker.visible ? (series.marker.height + 5) / 2 : 0;\n      height = series.type === 'Scatter' || series.drawType === 'Scatter' || series.marker.visible ? (series.marker.width + 5) / 2 : 0;\n      mouseX = chart.mouseX;\n      mouseY = chart.mouseY;\n      if (series.dragSettings.enable && series.isRectSeries) {\n        if (!(series.type === 'Bar' && chart.isTransposed) && (chart.isTransposed || series.type === 'Bar')) {\n          var markerWidth = series.marker.width / 2;\n          mouseX = series.yAxis.isAxisInverse ? mouseX + markerWidth : mouseX - markerWidth;\n        } else {\n          var markerHeight = series.marker.height / 2;\n          mouseY = series.yAxis.isAxisInverse ? mouseY - markerHeight : mouseY + markerHeight;\n        }\n      }\n      if (series.visible && withInBounds(mouseX, mouseY, series.clipRect, width, height)) {\n        point = this.getRectPoint(series, series.clipRect, mouseX, mouseY);\n      }\n      if (point) {\n        return new PointData(point, series);\n      }\n    }\n    return new PointData(point, series);\n  };\n  ChartData.prototype.isSelected = function (chart) {\n    return (chart.selectionMode.indexOf('Drag') > -1 || chart.selectionMode.indexOf('Lasso') > -1) && chart.selectionModule && chart.selectionModule.rectPoints !== null;\n  };\n  ChartData.prototype.getRectPoint = function (series, rect, x, y) {\n    var chart = this.chart;\n    var fromCenterX;\n    var fromCenterY;\n    var clickAngle;\n    var arcAngle = 0;\n    var startAngle;\n    var endAngle;\n    var distanceFromCenter;\n    if (chart.isScrolling) {\n      return null;\n    }\n    for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n      var point = _a[_i];\n      if (!point.regionData) {\n        if (!point.regions || !point.regions.length) {\n          continue;\n        }\n      }\n      if (point.regionData && this.chart.chartAreaType === 'PolarRadar' && series.drawType.indexOf('Column') > -1) {\n        fromCenterX = x - (series.clipRect.width / 2 + series.clipRect.x);\n        fromCenterY = y - (series.clipRect.height / 2 + series.clipRect.y);\n        arcAngle = 2 * Math.PI * (point.regionData.currentXPosition < 0 ? 1 + point.regionData.currentXPosition : point.regionData.currentXPosition);\n        clickAngle = (Math.atan2(fromCenterY, fromCenterX) + 0.5 * Math.PI - arcAngle) % (2 * Math.PI);\n        clickAngle = clickAngle < 0 ? 2 * Math.PI + clickAngle : clickAngle;\n        clickAngle = clickAngle + 2 * Math.PI * series.chart.primaryXAxis.startAngle;\n        startAngle = point.regionData.startAngle;\n        startAngle -= arcAngle;\n        startAngle = startAngle < 0 ? 2 * Math.PI + startAngle : startAngle;\n        endAngle = point.regionData.endAngle;\n        endAngle -= arcAngle;\n        endAngle = endAngle < 0 ? 2 * Math.PI + endAngle : endAngle;\n        distanceFromCenter = Math.sqrt(Math.pow(Math.abs(fromCenterX), 2) + Math.pow(Math.abs(fromCenterY), 2));\n        if (clickAngle >= startAngle && clickAngle <= endAngle && (distanceFromCenter >= point.regionData.innerRadius && distanceFromCenter <= point.regionData.radius || distanceFromCenter <= point.regionData.innerRadius && distanceFromCenter >= point.regionData.radius) && distanceFromCenter <= series.chart.radius) {\n          return point;\n        }\n      }\n      if (series.dragSettings.enable && series.isRectSeries || series.isRectSeries && series.marker.visible && this.chart.chartAreaType !== 'PolarRadar') {\n        if (this.isPointInThresholdRegion(x, y, point, rect, series)) {\n          this.insideRegion = true;\n          return point;\n        }\n      }\n      if (!this.insideRegion && this.checkRegionContainsPoint(point.regions, rect, x, y)) {\n        return point;\n      } else if (this.insideRegion && this.checkRegionContainsPoint(point.regions, rect, x, y)) {\n        return point;\n      }\n    }\n    return null;\n  };\n  /**\r\n   * Checks if the given point is contained within any of the regions defined by the array of rectangles.\r\n   *\r\n   * @param {Rect[]} regionRect - The array of rectangles defining the regions.\r\n   * @param {Rect} rect - The rectangle to check against the regions.\r\n   * @param {number} x - The x-coordinate of the point.\r\n   * @param {number} y - The y-coordinate of the point.\r\n   * @returns {boolean} - True if the point is contained within any of the regions, otherwise false.\r\n   */\n  ChartData.prototype.checkRegionContainsPoint = function (regionRect, rect, x, y) {\n    var _this = this;\n    return regionRect.some(function (region, index) {\n      _this.lierIndex = index;\n      return withInBounds(x, y, new Rect((_this.chart.chartAreaType === 'Cartesian' ? rect.x : 0) + region.x, (_this.chart.chartAreaType === 'Cartesian' ? rect.y : 0) + region.y, region.width, region.height));\n    });\n  };\n  /**\r\n   * Checks if the given point is within the threshold region of a data point.\r\n   *\r\n   * @param {number} x - The x-coordinate of the point to check.\r\n   * @param {number} y - The y-coordinate of the point to check.\r\n   * @param {Points} point - The data point.\r\n   * @param {Rect} rect - The rectangle representing the threshold region.\r\n   * @param {Series} series - The series to which the data point belongs.\r\n   * @returns {boolean} - True if the point is within the threshold region, otherwise false.\r\n   */\n  ChartData.prototype.isPointInThresholdRegion = function (x, y, point, rect, series) {\n    var _this = this;\n    var isBar = series.type === 'Bar';\n    var isInversed = series.yAxis.isAxisInverse;\n    var isTransposed = series.chart.isTransposed;\n    var heightValue = 10;\n    var yValue = 0;\n    var xValue = 0;\n    var width;\n    var height = width = 2 * heightValue;\n    if (isInversed && isTransposed) {\n      if (isBar) {\n        yValue = point.regions[0].height - heightValue;\n        width = point.regions[0].width;\n      } else {\n        xValue = -heightValue;\n        height = point.regions[0].height;\n      }\n    } else if (isInversed || point.yValue < 0) {\n      if (isBar) {\n        xValue = -heightValue;\n        height = point.regions[0].height;\n      } else {\n        yValue = point.regions[0].height - heightValue;\n        width = point.regions[0].width;\n      }\n    } else if (isTransposed) {\n      if (isBar) {\n        yValue = -heightValue;\n        width = point.regions[0].width;\n      } else {\n        xValue = point.regions[0].width - heightValue;\n        height = point.regions[0].height;\n      }\n    } else {\n      if (isBar) {\n        xValue = point.regions[0].width - heightValue;\n        height = point.regions[0].height;\n      } else {\n        yValue = -heightValue;\n        width = point.regions[0].width;\n      }\n    }\n    return point.regions.some(function (region) {\n      return withInBounds(x, y, new Rect((_this.chart.chartAreaType === 'Cartesian' ? rect.x : 0) + region.x + xValue, (_this.chart.chartAreaType === 'Cartesian' ? rect.y : 0) + region.y + yValue, width, height));\n    });\n  };\n  /**\r\n   * Gets the index of the closest data point to the given value in the series.\r\n   *\r\n   * @param {Series} series - The series.\r\n   * @param {number} value - The value to which the closest data point is sought.\r\n   * @param {number[]} [xvalues] - The x-values of the data points.\r\n   * @returns {number} - The index of the closest data point.\r\n   */\n  ChartData.prototype.getClosest = function (series, value, xvalues) {\n    var closest;\n    var data;\n    var xData = xvalues ? xvalues : series.xData;\n    var xLength = xData.length;\n    var leftSideNearest = 0.5;\n    var rightSideNearest = 0.5;\n    if (series.xAxis.valueType === 'DateTime' && series.points.length === 1) {\n      leftSideNearest = series.xAxis.visibleRange.min;\n      rightSideNearest = series.xAxis.visibleRange.max;\n      for (var index = 0; index < series.chart.visibleSeries.length; index++) {\n        var visibleSeries = series.chart.visibleSeries[index];\n        if (visibleSeries.xMin >= leftSideNearest && visibleSeries.xMin < series.xMin) {\n          leftSideNearest = visibleSeries.xMin + 0.1;\n        }\n        if (visibleSeries.xMax <= rightSideNearest && visibleSeries.xMax > series.xMax) {\n          rightSideNearest = visibleSeries.xMax - 0.1;\n        }\n        if (visibleSeries.points.length > 1) {\n          if (visibleSeries.xMax >= leftSideNearest && visibleSeries.xMax < series.xMin) {\n            leftSideNearest = visibleSeries.xMax + 0.1;\n          }\n          if (visibleSeries.xMin <= rightSideNearest && visibleSeries.xMin > series.xMax) {\n            rightSideNearest = visibleSeries.xMin - 0.1;\n          }\n        }\n      }\n      if (leftSideNearest !== series.xAxis.visibleRange.min) {\n        leftSideNearest = Math.abs(series.xMin - leftSideNearest) / 2;\n      }\n      if (rightSideNearest !== series.xAxis.visibleRange.max) {\n        rightSideNearest = Math.abs(series.xMax - rightSideNearest) / 2;\n      }\n    }\n    if (value >= series.xMin - leftSideNearest && value <= series.xMax + rightSideNearest) {\n      for (var i = 0; i < xLength; i++) {\n        data = xData[i];\n        if (closest == null || Math.abs(data - value) < Math.abs(closest - value)) {\n          closest = data;\n        }\n      }\n    }\n    var isDataExist = series.xData.indexOf(closest) !== -1;\n    if (isDataExist) {\n      return closest;\n    } else {\n      return null;\n    }\n  };\n  ChartData.prototype.binarySearch = function (target, list) {\n    var first = 0;\n    var last = list.length;\n    var position = -1;\n    var found = false;\n    var middle;\n    while (found === false && first <= last) {\n      middle = Math.floor((first + last) / 2);\n      if (list[middle].xValue === target) {\n        found = true;\n        position = middle;\n      } else if (list[middle].xValue > target) {\n        last = middle - 1;\n      } else {\n        first = middle + 1;\n      }\n    }\n    return position !== -1 ? list[position] : null;\n  };\n  ChartData.prototype.getClosestX = function (chart, series, xvalues) {\n    var value;\n    var rect = series.clipRect;\n    if (chart.mouseX <= rect.x + rect.width && chart.mouseX >= rect.x) {\n      if (!chart.requireInvertedAxis) {\n        value = getValueXByPoint(chart.mouseX - rect.x, rect.width, series.xAxis);\n      } else {\n        value = getValueYByPoint(chart.mouseY - rect.y, rect.height, series.xAxis);\n      }\n    }\n    var closest = this.getClosest(series, value, xvalues);\n    var point = (closest || closest === 0) && series.points.length > 0 ? this.binarySearch(closest, sort(series.points, ['xValue'])) : null;\n    if (point && point.visible) {\n      if (!(this.chart.chartAreaType === 'Cartesian' && (series.category === 'Indicator' && series.name === 'Histogram' || point.symbolLocations && point.symbolLocations.length > 0 && point.symbolLocations[0].x >= 0 && point.symbolLocations[0].x <= rect.width))) {\n        return null;\n      }\n      return new PointData(point, series);\n    }\n    return null;\n  };\n  /**\r\n   * Merges the x-values of the data points from multiple series into a single array.\r\n   *\r\n   * @param {Series[]} visibleSeries - The array of visible series.\r\n   * @returns {number[]} - The merged array of x-values.\r\n   */\n  ChartData.prototype.mergeXvalues = function (visibleSeries) {\n    if (visibleSeries.length && (!this.commonXvalues.length || this.commonXvalues.length !== visibleSeries[0].xData.length)) {\n      this.commonXvalues = visibleSeries[0].xData;\n      for (var index = 1; index < visibleSeries.length; index++) {\n        this.commonXvalues = this.getDistinctValues(this.commonXvalues, visibleSeries[index].xData);\n      }\n    }\n    return this.commonXvalues;\n  };\n  ChartData.prototype.commonXValue = function (visibleSeries) {\n    var commonXValues = [];\n    for (var j = 0; j < visibleSeries.length; j++) {\n      for (var i = 0; visibleSeries[j].points && i < visibleSeries[j].points.length; i++) {\n        var point = visibleSeries[j].points[i];\n        if (point && (point.index === 0 || point.index === visibleSeries[j].points.length - 1 || point.symbolLocations && point.symbolLocations.length > 0)) {\n          commonXValues.push(point.xValue);\n        }\n      }\n    }\n    return commonXValues;\n  };\n  ChartData.prototype.getDistinctValues = function (first, second) {\n    if (first === void 0) {\n      first = [];\n    }\n    if (second === void 0) {\n      second = [];\n    }\n    var intial = {};\n    var result = [];\n    var index;\n    for (index = 0; index < first.length; index++) {\n      var temp = first[index];\n      if (!intial[temp]) {\n        intial[temp] = true;\n        result.push(temp);\n      }\n    }\n    for (index = 0; index < second.length; index++) {\n      var temp = second[index];\n      if (!intial[temp]) {\n        intial[temp] = true;\n        result.push(temp);\n      }\n    }\n    return result;\n  };\n  return ChartData;\n}();\nexport { ChartData };","map":{"version":3,"names":["withInBounds","PointData","getValueXByPoint","getValueYByPoint","sort","Rect","ChartData","chart","currentPoints","previousPoints","insideRegion","commonXvalues","lierIndex","prototype","getData","point","series","width","height","mouseX","mouseY","len","visibleSeries","length","i","type","drawType","marker","visible","dragSettings","enable","isRectSeries","isTransposed","markerWidth","yAxis","isAxisInverse","markerHeight","clipRect","getRectPoint","isSelected","selectionMode","indexOf","selectionModule","rectPoints","rect","x","y","fromCenterX","fromCenterY","clickAngle","arcAngle","startAngle","endAngle","distanceFromCenter","isScrolling","_i","_a","points","regionData","regions","chartAreaType","Math","PI","currentXPosition","atan2","primaryXAxis","sqrt","pow","abs","innerRadius","radius","isPointInThresholdRegion","checkRegionContainsPoint","regionRect","_this","some","region","index","isBar","isInversed","heightValue","yValue","xValue","getClosest","value","xvalues","closest","data","xData","xLength","leftSideNearest","rightSideNearest","xAxis","valueType","visibleRange","min","max","xMin","xMax","isDataExist","binarySearch","target","list","first","last","position","found","middle","floor","getClosestX","requireInvertedAxis","category","name","symbolLocations","mergeXvalues","getDistinctValues","commonXValue","commonXValues","j","push","second","intial","result","temp"],"sources":["C:/Users/wiliam/Desktop/indiec-nuevo/fronted-vue/node_modules/@syncfusion/ej2-charts/src/chart/utils/get-data.js"],"sourcesContent":["import { withInBounds, PointData, getValueXByPoint, getValueYByPoint, sort } from '../../common/utils/helper';\r\nimport { Rect } from '@syncfusion/ej2-svg-base';\r\n/**\r\n * To get the data on mouse move.\r\n *\r\n * @private\r\n */\r\nvar ChartData = /** @class */ (function () {\r\n    /**\r\n     * Constructor for the data.\r\n     *\r\n     * @private\r\n     */\r\n    function ChartData(chart) {\r\n        /** @private */\r\n        this.currentPoints = [];\r\n        /** @private */\r\n        this.previousPoints = [];\r\n        this.insideRegion = false;\r\n        this.commonXvalues = [];\r\n        this.chart = chart;\r\n        this.lierIndex = 0;\r\n    }\r\n    /**\r\n     * Method to get the Data.\r\n     *\r\n     * @private\r\n     */\r\n    ChartData.prototype.getData = function () {\r\n        var chart = this.chart;\r\n        var point = null;\r\n        var series = null;\r\n        var width;\r\n        var height;\r\n        var mouseX;\r\n        var mouseY;\r\n        for (var len = chart.visibleSeries.length, i = len - 1; i >= 0; i--) {\r\n            series = chart.visibleSeries[i];\r\n            width = (series.type === 'Scatter' || series.drawType === 'Scatter' || (series.marker.visible))\r\n                ? (series.marker.height + 5) / 2 : 0;\r\n            height = (series.type === 'Scatter' || series.drawType === 'Scatter' || (series.marker.visible))\r\n                ? (series.marker.width + 5) / 2 : 0;\r\n            mouseX = chart.mouseX;\r\n            mouseY = chart.mouseY;\r\n            if (series.dragSettings.enable && series.isRectSeries) {\r\n                if (!(series.type === 'Bar' && chart.isTransposed) && (chart.isTransposed || series.type === 'Bar')) {\r\n                    var markerWidth = series.marker.width / 2;\r\n                    mouseX = series.yAxis.isAxisInverse ? mouseX + markerWidth : mouseX - markerWidth;\r\n                }\r\n                else {\r\n                    var markerHeight = series.marker.height / 2;\r\n                    mouseY = series.yAxis.isAxisInverse ? mouseY - markerHeight : mouseY + markerHeight;\r\n                }\r\n            }\r\n            if (series.visible && withInBounds(mouseX, mouseY, series.clipRect, width, height)) {\r\n                point = this.getRectPoint(series, series.clipRect, mouseX, mouseY);\r\n            }\r\n            if (point) {\r\n                return new PointData(point, series);\r\n            }\r\n        }\r\n        return new PointData(point, series);\r\n    };\r\n    ChartData.prototype.isSelected = function (chart) {\r\n        return ((chart.selectionMode.indexOf('Drag') > -1 || chart.selectionMode.indexOf('Lasso') > -1) && chart.selectionModule &&\r\n            chart.selectionModule.rectPoints !== null);\r\n    };\r\n    ChartData.prototype.getRectPoint = function (series, rect, x, y) {\r\n        var chart = this.chart;\r\n        var fromCenterX;\r\n        var fromCenterY;\r\n        var clickAngle;\r\n        var arcAngle = 0;\r\n        var startAngle;\r\n        var endAngle;\r\n        var distanceFromCenter;\r\n        if (chart.isScrolling) {\r\n            return null;\r\n        }\r\n        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\r\n            var point = _a[_i];\r\n            if (!point.regionData) {\r\n                if (!point.regions || !point.regions.length) {\r\n                    continue;\r\n                }\r\n            }\r\n            if (point.regionData && this.chart.chartAreaType === 'PolarRadar' && series.drawType.indexOf('Column') > -1) {\r\n                fromCenterX = x - (series.clipRect.width / 2 + series.clipRect.x);\r\n                fromCenterY = y - (series.clipRect.height / 2 + series.clipRect.y);\r\n                arcAngle = 2 * Math.PI * (point.regionData.currentXPosition < 0 ? 1 + point.regionData.currentXPosition\r\n                    : point.regionData.currentXPosition);\r\n                clickAngle = (Math.atan2(fromCenterY, fromCenterX) + 0.5 * Math.PI - arcAngle) % (2 * Math.PI);\r\n                clickAngle = clickAngle < 0 ? 2 * Math.PI + clickAngle : clickAngle;\r\n                clickAngle = clickAngle + 2 * Math.PI * series.chart.primaryXAxis.startAngle;\r\n                startAngle = point.regionData.startAngle;\r\n                startAngle -= arcAngle;\r\n                startAngle = startAngle < 0 ? 2 * Math.PI + startAngle : startAngle;\r\n                endAngle = point.regionData.endAngle;\r\n                endAngle -= arcAngle;\r\n                endAngle = endAngle < 0 ? 2 * Math.PI + endAngle : endAngle;\r\n                distanceFromCenter = Math.sqrt(Math.pow(Math.abs(fromCenterX), 2) + Math.pow(Math.abs(fromCenterY), 2));\r\n                if (clickAngle >= startAngle && clickAngle <= endAngle &&\r\n                    (((distanceFromCenter >= point.regionData.innerRadius && distanceFromCenter <= point.regionData.radius) ||\r\n                        (distanceFromCenter <= point.regionData.innerRadius && distanceFromCenter >= point.regionData.radius))\r\n                        && distanceFromCenter <= series.chart.radius)) {\r\n                    return point;\r\n                }\r\n            }\r\n            if ((series.dragSettings.enable && series.isRectSeries) || (series.isRectSeries && series.marker.visible && this.chart.chartAreaType !== 'PolarRadar')) {\r\n                if (this.isPointInThresholdRegion(x, y, point, rect, series)) {\r\n                    this.insideRegion = true;\r\n                    return point;\r\n                }\r\n            }\r\n            if (!this.insideRegion && this.checkRegionContainsPoint(point.regions, rect, x, y)) {\r\n                return point;\r\n            }\r\n            else if (this.insideRegion && this.checkRegionContainsPoint(point.regions, rect, x, y)) {\r\n                return point;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Checks if the given point is contained within any of the regions defined by the array of rectangles.\r\n     *\r\n     * @param {Rect[]} regionRect - The array of rectangles defining the regions.\r\n     * @param {Rect} rect - The rectangle to check against the regions.\r\n     * @param {number} x - The x-coordinate of the point.\r\n     * @param {number} y - The y-coordinate of the point.\r\n     * @returns {boolean} - True if the point is contained within any of the regions, otherwise false.\r\n     */\r\n    ChartData.prototype.checkRegionContainsPoint = function (regionRect, rect, x, y) {\r\n        var _this = this;\r\n        return regionRect.some(function (region, index) {\r\n            _this.lierIndex = index;\r\n            return withInBounds(x, y, new Rect((_this.chart.chartAreaType === 'Cartesian' ? rect.x : 0) + region.x, (_this.chart.chartAreaType === 'Cartesian' ? rect.y : 0) + region.y, region.width, region.height));\r\n        });\r\n    };\r\n    /**\r\n     * Checks if the given point is within the threshold region of a data point.\r\n     *\r\n     * @param {number} x - The x-coordinate of the point to check.\r\n     * @param {number} y - The y-coordinate of the point to check.\r\n     * @param {Points} point - The data point.\r\n     * @param {Rect} rect - The rectangle representing the threshold region.\r\n     * @param {Series} series - The series to which the data point belongs.\r\n     * @returns {boolean} - True if the point is within the threshold region, otherwise false.\r\n     */\r\n    ChartData.prototype.isPointInThresholdRegion = function (x, y, point, rect, series) {\r\n        var _this = this;\r\n        var isBar = series.type === 'Bar';\r\n        var isInversed = series.yAxis.isAxisInverse;\r\n        var isTransposed = series.chart.isTransposed;\r\n        var heightValue = 10;\r\n        var yValue = 0;\r\n        var xValue = 0;\r\n        var width;\r\n        var height = width = 2 * heightValue;\r\n        if (isInversed && isTransposed) {\r\n            if (isBar) {\r\n                yValue = point.regions[0].height - heightValue;\r\n                width = point.regions[0].width;\r\n            }\r\n            else {\r\n                xValue = -heightValue;\r\n                height = point.regions[0].height;\r\n            }\r\n        }\r\n        else if (isInversed || point.yValue < 0) {\r\n            if (isBar) {\r\n                xValue = -heightValue;\r\n                height = point.regions[0].height;\r\n            }\r\n            else {\r\n                yValue = point.regions[0].height - heightValue;\r\n                width = point.regions[0].width;\r\n            }\r\n        }\r\n        else if (isTransposed) {\r\n            if (isBar) {\r\n                yValue = -heightValue;\r\n                width = point.regions[0].width;\r\n            }\r\n            else {\r\n                xValue = point.regions[0].width - heightValue;\r\n                height = point.regions[0].height;\r\n            }\r\n        }\r\n        else {\r\n            if (isBar) {\r\n                xValue = point.regions[0].width - heightValue;\r\n                height = point.regions[0].height;\r\n            }\r\n            else {\r\n                yValue = -heightValue;\r\n                width = point.regions[0].width;\r\n            }\r\n        }\r\n        return point.regions.some(function (region) {\r\n            return withInBounds(x, y, new Rect((_this.chart.chartAreaType === 'Cartesian' ? rect.x : 0) + region.x + xValue, (_this.chart.chartAreaType === 'Cartesian' ? rect.y : 0) + region.y + yValue, width, height));\r\n        });\r\n    };\r\n    /**\r\n     * Gets the index of the closest data point to the given value in the series.\r\n     *\r\n     * @param {Series} series - The series.\r\n     * @param {number} value - The value to which the closest data point is sought.\r\n     * @param {number[]} [xvalues] - The x-values of the data points.\r\n     * @returns {number} - The index of the closest data point.\r\n     */\r\n    ChartData.prototype.getClosest = function (series, value, xvalues) {\r\n        var closest;\r\n        var data;\r\n        var xData = xvalues ? xvalues : series.xData;\r\n        var xLength = xData.length;\r\n        var leftSideNearest = 0.5;\r\n        var rightSideNearest = 0.5;\r\n        if (series.xAxis.valueType === 'DateTime' && series.points.length === 1) {\r\n            leftSideNearest = series.xAxis.visibleRange.min;\r\n            rightSideNearest = series.xAxis.visibleRange.max;\r\n            for (var index = 0; index < series.chart.visibleSeries.length; index++) {\r\n                var visibleSeries = series.chart.visibleSeries[index];\r\n                if (visibleSeries.xMin >= leftSideNearest && visibleSeries.xMin < series.xMin) {\r\n                    leftSideNearest = visibleSeries.xMin + 0.1;\r\n                }\r\n                if (visibleSeries.xMax <= rightSideNearest && visibleSeries.xMax > series.xMax) {\r\n                    rightSideNearest = visibleSeries.xMax - 0.1;\r\n                }\r\n                if (visibleSeries.points.length > 1) {\r\n                    if (visibleSeries.xMax >= leftSideNearest && visibleSeries.xMax < series.xMin) {\r\n                        leftSideNearest = visibleSeries.xMax + 0.1;\r\n                    }\r\n                    if (visibleSeries.xMin <= rightSideNearest && visibleSeries.xMin > series.xMax) {\r\n                        rightSideNearest = visibleSeries.xMin - 0.1;\r\n                    }\r\n                }\r\n            }\r\n            if (leftSideNearest !== series.xAxis.visibleRange.min) {\r\n                leftSideNearest = Math.abs(series.xMin - leftSideNearest) / 2;\r\n            }\r\n            if (rightSideNearest !== series.xAxis.visibleRange.max) {\r\n                rightSideNearest = Math.abs(series.xMax - rightSideNearest) / 2;\r\n            }\r\n        }\r\n        if (value >= series.xMin - leftSideNearest && value <= series.xMax + rightSideNearest) {\r\n            for (var i = 0; i < xLength; i++) {\r\n                data = xData[i];\r\n                if (closest == null || Math.abs(data - value) < Math.abs(closest - value)) {\r\n                    closest = data;\r\n                }\r\n            }\r\n        }\r\n        var isDataExist = series.xData.indexOf(closest) !== -1;\r\n        if (isDataExist) {\r\n            return closest;\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    };\r\n    ChartData.prototype.binarySearch = function (target, list) {\r\n        var first = 0;\r\n        var last = list.length;\r\n        var position = -1;\r\n        var found = false;\r\n        var middle;\r\n        while (found === false && first <= last) {\r\n            middle = Math.floor((first + last) / 2);\r\n            if (list[middle].xValue === target) {\r\n                found = true;\r\n                position = middle;\r\n            }\r\n            else if (list[middle].xValue > target) {\r\n                last = middle - 1;\r\n            }\r\n            else {\r\n                first = middle + 1;\r\n            }\r\n        }\r\n        return position !== -1 ? list[position] : null;\r\n    };\r\n    ChartData.prototype.getClosestX = function (chart, series, xvalues) {\r\n        var value;\r\n        var rect = series.clipRect;\r\n        if (chart.mouseX <= rect.x + rect.width && chart.mouseX >= rect.x) {\r\n            if (!chart.requireInvertedAxis) {\r\n                value = getValueXByPoint(chart.mouseX - rect.x, rect.width, series.xAxis);\r\n            }\r\n            else {\r\n                value = getValueYByPoint(chart.mouseY - rect.y, rect.height, series.xAxis);\r\n            }\r\n        }\r\n        var closest = this.getClosest(series, value, xvalues);\r\n        var point = ((closest || closest === 0) && series.points.length > 0) ? this.binarySearch(closest, sort(series.points, ['xValue'])) : null;\r\n        if (point && point.visible) {\r\n            if (!(this.chart.chartAreaType === 'Cartesian' && ((series.category === 'Indicator' && series.name === 'Histogram') ||\r\n                (point.symbolLocations && point.symbolLocations.length > 0 && point.symbolLocations[0].x >= 0 &&\r\n                    point.symbolLocations[0].x <= rect.width)))) {\r\n                return null;\r\n            }\r\n            return new PointData(point, series);\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Merges the x-values of the data points from multiple series into a single array.\r\n     *\r\n     * @param {Series[]} visibleSeries - The array of visible series.\r\n     * @returns {number[]} - The merged array of x-values.\r\n     */\r\n    ChartData.prototype.mergeXvalues = function (visibleSeries) {\r\n        if (visibleSeries.length && (!this.commonXvalues.length || (this.commonXvalues.length !== visibleSeries[0].xData.length))) {\r\n            this.commonXvalues = visibleSeries[0].xData;\r\n            for (var index = 1; index < visibleSeries.length; index++) {\r\n                this.commonXvalues = this.getDistinctValues(this.commonXvalues, visibleSeries[index].xData);\r\n            }\r\n        }\r\n        return this.commonXvalues;\r\n    };\r\n    ChartData.prototype.commonXValue = function (visibleSeries) {\r\n        var commonXValues = [];\r\n        for (var j = 0; j < visibleSeries.length; j++) {\r\n            for (var i = 0; (visibleSeries[j].points && i < visibleSeries[j].points.length); i++) {\r\n                var point = visibleSeries[j].points[i];\r\n                if (point && (point.index === 0 || point.index === visibleSeries[j].points.length - 1 ||\r\n                    (point.symbolLocations && point.symbolLocations.length > 0))) {\r\n                    commonXValues.push(point.xValue);\r\n                }\r\n            }\r\n        }\r\n        return commonXValues;\r\n    };\r\n    ChartData.prototype.getDistinctValues = function (first, second) {\r\n        if (first === void 0) { first = []; }\r\n        if (second === void 0) { second = []; }\r\n        var intial = {};\r\n        var result = [];\r\n        var index;\r\n        for (index = 0; index < first.length; index++) {\r\n            var temp = first[index];\r\n            if (!intial[temp]) {\r\n                intial[temp] = true;\r\n                result.push(temp);\r\n            }\r\n        }\r\n        for (index = 0; index < second.length; index++) {\r\n            var temp = second[index];\r\n            if (!intial[temp]) {\r\n                intial[temp] = true;\r\n                result.push(temp);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n    return ChartData;\r\n}());\r\nexport { ChartData };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}