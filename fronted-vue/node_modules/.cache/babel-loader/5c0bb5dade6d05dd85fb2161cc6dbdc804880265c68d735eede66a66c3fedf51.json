{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\r\n * AccumulationChart DataLabel module file\r\n */\nimport { extend, createElement, getValue, isNullOrUndefined, animationMode } from '@syncfusion/ej2-base';\nimport { Rect, Size, PathOption, measureText, TextOption } from '@syncfusion/ej2-svg-base';\nimport { ChartLocation, degreeToLocation, isOverlap, stringToNumber, getAngle, appendChildElement } from '../../common/utils/helper';\nimport { textTrim, subtractThickness, Thickness, getElement } from '../../common/utils/helper';\nimport { removeElement, RectOption, textElement, showTooltip } from '../../common/utils/helper';\nimport { colorNameToHex, convertHexToColor, containsRect, textWrap, CircleOption } from '../../common/utils/helper';\nimport { getSeriesFromIndex } from '../model/acc-base';\nimport { textRender } from '../../common/model/constants';\nimport { getFontStyle, createTemplate, measureElementRect, templateAnimate } from '../../common/utils/helper';\nimport { AccumulationBase } from './accumulation-base';\n/**\r\n * AccumulationDataLabel module used to render `dataLabel`.\r\n */\nvar AccumulationDataLabel = /** @class */function (_super) {\n  __extends(AccumulationDataLabel, _super);\n  function AccumulationDataLabel(accumulation) {\n    var _this = _super.call(this, accumulation) || this;\n    _this.rightSideRenderingPoints = [];\n    _this.leftSideRenderingPoints = [];\n    _this.id = accumulation.element.id + '_datalabel_Series_';\n    return _this;\n  }\n  /**\r\n   * Method to get datalabel text location.\r\n   *\r\n   * @private\r\n   * @param {AccPoints} point - The data point for which to calculate the label text location.\r\n   * @param {AccumulationDataLabelSettingsModel} dataLabel - The data label settings for the series.\r\n   * @param {Size} textSize - The size of the text to be displayed.\r\n   * @param {AccPoints[]} points - The array of data points in the series.\r\n   * @returns {void}\r\n   */\n  AccumulationDataLabel.prototype.getDataLabelPosition = function (point, dataLabel, textSize, points) {\n    var radius = this.isCircular() ? !this.isVariousRadius() ? this.accumulation.pieSeriesModule.labelRadius : this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], point) : this.getLabelDistance(point, dataLabel);\n    //let radius: number = this.isCircular() ? this.labelRadius : this.getLabelDistance(point, dataLabel);\n    if (this.accumulation.title) {\n      var titleSize = measureText(this.accumulation.title, this.accumulation.titleStyle, this.accumulation.themeStyle.datalabelFont);\n      this.titleRect = new Rect(this.accumulation.availableSize.width / 2 - titleSize.width / 2, this.accumulation.margin.top, titleSize.width, titleSize.height);\n    }\n    this.getLabelRegion(point, dataLabel.position, textSize, radius, this.marginValue);\n    point.labelAngle = point.midAngle;\n    point.labelPosition = dataLabel.position;\n    if (this.accumulation.enableSmartLabels) {\n      this.getSmartLabel(point, dataLabel, textSize, points);\n    }\n  };\n  /**\r\n   * Method to get datalabel bound.\r\n   */\n  AccumulationDataLabel.prototype.getLabelRegion = function (point, position, textSize, labelRadius, margin, endAngle) {\n    if (endAngle === void 0) {\n      endAngle = 0;\n    }\n    var labelAngle = endAngle || point.midAngle;\n    var space = 20;\n    var location = degreeToLocation(labelAngle, labelRadius, this.isCircular() ? this.center : this.getLabelLocation(point, position));\n    location.y = position === 'Inside' ? location.y - textSize.height / 2 : location.y;\n    location.x = position === 'Inside' ? location.x - textSize.width / 2 : location.x;\n    point.labelRegion = new Rect(location.x, location.y, textSize.width + margin * 2, textSize.height + margin * 2);\n    if (position === 'Outside') {\n      point.labelRegion.y -= point.labelRegion.height / 2;\n      if (labelAngle >= 90 && labelAngle <= 270) {\n        point.labelRegion.x -= point.labelRegion.width + space;\n      } else {\n        point.labelRegion.x += space;\n      }\n    }\n  };\n  /**\r\n   * Method to get data label collection.\r\n   *\r\n   * @param {AccPoints} point - The data point for which to calculate the label collection.\r\n   * @param {AccumulationDataLabelSettingsModel} dataLabel - The data label settings for the series.\r\n   * @returns {void}\r\n   */\n  AccumulationDataLabel.prototype.calculateLabelCollection = function (point, dataLabel) {\n    if (point.argsData.template !== null) {\n      return null;\n    }\n    var position = point.labelPosition || dataLabel.position;\n    var labelRadius = this.isCircular() ? !this.isVariousRadius() ? this.accumulation.pieSeriesModule.labelRadius : this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], point) : this.getLabelDistance(point, dataLabel);\n    var radius = !this.isVariousRadius() ? this.accumulation.pieSeriesModule.radius - this.accumulation.pieSeriesModule.innerRadius : this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], point);\n    var location = degreeToLocation(point.midAngle, labelRadius, this.isCircular() ? this.center : this.getLabelLocation(point, position));\n    var padding = 20;\n    var maxWidth = dataLabel.maxWidth;\n    if (!maxWidth) {\n      if (position === 'Outside') {\n        maxWidth = this.isCircular() ? location.x >= this.center.x ? this.areaRect.x + this.areaRect.width - location.x : location.x - this.areaRect.x : location.x >= point.region.x ? this.areaRect.x + this.areaRect.width - location.x : location.x - this.areaRect.x;\n      } else {\n        maxWidth = this.isCircular() ? radius - padding : point.region.width;\n      }\n    }\n    if (point.label.indexOf('<br>') !== -1) {\n      point.labelCollection = point.label.split('<br>');\n    } else if (dataLabel.textWrap === 'Normal' && dataLabel.textOverflow === 'Ellipsis') {\n      point.labelCollection[0] = textTrim(maxWidth, point.label, point.argsData.font, this.accumulation.enableRtl, this.accumulation.themeStyle.datalabelFont);\n    } else if (dataLabel.textWrap === 'Wrap' || dataLabel.textWrap === 'AnyWhere') {\n      point.labelCollection = textWrap(point.label, maxWidth, point.argsData.font, this.accumulation.enableRtl, dataLabel.textWrap === 'AnyWhere', dataLabel.textOverflow === 'Clip', this.accumulation.themeStyle.datalabelFont);\n    } else {\n      point.labelCollection[0] = point.label;\n    }\n  };\n  /**\r\n   * To calculate label collection text size.\r\n   *\r\n   * @param {string[]} labelCollection - The collection of label texts.\r\n   * @param {AccumulationDataLabelSettingsModel} dataLabel - The data label settings for the series.\r\n   * @returns {Size} - The size of the label text collection.\r\n   */\n  AccumulationDataLabel.prototype.getTextSize = function (labelCollection, dataLabel) {\n    var height = 0;\n    var font = dataLabel.font;\n    var width = dataLabel.maxWidth ? dataLabel.maxWidth : 0;\n    var textSize;\n    for (var i = 0; i < labelCollection.length; i++) {\n      textSize = measureText(labelCollection[i], font, this.accumulation.themeStyle.datalabelFont);\n      width = Math.max(textSize.width, width);\n      height += textSize.height;\n    }\n    if (dataLabel.textOverflow === 'Clip' && dataLabel.textWrap !== 'Normal' && dataLabel.maxWidth) {\n      width = dataLabel.maxWidth;\n    }\n    return new Size(width, height);\n  };\n  /**\r\n   * Method to get datalabel smart position.\r\n   *\r\n   * @param {AccPoints} point - The data point for which to calculate the label smart position.\r\n   * @param {AccumulationDataLabelSettingsModel} dataLabel - The data label settings for the series.\r\n   * @param {Size} textSize - The size of the text.\r\n   * @param {AccPoints[]} points - The collection of data points.\r\n   * @returns {void}\r\n   */\n  AccumulationDataLabel.prototype.getSmartLabel = function (point, dataLabel, textSize, points) {\n    var circular = this.isCircular();\n    var labelRadius = circular ? this.radius : this.getLabelDistance(point, dataLabel);\n    var connectorLength = circular ? dataLabel.connectorStyle.length || '4%' : '0px';\n    labelRadius += stringToNumber(connectorLength, labelRadius);\n    var previousPoint = this.findPreviousPoint(points, point.index, point.labelPosition);\n    if (dataLabel.position === 'Inside') {\n      // `4` is padding adding to height and width of label region.\n      point.labelRegion.height -= 4;\n      point.labelRegion.width -= 4;\n      if (previousPoint && previousPoint.labelRegion && !dataLabel.enableRotation && (isOverlap(point.labelRegion, previousPoint.labelRegion) || this.isOverlapping(point, points)) || !circular && !containsRect(point.region, point.labelRegion)) {\n        point.labelPosition = 'Outside';\n        if (!circular) {\n          labelRadius = this.getLabelDistance(point, dataLabel);\n        }\n        this.calculateLabelCollection(point, dataLabel);\n        textSize = this.getTextSize(point.labelCollection, dataLabel);\n        textSize.height += 4; // 4 for calculation with padding for smart label shape\n        textSize.width += 4;\n        this.getLabelRegion(point, point.labelPosition, textSize, labelRadius, this.marginValue);\n        previousPoint = this.findPreviousPoint(points, point.index, point.labelPosition);\n        if (previousPoint && (isOverlap(point.labelRegion, previousPoint.labelRegion) || this.isConnectorLineOverlapping(point, previousPoint))) {\n          this.setOuterSmartLabel(previousPoint, point, dataLabel.border.width, labelRadius, textSize, this.marginValue);\n        }\n      }\n    } else {\n      if (previousPoint && previousPoint.labelRegion && (isOverlap(point.labelRegion, previousPoint.labelRegion) || this.isOverlapping(point, points) || this.isConnectorLineOverlapping(point, previousPoint))) {\n        this.setOuterSmartLabel(previousPoint, point, dataLabel.border.width, labelRadius, textSize, this.marginValue);\n      }\n    }\n    if (this.isOverlapping(point, points) && (this.accumulation.type === 'Pyramid' || this.accumulation.type === 'Funnel')) {\n      var position = 'OutsideLeft';\n      var space = 20;\n      var labelAngle = point.midAngle || 0;\n      var labelRadius_1 = circular ? this.radius : this.getLabelDistance(point, dataLabel);\n      var location_1 = degreeToLocation(labelAngle, -labelRadius_1, this.isCircular() ? this.center : this.getLabelLocation(point, position));\n      point.labelRegion = new Rect(location_1.x, location_1.y, textSize.width + this.marginValue * 2, textSize.height + this.marginValue * 2);\n      point.labelRegion.y -= point.labelRegion.height / 2;\n      point.labelRegion.x = point.labelRegion.x - space - point.labelRegion.width;\n      if (previousPoint && previousPoint.labelRegion && (isOverlap(point.labelRegion, previousPoint.labelRegion) || this.isOverlapping(point, points) || this.isConnectorLineOverlapping(point, previousPoint))) {\n        this.setOuterSmartLabel(previousPoint, point, dataLabel.border.width, labelRadius_1, textSize, this.marginValue);\n      }\n    }\n  };\n  /**\r\n   * To find trimmed datalabel tooltip needed.\r\n   *\r\n   * @param {Event} e - The move event.\r\n   * @param {number} x - The x-coordinate.\r\n   * @param {number} y - The y-coordinate.\r\n   * @param {boolean} isTouch - Indicates if the interaction is touch-based.\r\n   * @returns {void}\r\n   * @private\r\n   */\n  AccumulationDataLabel.prototype.move = function (e, x, y, isTouch) {\n    var _this = this;\n    if (e.target.textContent.indexOf('...') > -1) {\n      var targetId = e.target.id.split(this.id);\n      if (targetId.length === 2) {\n        var seriesIndex = parseInt(targetId[1].split('_text_')[0], 10);\n        var pointIndex = parseInt(targetId[1].split('_text_')[1], 10);\n        if (!isNaN(seriesIndex) && !isNaN(pointIndex)) {\n          if (isTouch) {\n            removeElement(this.accumulation.element.id + '_EJ2_Datalabel_Tooltip');\n          }\n          var point = getSeriesFromIndex(seriesIndex, this.accumulation.visibleSeries).points[pointIndex];\n          showTooltip(point.text || point.y.toString(), x, y, this.areaRect.width, this.accumulation.element.id + '_EJ2_Datalabel_Tooltip', getElement(this.accumulation.element.id + '_Secondary_Element'), null, null, this.accumulation.initialClipRect);\n        }\n      }\n    } else {\n      removeElement(this.accumulation.element.id + '_EJ2_Datalabel_Tooltip');\n    }\n    if (isTouch) {\n      clearTimeout(this.clearTooltip);\n      this.clearTooltip = +setTimeout(function () {\n        removeElement(_this.accumulation.element.id + '_EJ2_Datalabel_Tooltip');\n      }, 1000);\n    }\n  };\n  /**\r\n   * To find previous valid label point.\r\n   *\r\n   * @param {AccPoints[]} points - The array of accumulation points.\r\n   * @param {number} index - The index of the current point.\r\n   * @param {AccumulationLabelPosition} position - The position of the label.\r\n   * @returns {AccPoints} - Find the previous value of accumulation point.\r\n   */\n  AccumulationDataLabel.prototype.findPreviousPoint = function (points, index, position) {\n    var point = points[0];\n    for (var i = index - 1; i >= 0; i--) {\n      point = points[i];\n      if (point.visible && point.labelVisible && point.labelRegion && point.labelPosition === position) {\n        return point;\n      }\n    }\n    return null;\n  };\n  /**\r\n   * To find current point datalabel is overlapping with other points.\r\n   *\r\n   * @param {AccPoints} currentPoint - The current point.\r\n   * @param {AccPoints[]} points - The array of accumulation points.\r\n   * @returns {boolean} - It returns boolean value of overlapping.\r\n   */\n  AccumulationDataLabel.prototype.isOverlapping = function (currentPoint, points) {\n    for (var i = currentPoint.index - 1; i >= 0; i--) {\n      if (points[i].visible && points[i].labelVisible && points[i].labelRegion && currentPoint.labelRegion && currentPoint.labelVisible && isOverlap(currentPoint.labelRegion, points[i].labelRegion)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  /**\r\n   * To get text trimmed while exceeds the accumulation chart area.\r\n   *\r\n   * @param {AccPoints} point - The accumulation point.\r\n   * @param {Rect} rect - The area of the accumulation chart.\r\n   * @param {FontModel} font - The font settings.\r\n   * @param {string} position - The position of the data label.\r\n   * @param {AccumulationDataLabelSettingsModel} dataLabel - The data label settings.\r\n   * @returns {void}\r\n   */\n  AccumulationDataLabel.prototype.textTrimming = function (point, rect, font, position, dataLabel) {\n    if (isOverlap(point.labelRegion, rect)) {\n      var size = point.labelRegion.width;\n      if (position === 'Right') {\n        size = rect.x - point.labelRegion.x;\n      } else if (position === 'Left') {\n        size = point.labelRegion.x - (rect.x + rect.width);\n        if (size < 0) {\n          size += point.labelRegion.width;\n          point.labelRegion.x = rect.x + rect.width;\n        }\n      } else if (position === 'InsideRight') {\n        size = rect.x + rect.width - point.labelRegion.x;\n      } else if (position === 'InsideLeft') {\n        size = point.labelRegion.x + point.labelRegion.width - rect.x;\n        if (size < point.labelRegion.width) {\n          point.labelRegion.x = rect.x;\n        }\n      } else if (this.accumulation.enableSmartLabels) {\n        this.setPointVisibileFalse(point);\n      }\n      if (point.labelVisible && point.labelRegion) {\n        if (point.label.indexOf('<br>') !== -1) {\n          point.labelCollection = point.label.split('<br>');\n        } else if (size < point.labelRegion.width) {\n          if (dataLabel.textWrap === 'Normal' && dataLabel.textOverflow === 'Ellipsis') {\n            point.labelCollection[0] = textTrim(size - this.marginValue * 2, point.label, font, this.accumulation.enableRtl, this.accumulation.themeStyle.datalabelFont);\n          } else if (dataLabel.textWrap === 'Wrap' || dataLabel.textWrap === 'AnyWhere') {\n            point.labelCollection = textWrap(point.label, size - this.marginValue * 2, font, this.accumulation.enableRtl, dataLabel.textWrap === 'AnyWhere', dataLabel.textOverflow === 'Clip', this.accumulation.themeStyle.datalabelFont);\n          }\n          point.labelRegion.width = size;\n        }\n        for (var i = 0; i < point.labelCollection.length; i++) {\n          if (point.labelCollection[i].length === 3 && point.labelCollection[i].indexOf('...') > -1) {\n            this.setPointVisibileFalse(point);\n            break;\n          }\n        }\n      }\n    }\n  };\n  /**\r\n   * To set point label visible and region to disable.\r\n   *\r\n   * @param {AccPoints} point - The accumulation point.\r\n   * @returns {void}\r\n   */\n  AccumulationDataLabel.prototype.setPointVisibileFalse = function (point) {\n    point.labelVisible = false;\n    point.labelRegion = null;\n  };\n  /**\r\n   * To set point label visible to enable.\r\n   *\r\n   * @param {AccPoints} point - The accumulation point.\r\n   * @returns {void}\r\n   */\n  AccumulationDataLabel.prototype.setPointVisibleTrue = function (point) {\n    point.labelVisible = true;\n  };\n  /**\r\n   * To set datalabel angle position for outside labels.\r\n   *\r\n   * @param {AccPoints} previousPoint - The previous accumulation point.\r\n   * @param {AccPoints} point - The accumulation point.\r\n   * @param {number} border - The border size.\r\n   * @param {number} labelRadius - The radius for the labels.\r\n   * @param {Size} textsize - The size of the labels.\r\n   * @param {number} margin - The margin value.\r\n   * @returns {void}\r\n   */\n  AccumulationDataLabel.prototype.setOuterSmartLabel = function (previousPoint, point, border, labelRadius, textsize, margin) {\n    if (!this.isCircular()) {\n      this.setSmartLabelForSegments(point, previousPoint);\n    } else {\n      var labelAngle = this.getOverlappedAngle(previousPoint.labelRegion, point.labelRegion, point.midAngle, border * 2);\n      this.getLabelRegion(point, 'Outside', textsize, labelRadius, margin, labelAngle);\n      if (labelAngle > point.endAngle) {\n        labelAngle = point.midAngle;\n        //this.setPointVisibileFalse(point);\n      }\n      point.labelAngle = labelAngle;\n      while (point.labelVisible && (isOverlap(previousPoint.labelRegion, point.labelRegion) || labelAngle <= previousPoint.labelAngle || labelAngle <= point.midAngle * 0.9 || this.isConnectorLineOverlapping(point, previousPoint))) {\n        if (labelAngle > point.endAngle) {\n          //this.setPointVisibileFalse(point);\n          break;\n        }\n        point.labelAngle = labelAngle;\n        this.getLabelRegion(point, 'Outside', textsize, labelRadius, margin, labelAngle);\n        labelAngle += 0.1;\n      }\n    }\n  };\n  /**\r\n   * Sets smart label positions for funnel and pyramid series.\r\n   *\r\n   * @param {AccPoints} point - The accumulation point.\r\n   * @param {AccPoints} prevPoint - The previous point.\r\n   * @returns {void} setSmartLabelForSegments.\r\n   */\n  AccumulationDataLabel.prototype.setSmartLabelForSegments = function (point, prevPoint) {\n    var textRegion = point.labelRegion;\n    //let overlapWidth: number = prevPoint.labelRegion.x + prevPoint.labelRegion.width - textRegion.x;\n    var overlapHeight = this.accumulation.type === 'Funnel' ? prevPoint.labelRegion.y - (textRegion.y + textRegion.height) : point.labelRegion.y - (prevPoint.labelRegion.y + prevPoint.labelRegion.height);\n    if (overlapHeight < 0) {\n      point.labelRegion.y += this.accumulation.type === 'Funnel' ? overlapHeight : -overlapHeight;\n    }\n  };\n  /**\r\n   * To find connector line overlapping.\r\n   *\r\n   * @param {AccPoints} point - The accumulation point.\r\n   * @param {AccPoints} previous - The previous point.\r\n   * @returns {boolean} - To find connector line overlapping or not.\r\n   */\n  AccumulationDataLabel.prototype.isConnectorLineOverlapping = function (point, previous) {\n    var position;\n    if (!this.isCircular() && point.labelRegion.x < point.region.x) {\n      position = 'outsideLeft';\n    }\n    var start = this.getLabelLocation(point, position);\n    var end = new ChartLocation(0, 0);\n    this.getEdgeOfLabel(point.labelRegion, point.labelAngle, end, 0, point);\n    var previousstart = this.getLabelLocation(previous);\n    var previousend = new ChartLocation(0, 0);\n    this.getEdgeOfLabel(previous.labelRegion, previous.labelAngle, previousend, 0, point);\n    return this.isLineRectangleIntersect(start, end, point.labelRegion) || this.isLineRectangleIntersect(start, end, previous.labelRegion) || this.isLineRectangleIntersect(previousstart, previousend, point.labelRegion);\n  };\n  /**\r\n   * To find two rectangle intersect.\r\n   *\r\n   * @param {ChartLocation} line1 - The first line.\r\n   * @param {ChartLocation} line2 - The second line.\r\n   * @param {Rect} rect - The rectangle to check against.\r\n   * @returns {boolean} - To find line rectangle intersect value.\r\n   */\n  AccumulationDataLabel.prototype.isLineRectangleIntersect = function (line1, line2, rect) {\n    var rectPoints = [new ChartLocation(Math.round(rect.x), Math.round(rect.y)), new ChartLocation(Math.round(rect.x + rect.width), Math.round(rect.y)), new ChartLocation(Math.round(rect.x + rect.width), Math.round(rect.y + rect.height)), new ChartLocation(Math.round(rect.x), Math.round(rect.y + rect.height))];\n    line1.x = Math.round(line1.x);\n    line1.y = Math.round(line1.y);\n    line2.x = Math.round(line2.x);\n    line2.y = Math.round(line2.y);\n    for (var i = 0; i < rectPoints.length; i++) {\n      if (this.isLinesIntersect(line1, line2, rectPoints[i], rectPoints[(i + 1) % rectPoints.length])) {\n        return true;\n      }\n    }\n    return false;\n  };\n  /**\r\n   * To find two line intersect.\r\n   *\r\n   * @param {ChartLocation} point1 - The first point of the first line.\r\n   * @param {ChartLocation} point2 - The second point of the first line.\r\n   * @param {ChartLocation} point11 - The first point of the second line.\r\n   * @param {ChartLocation} point12 - The second point of the second line.\r\n   * @returns {boolean} - To find line intersect or not.\r\n   */\n  AccumulationDataLabel.prototype.isLinesIntersect = function (point1, point2, point11, point12) {\n    var a1 = point2.y - point1.y;\n    var b1 = point1.x - point2.x;\n    var c1 = a1 * point1.x + b1 * point1.y;\n    var a2 = point12.y - point11.y;\n    var b2 = point11.x - point12.x;\n    var c2 = a2 * point11.x + b2 * point11.y;\n    var delta = a1 * b2 - a2 * b1;\n    if (delta !== 0) {\n      var x = (b2 * c1 - b1 * c2) / delta;\n      var y = (a1 * c2 - a2 * c1) / delta;\n      var lies = Math.min(point1.x, point2.x) <= x && x <= Math.max(point1.x, point2.x);\n      lies = lies && Math.min(point1.y, point2.y) <= y && y <= Math.max(point1.y, point2.y);\n      lies = lies && Math.min(point11.x, point12.x) <= x && x <= Math.max(point11.x, point12.x);\n      lies = lies && Math.min(point11.y, point12.y) <= y && y <= Math.max(point11.y, point12.y);\n      return lies;\n    }\n    return false;\n  };\n  /**\r\n   * To get two rectangle overlapping angles.\r\n   *\r\n   * @param {Rect} first - The first rectangle.\r\n   * @param {Rect} second - The second rectangle.\r\n   * @param {number} angle - The angle.\r\n   * @param {number} padding - The padding.\r\n   * @returns {number} - Get overlapped angle.\r\n   */\n  AccumulationDataLabel.prototype.getOverlappedAngle = function (first, second, angle, padding) {\n    var x = first.x;\n    if (angle >= 90 && angle <= 270) {\n      second.y = first.y - (padding + second.height / 2);\n      x = first.x + first.width;\n    } else {\n      second.y = first.y + first.height + padding;\n    }\n    return getAngle(this.center, new ChartLocation(x, second.y));\n  };\n  /**\r\n   * To get connector line path.\r\n   *\r\n   * @param {Rect} label - The label.\r\n   * @param {AccPoints} point - The accumulation point.\r\n   * @param {AccumulationDataLabelSettingsModel} dataLabel - The data label settings.\r\n   * @param {number} end - The end.\r\n   * @returns {string} - Get connector line path.\r\n   */\n  AccumulationDataLabel.prototype.getConnectorPath = function (label, point, dataLabel, end) {\n    if (end === void 0) {\n      end = 0;\n    }\n    var connector = dataLabel.connectorStyle;\n    var labelRadius = this.isCircular() ? !this.isVariousRadius() ? this.labelRadius : this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], point) : this.getLabelDistance(point, dataLabel);\n    //let labelRadius: number = this.isCircular() ? this.labelRadius : this.getLabelDistance(point, dataLabel);\n    var start = this.getConnectorStartPoint(point, connector);\n    var labelAngle = this.accumulation.enableSmartLabels ? point.midAngle : end || point.midAngle;\n    var middle = new ChartLocation(0, 0);\n    var endPoint = this.getEdgeOfLabel(label, labelAngle, middle, connector.width, point);\n    if (connector.type === 'Curve') {\n      if (this.isCircular()) {\n        var r = labelRadius - (this.isVariousRadius() ? stringToNumber(point.sliceRadius, this.accumulation.pieSeriesModule.size / 2) : this.radius);\n        //let r: number = labelRadius - this.radius;\n        if (point.isLabelUpdated) {\n          middle = this.getPerpendicularDistance(start, point);\n        } else {\n          middle = degreeToLocation(labelAngle, labelRadius - r / 2, this.center);\n          if (point.labelPosition === 'Outside' && dataLabel.position === 'Inside') {\n            middle = degreeToLocation(labelAngle, labelRadius - r * 1.25, this.center);\n          }\n        }\n        return 'M ' + start.x + ' ' + start.y + ' Q ' + middle.x + ' ' + middle.y + ' ' + endPoint.x + ' ' + endPoint.y;\n      } else {\n        return this.getPolyLinePath(start, endPoint);\n      }\n    } else {\n      return 'M ' + start.x + ' ' + start.y + ' L ' + middle.x + ' ' + middle.y + ' L ' + endPoint.x + ' ' + endPoint.y;\n    }\n  };\n  /**\r\n   * Finds the curved path for funnel/pyramid data label connectors.\r\n   *\r\n   * @param {ChartLocation} start - The start location.\r\n   * @param {ChartLocation} end - The end location.\r\n   * @returns {string} - Get poly line path.\r\n   */\n  AccumulationDataLabel.prototype.getPolyLinePath = function (start, end) {\n    var controlPoints = [start, end];\n    if (start.y === end.y) {\n      return 'M ' + start.x + ' ' + start.y + ' L ' + end.x + ' ' + end.y;\n    }\n    var path = 'M';\n    for (var i = 0; i <= 16; i++) {\n      var t = i / 16;\n      var points = this.getBezierPoint(t, controlPoints, 0, 2);\n      path += points.x + ',' + points.y;\n      if (i !== 16) {\n        path += ' L';\n      }\n    }\n    return path;\n  };\n  /**\r\n   * Finds the bezier point for funnel/pyramid data label connectors.\r\n   *\r\n   * @param {number} t - The parameter value.\r\n   * @param {ChartLocation[]} controlPoints - The control points for the bezier point.\r\n   * @param {number} index - The index of the point.\r\n   * @param {number} count - The total count of points.\r\n   * @returns {ChartLocation} - Get bazier point.\r\n   */\n  AccumulationDataLabel.prototype.getBezierPoint = function (t, controlPoints, index, count) {\n    if (count === 1) {\n      return controlPoints[index];\n    }\n    var p0 = this.getBezierPoint(t, controlPoints, index, count - 1);\n    var p1 = this.getBezierPoint(t, controlPoints, index + 1, count - 1);\n    var x = p0.x ? p0.x : p0.x;\n    var y = p0.y ? p0.y : p0.y;\n    var x1 = p1.x ? p1.x : p1.x;\n    var y1 = p1.y ? p1.y : p1.y;\n    var x2 = (1 - t) * x + t * x1;\n    var y2 = (1 - t) * y + t * y1;\n    if (p0.x) {\n      return {\n        x: x2,\n        y: y2\n      };\n    } else {\n      return {\n        x: x2,\n        y: y2\n      };\n    }\n  };\n  /**\r\n   * To get label edges based on the center and label rect position.\r\n   *\r\n   * @param {Rect} labelshape - The label shape.\r\n   * @param {number} angle - The angle of the label.\r\n   * @param {ChartLocation} middle - The middle point of the label.\r\n   * @param {number} border - The border value.\r\n   * @param {AccPoints} point - The accumulation point.\r\n   * @returns {ChartLocation} - Get label edge value.\r\n   */\n  AccumulationDataLabel.prototype.getEdgeOfLabel = function (labelshape, angle, middle, border, point) {\n    if (border === void 0) {\n      border = 1;\n    }\n    var edge = new ChartLocation(labelshape.x, labelshape.y);\n    var space = 10;\n    if (angle >= 90 && angle <= 270) {\n      edge.x += labelshape.width + border / 2 + space;\n      edge.y += labelshape.height / 2;\n      middle.x = edge.x + 10;\n      middle.y = edge.y;\n    } else if (point && point.region && point.region.x > point.labelRegion.x) {\n      edge.x += border * 2 + labelshape.width + space;\n      edge.y += labelshape.height / 2;\n      middle.x = edge.x + 10;\n      middle.y = edge.y;\n    } else {\n      edge.x -= space - border / 2;\n      edge.y += labelshape.height / 2;\n      middle.x = edge.x - 10;\n      middle.y = edge.y;\n    }\n    return edge;\n  };\n  /**\r\n   * Finds the distance between the label position and the edge/center of the funnel/pyramid.\r\n   *\r\n   * @param {AccPoints} point - The accumulation point.\r\n   * @param {AccumulationDataLabelSettingsModel} dataLabel - The data label settings.\r\n   * @returns {number} - Get label distance.\r\n   */\n  AccumulationDataLabel.prototype.getLabelDistance = function (point, dataLabel) {\n    if (point.labelPosition && dataLabel.position !== point.labelPosition || dataLabel.connectorStyle.length && dataLabel.position === 'Outside') {\n      var length_1 = stringToNumber(dataLabel.connectorStyle.length || '70px', this.accumulation.initialClipRect.width);\n      if (length_1 < this.accumulation.initialClipRect.width) {\n        return length_1;\n      }\n    }\n    var position = point.labelPosition || dataLabel.position;\n    var series = this.accumulation.visibleSeries[0];\n    var extraSpace = (this.accumulation.initialClipRect.width - series.triangleSize.width) / 2;\n    var labelLocation;\n    switch (position) {\n      case 'Inside':\n        return 0;\n      case 'Outside':\n        labelLocation = point.symbolLocation.x + point.labelOffset.x;\n        return this.accumulation.initialClipRect.width - labelLocation - extraSpace;\n    }\n  };\n  /**\r\n   * Finds the label position / beginning of the connector(ouside funnel labels).\r\n   *\r\n   * @param {AccPoints} point - The accumulation point.\r\n   * @param {AccumulationLabelPosition | string} position - The data label position.\r\n   * @returns {ChartLocation} - Get label location.\r\n   */\n  AccumulationDataLabel.prototype.getLabelLocation = function (point, position) {\n    if (position === void 0) {\n      position = 'Outside';\n    }\n    if (this.accumulation.type !== 'Pie') {\n      position = position === 'OutsideLeft' ? 'OutsideLeft' : point.labelPosition || position;\n      var location_2 = {\n        x: point.symbolLocation.x,\n        y: point.symbolLocation.y - point.labelOffset.y\n      };\n      switch (position) {\n        case 'Inside':\n          location_2.y = point.region.y + point.region.height / 2;\n          break;\n        case 'Outside':\n          location_2.x += point.labelOffset.x;\n          break;\n        case 'OutsideLeft':\n          location_2.x -= point.labelOffset.x;\n      }\n      return location_2;\n    } else {\n      //return degreeToLocation(point.midAngle, this.radius, this.center);\n      return degreeToLocation(point.midAngle, this.isVariousRadius() ? stringToNumber(point.sliceRadius, this.accumulation.pieSeriesModule.seriesRadius) : this.radius, this.center);\n    }\n  };\n  /**\r\n   * Finds the beginning of connector line.\r\n   *\r\n   * @param {AccPoints} point - The accumulation point.\r\n   * @param {ConnectorModel} connector - The connector line.\r\n   * @returns {ChartLocation} - Staring point of connector line.\r\n   */\n  AccumulationDataLabel.prototype.getConnectorStartPoint = function (point, connector) {\n    // return this.isCircular() ? degreeToLocation(point.midAngle, this.radius - connector.width, this.center) :\n    //     this.getLabelLocation(point);\n    var position;\n    if (!this.isCircular() && point.region.x > point.labelRegion.x) {\n      position = 'OutsideLeft';\n    }\n    return this.isCircular() ? degreeToLocation(point.midAngle, (this.isVariousRadius() ? stringToNumber(point.sliceRadius, this.accumulation.pieSeriesModule.seriesRadius) : this.radius) - connector.width, this.center) : this.getLabelLocation(point, position);\n  };\n  /**\r\n   * To find area rect based on margin, available size.\r\n   *\r\n   * @private\r\n   * @returns {void}\r\n   */\n  AccumulationDataLabel.prototype.findAreaRect = function () {\n    this.areaRect = new Rect(0, 0, this.accumulation.availableSize.width, this.accumulation.availableSize.height);\n    var margin = this.accumulation.margin;\n    subtractThickness(this.areaRect, new Thickness(margin.left, margin.right, margin.top, margin.bottom));\n  };\n  /**\r\n   * To render the data labels from series points.\r\n   *\r\n   * @param {AccPoints} point - The point for which to render the data label.\r\n   * @param {AccumulationDataLabelSettingsModel} dataLabel - The settings for the data labels.\r\n   * @param {Element} parent - The parent element to which the data labels are appended.\r\n   * @param {AccPoints[]} points - The collection of points in the series.\r\n   * @param {number} series - The index of the series.\r\n   * @param {HTMLElement} templateElement - The template element for the data label.\r\n   * @param {boolean} redraw - Indicates whether the data labels are being redrawn.\r\n   * @returns {void}\r\n   */\n  AccumulationDataLabel.prototype.renderDataLabel = function (point, dataLabel, parent, points, series, templateElement, redraw) {\n    var id = this.accumulation.element.id + '_datalabel_Series_' + series + '_';\n    var datalabelGroup = this.accumulation.renderer.createGroup({\n      id: id + 'g_' + point.index\n    });\n    var border = {\n      width: dataLabel.border.width,\n      color: dataLabel.border.color\n    };\n    var argsFont = extend({}, getValue('properties', dataLabel.font), null, true);\n    point.label = this.getDatalabelText(dataLabel.format, this.accumulation, point.originalText || point.y.toString());\n    var argsData = {\n      cancel: false,\n      name: textRender,\n      series: this.accumulation.visibleSeries[0],\n      point: point,\n      text: point.label,\n      border: border,\n      color: dataLabel.fill,\n      template: dataLabel.template,\n      font: argsFont\n    };\n    this.accumulation.trigger(textRender, argsData);\n    point.argsData = argsData;\n    var isTemplate = argsData.template !== null;\n    point.labelVisible = !argsData.cancel;\n    point.text = point.label = argsData.text;\n    point.labelCollection = [];\n    this.marginValue = argsData.border.width ? 5 + argsData.border.width : 1;\n    var childElement = createElement('div', {\n      id: this.accumulation.element.id + '_Series_' + 0 + '_DataLabel_' + point.index,\n      styles: 'position: absolute;background-color:' + argsData.color + ';' + getFontStyle(dataLabel.font, this.accumulation.themeStyle.datalabelFont) + ';border:' + argsData.border.width + 'px solid ' + argsData.border.color + ';'\n    });\n    this.calculateLabelSize(isTemplate, childElement, point, points, argsData, datalabelGroup, id, dataLabel, redraw);\n  };\n  AccumulationDataLabel.prototype.getDatalabelText = function (labelFormat, chart, labelText) {\n    if (Number(labelText)) {\n      var customLabelFormat = labelFormat.match('{value}') !== null;\n      var format = chart.intl.getNumberFormat({\n        format: customLabelFormat ? '' : labelFormat,\n        useGrouping: chart.useGroupingSeparator\n      });\n      labelText = customLabelFormat ? labelFormat.replace('{value}', format(parseFloat(labelText))) : format(parseFloat(labelText));\n    }\n    return labelText;\n  };\n  /**\r\n   * To calculate label size.\r\n   *\r\n   * @param {boolean} isTemplate - Indicates whether the label is a template.\r\n   * @param {HTMLElement} childElement - The child element of the label.\r\n   * @param {AccPoints} point - The point associated with the label.\r\n   * @param {AccPoints[]} points - The collection of points.\r\n   * @param {IAccTextRenderEventArgs} argsData - The arguments data for text rendering.\r\n   * @param {Element} datalabelGroup - The group element for data labels.\r\n   * @param {string} id - The id of the label.\r\n   * @param {AccumulationDataLabelSettingsModel} dataLabel - The settings for the data labels.\r\n   * @param {boolean} redraw - Indicates whether the labels are being redrawn.\r\n   * @param {ClientRect} clientRect - The client rectangle.\r\n   * @param {boolean} isReactCallback - Indicates whether a React callback is being used.\r\n   * @returns {void}\r\n   */\n  AccumulationDataLabel.prototype.calculateLabelSize = function (isTemplate, childElement, point, points, argsData, datalabelGroup, id, dataLabel, redraw, clientRect, isReactCallback) {\n    this.calculateLabelCollection(point, dataLabel);\n    var textSize = isTemplate ? isReactCallback ? {\n      width: clientRect.width,\n      height: clientRect.height\n    } : this.getTemplateSize(childElement, point, argsData, redraw, isTemplate, points, datalabelGroup, id, dataLabel) : this.getTextSize(point.labelCollection, dataLabel);\n    textSize.height += 4; // 4 for calculation with padding for smart label shape\n    textSize.width += 4;\n    point.textSize = textSize;\n    point.templateElement = childElement;\n    this.getDataLabelPosition(point, dataLabel, textSize, points);\n    if (point.labelRegion) {\n      this.correctLabelRegion(point.labelRegion, point.textSize);\n    }\n  };\n  /**\r\n   * To draw a data label.\r\n   *\r\n   * @param {AccumulationSeries} series - The series associated with the data label.\r\n   * @param {AccumulationDataLabelSettingsModel} dataLabel - The settings for the data labels.\r\n   * @param {HTMLElement} parent - The parent element of the data labels.\r\n   * @param {HTMLElement} templateElement - The template element for the data label.\r\n   * @param {boolean} redraw - Indicates whether the data labels are being redrawn.\r\n   * @returns {void}\r\n   * @private\r\n   */\n  AccumulationDataLabel.prototype.drawDataLabels = function (series, dataLabel, parent, templateElement, redraw) {\n    var angle;\n    var degree;\n    var modifiedPoints = series.leftSidePoints.concat(series.rightSidePoints);\n    modifiedPoints.sort(function (a, b) {\n      return a.index - b.index;\n    });\n    if (series.type === 'Pie' && this.accumulation.enableSmartLabels) {\n      this.extendedLabelsCalculation();\n    }\n    for (var _i = 0, modifiedPoints_1 = modifiedPoints; _i < modifiedPoints_1.length; _i++) {\n      var point = modifiedPoints_1[_i];\n      if (!isNullOrUndefined(point.argsData) && !isNullOrUndefined(point.y)) {\n        this.finalizeDatalabels(point, modifiedPoints, dataLabel);\n        var id = this.accumulation.element.id + '_datalabel_Series_' + 0 + '_';\n        var datalabelGroup = this.accumulation.renderer.createGroup({\n          id: id + 'g_' + point.index\n        });\n        datalabelGroup.setAttribute('aria-hidden', 'true');\n        var dataLabelElement = void 0;\n        var location_3 = void 0;\n        var element = void 0;\n        if (point.visible && point.labelVisible) {\n          angle = degree = dataLabel.angle;\n          if (point.argsData.template) {\n            this.setTemplateStyle(point.templateElement, point, templateElement, dataLabel.font.color, point.color, redraw);\n          } else {\n            location_3 = new ChartLocation(point.labelRegion.x + this.marginValue, point.labelRegion.y + point.textSize.height * 3 / (point.labelCollection.length * 4) + this.marginValue);\n            element = getElement(id + 'shape_' + point.index);\n            var startLocation = element ? new ChartLocation(+element.getAttribute('x'), +element.getAttribute('y')) : null;\n            var textWidth = point.textSize.width;\n            if (dataLabel.enableRotation) {\n              if (angle === 0) {\n                if (point.labelPosition === 'Outside') {\n                  degree = 0;\n                } else if (point.midAngle >= 90 && point.midAngle <= 260) {\n                  degree = point.midAngle + 180;\n                } else {\n                  degree = point.midAngle;\n                }\n              } else {\n                degree = angle > 360 ? angle - 360 : angle < -360 ? angle + 360 : angle;\n              }\n            } else {\n              degree = 0;\n            }\n            var rotate = 'rotate(' + degree + ',' + (location_3.x + textWidth / 2) + ',' + location_3.y + ')';\n            point.transform = rotate;\n            dataLabelElement = this.accumulation.renderer.drawRectangle(new RectOption(id + 'shape_' + point.index, point.argsData.color, point.argsData.border, 1, point.labelRegion, dataLabel.rx, dataLabel.ry, rotate, series.dataLabel.border.dashArray));\n            appendChildElement(false, datalabelGroup, dataLabelElement, redraw, true, 'x', 'y', startLocation, null, false, false, null, this.accumulation.duration);\n            textElement(this.accumulation.renderer, new TextOption(id + 'text_' + point.index, location_3.x, location_3.y, this.accumulation.enableRtl ? 'end' : 'start', point.labelCollection, rotate, 'auto', degree), point.argsData.font, point.argsData.font.color || this.getSaturatedColor(point, point.argsData.color), datalabelGroup, false, redraw, true, false, this.accumulation.duration, null, null, null, null, true, this.accumulation.themeStyle.datalabelFont);\n            element = null;\n          }\n          if (this.accumulation.accumulationLegendModule && this.accumulation.legendSettings.visible && (dataLabel.position === 'Outside' || this.accumulation.enableSmartLabels)) {\n            this.accumulation.visibleSeries[0].findMaxBounds(this.accumulation.visibleSeries[0].labelBound, point.labelRegion);\n          }\n          if (point.labelPosition === 'Outside') {\n            var element_1 = getElement(id + 'connector_' + point.index);\n            var previousDirection = element_1 ? element_1.getAttribute('d') : '';\n            var pathElement = this.accumulation.renderer.drawPath(new PathOption(id + 'connector_' + point.index, 'transparent', dataLabel.connectorStyle.width, dataLabel.connectorStyle.color || point.color, 1, dataLabel.connectorStyle.dashArray, this.getConnectorPath(extend({}, point.labelRegion, null, true), point, dataLabel, point.labelAngle)));\n            appendChildElement(false, datalabelGroup, pathElement, redraw, true, null, null, null, previousDirection, false, false, null, this.accumulation.duration);\n          }\n          appendChildElement(false, parent, datalabelGroup, redraw);\n        }\n      }\n    }\n    if (this.accumulation.type === 'Pie' && dataLabel.textWrap === 'Normal' && dataLabel.textOverflow === 'Clip') {\n      this.dataLabelClipPath(dataLabel, parent);\n    }\n  };\n  /**\r\n   * To calculate data label clip path.\r\n   *\r\n   * @param {AccumulationDataLabelSettingsModel} dataLabel - The settings for the data labels.\r\n   * @param {HTMLElement} parent - The parent element of the data labels.\r\n   * @returns {void}\r\n   */\n  AccumulationDataLabel.prototype.dataLabelClipPath = function (dataLabel, parent) {\n    var id = this.accumulation.element.id + '_datalabel_Series_' + 0 + '_';\n    var clippath = this.accumulation.renderer.createClipPath({\n      id: id + 'clipPath'\n    });\n    var clipRect;\n    var radius = this.accumulation.pieSeriesModule.pieBaseRadius;\n    if (dataLabel.position === 'Inside') {\n      clipRect = this.accumulation.renderer.drawCircle(new CircleOption(id + 'clipPath_rect', 'transparent', {\n        width: 0\n      }, 0, this.center.x, this.center.y, radius));\n    } else if (dataLabel.maxWidth) {\n      var x = this.center.x - radius - stringToNumber(dataLabel.connectorStyle.length || '4%', radius) - dataLabel.maxWidth;\n      var y = this.center.y - radius - stringToNumber(dataLabel.connectorStyle.length || '4%', radius) - dataLabel.maxWidth;\n      var height = (radius + stringToNumber(dataLabel.connectorStyle.length || '4%', radius) + dataLabel.maxWidth) * 2;\n      var width = height;\n      if (this.accumulation.legendSettings.visible) {\n        var legendModule = this.accumulation.accumulationLegendModule;\n        if (legendModule.position === 'Left') {\n          width = legendModule.legendBounds.x + legendModule.legendBounds.width - x > 0 ? width - (legendModule.legendBounds.width - x) : width;\n          x = legendModule.legendBounds.x + legendModule.legendBounds.width < x ? x : legendModule.legendBounds.x + legendModule.legendBounds.width;\n        } else if (legendModule.position === 'Right') {\n          width = x + width - legendModule.legendBounds.x > 0 ? width - (x + width - legendModule.legendBounds.x) : width;\n        }\n      }\n      clipRect = this.accumulation.renderer.drawRectangle(new RectOption(id + 'clipPath_rect', 'transparent', {\n        width: 0\n      }, 0, new Rect(x, y, height, width), 0, 0));\n    }\n    if (dataLabel.position === 'Inside' || dataLabel.maxWidth) {\n      clippath.appendChild(clipRect);\n      appendChildElement(false, this.accumulation.svgObject, clippath);\n      parent.style.cssText = 'clip-path:url(#' + clippath.id + ')';\n    }\n  };\n  /**\r\n   * In this method datalabels region checked with legebdBounds and areaBounds.\r\n   * Trimming of datalabel and point's visibility again changed here.\r\n   *\r\n   * @param {AccPoints} point - Current point in which trimming and visibility to be checked.\r\n   * @param {AccPoints[]} points - Finalized points.\r\n   * @param {AccumulationDataLabelSettingsModel} dataLabel - Datalabel model.\r\n   * @returns {void}\r\n   */\n  AccumulationDataLabel.prototype.finalizeDatalabels = function (point, points, dataLabel) {\n    if (this.isOverlapping(point, points) || this.titleRect && point.labelRegion && isOverlap(point.labelRegion, this.titleRect)) {\n      if (this.isCircular() && point.labelPosition === 'Outside' && this.accumulation.enableSmartLabels) {\n        this.setPointVisibileFalse(point);\n      }\n    }\n    if (this.accumulation.accumulationLegendModule && this.accumulation.legendSettings.visible && point.labelVisible && point.labelRegion && (!dataLabel.maxWidth ? dataLabel.textOverflow === 'Clip' ? dataLabel.textWrap !== 'Normal' : true : false)) {\n      var rect = this.accumulation.accumulationLegendModule.legendBounds;\n      if (this.accumulation.visibleSeries[0].type !== 'Pie' && this.accumulation.legendSettings.position === 'Left' && dataLabel.position === 'Outside') {\n        point.labelRegion.x = point.labelRegion.x + rect.width;\n      }\n      var padding = this.accumulation.legendSettings.border.width / 2;\n      this.textTrimming(point, new Rect(rect.x - padding, rect.y - padding, rect.width + 2 * padding, rect.height + 2 * padding), dataLabel.font, this.accumulation.accumulationLegendModule.position, dataLabel);\n    }\n    if (point.labelVisible && point.labelRegion && (!dataLabel.maxWidth ? dataLabel.textOverflow === 'Clip' ? dataLabel.textWrap !== 'Normal' : true : false)) {\n      var position = this.isCircular() ? point.labelRegion.x >= this.center.x ? 'InsideRight' : 'InsideLeft' : point.labelRegion.x >= point.region.x ? 'InsideRight' : 'InsideLeft';\n      this.textTrimming(point, this.areaRect, dataLabel.font, position, dataLabel);\n    }\n    if (point.labelVisible && point.labelRegion && !dataLabel.maxWidth && dataLabel.textOverflow !== 'Clip' && this.accumulation.enableSmartLabels && (point.labelRegion.y + point.labelRegion.height / 2 > this.areaRect.y + this.areaRect.height || point.labelRegion.y < this.areaRect.y || point.labelRegion.x < this.areaRect.x || point.labelRegion.x + point.labelRegion.width > this.areaRect.x + this.areaRect.width)) {\n      this.setPointVisibileFalse(point);\n    }\n  };\n  /**\r\n   * To find the template element size.\r\n   *\r\n   * @param {HTMLElement} element - To get a template element.\r\n   * @param {AccPoints} point - The accumulation point for the template.\r\n   * @param {IAccTextRenderEventArgs} argsData - The arguments for the accumulation points.\r\n   * @param {boolean} redraw - Indicates whether to redraw the template.\r\n   * @param {boolean} isTemplate - Indicates whether the element is a template.\r\n   * @param {AccPoints[]} points - The accumulation points for the template.\r\n   * @param {Element} datalabelGroup - The group element for the data labels.\r\n   * @param {string} id - The identifier for the template.\r\n   * @param {AccumulationDataLabelSettingsModel} dataLabel - The settings for the data labels.\r\n   * @returns {Size} - The size of the template.\r\n   */\n  AccumulationDataLabel.prototype.getTemplateSize = function (element, point, argsData, redraw, isTemplate, points, datalabelGroup, id, dataLabel) {\n    element = createTemplate(element, point.index, argsData.template, this.accumulation, point, this.accumulation.visibleSeries[0], this.accumulation.element.id + '_DataLabel', 0, argsData, isTemplate, points, datalabelGroup, id, dataLabel, redraw);\n    var clientRect = measureElementRect(element, redraw);\n    return {\n      width: clientRect.width,\n      height: clientRect.height\n    };\n  };\n  /**\r\n   * To set the template element style.\r\n   *\r\n   * @param {HTMLElement} childElement - The child element of the template.\r\n   * @param {AccPoints} point - The point data for the template.\r\n   * @param {Element} parent - The parent element of the template.\r\n   * @param {string} labelColor - The color of the label in the template.\r\n   * @param {string} fill - The fill color of the template.\r\n   * @param {boolean} redraw - Indicates whether to redraw the template.\r\n   * @returns {void}\r\n   */\n  AccumulationDataLabel.prototype.setTemplateStyle = function (childElement, point, parent, labelColor, fill, redraw) {\n    childElement.style.left = point.labelRegion.x + 'px';\n    childElement.style.top = point.labelRegion.y + 'px';\n    childElement.style.color = labelColor || this.getSaturatedColor(point, point.labelPosition === 'Inside' ? fill : this.getLabelBackground(point));\n    if (this.accumulation.isBlazor) {\n      var position = this.isCircular() ? point.labelRegion.x >= this.center.x ? 'InsideRight' : 'InsideLeft' : point.labelRegion.x >= point.region.x ? 'InsideRight' : 'InsideLeft';\n      if (position === 'InsideRight') {\n        childElement.style.transform = 'translate(0%, -50%)';\n      } else {\n        childElement.style.transform = 'translate(-100%, -50%)';\n      }\n    }\n    if (childElement.childElementCount) {\n      appendChildElement(false, parent, childElement, redraw, true, 'left', 'top');\n      this.doTemplateAnimation(this.accumulation, childElement);\n    }\n  };\n  /**\r\n   * To find saturated color for datalabel\r\n   *\r\n   * @param {AccPoints} point - The accumulation point.\r\n   * @param {string} color - The original color.\r\n   * @returns {string} - Get a saturated color.\r\n   */\n  AccumulationDataLabel.prototype.getSaturatedColor = function (point, color) {\n    var saturatedColor;\n    if (this.marginValue >= 1) {\n      saturatedColor = color === 'transparent' ? this.getLabelBackground(point) : color;\n    } else {\n      saturatedColor = this.getLabelBackground(point);\n    }\n    saturatedColor = saturatedColor === 'transparent' ? this.accumulation.theme.indexOf('Dark') > -1 || this.accumulation.theme.indexOf('HighContrast') > -1 ? 'black' : 'white' : saturatedColor;\n    var rgbValue = convertHexToColor(colorNameToHex(saturatedColor));\n    var contrast = Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000);\n    return contrast >= 128 ? 'black' : 'white';\n  };\n  /**\r\n   * Animates the data label template.\r\n   *\r\n   * @param {AccumulationChart} accumulation - The accumulation chart control.\r\n   * @param {Element} element - The element to animate.\r\n   * @returns {void}\r\n   * @private\r\n   */\n  AccumulationDataLabel.prototype.doTemplateAnimation = function (accumulation, element) {\n    var series = accumulation.visibleSeries[0];\n    var delay = series.animation.delay + series.animation.duration;\n    if ((series.animation.enable && animationMode !== 'Disable' || animationMode === 'Enable') && accumulation.animateSeries) {\n      element.style.visibility = 'hidden';\n      templateAnimate(element, delay, 200, 'ZoomIn');\n    }\n  };\n  /**\r\n   * To find background color for the datalabel.\r\n   *\r\n   * @param {AccPoints} point - The data point for which to determine the background color.\r\n   * @returns {string} - The background color for the data label.\r\n   */\n  AccumulationDataLabel.prototype.getLabelBackground = function (point) {\n    return point.labelPosition === 'Outside' ? this.accumulation.background || this.accumulation.themeStyle.background : !point.y ? this.accumulation.theme.indexOf('dark') ? 'white' : 'black' : point.color;\n  };\n  /**\r\n   * To correct the padding between datalabel regions.\r\n   *\r\n   * @param {Rect} labelRegion - The region occupied by the data label.\r\n   * @param {Size} textSize - The size of the text within the data label.\r\n   * @param {number} padding - The padding value to adjust the spacing.\r\n   * @returns {void}\r\n   */\n  AccumulationDataLabel.prototype.correctLabelRegion = function (labelRegion, textSize, padding) {\n    if (padding === void 0) {\n      padding = 4;\n    }\n    labelRegion.height -= padding;\n    labelRegion.width -= padding;\n    labelRegion.x += padding / 2;\n    labelRegion.y += padding / 2;\n    textSize.height -= padding;\n    textSize.width -= padding;\n  };\n  /**\r\n   * To get the dataLabel module name.\r\n   *\r\n   * @returns {string} - Returns the module name.\r\n   */\n  AccumulationDataLabel.prototype.getModuleName = function () {\n    return 'AccumulationDataLabel';\n  };\n  /**\r\n   * To destroy the data label.\r\n   *\r\n   * @returns {void}\r\n   * @private\r\n   */\n  AccumulationDataLabel.prototype.destroy = function () {\n    /**\r\n     * Destroy method performed here.\r\n     */\n  };\n  //calculation for placing labels smartly\n  AccumulationDataLabel.prototype.extendedLabelsCalculation = function () {\n    var _this = this;\n    var series = this.accumulation.series[0];\n    series.rightSidePoints.forEach(function (point, index, halfSidePoints) {\n      point.initialLabelRegion = point.labelRegion;\n      point.isLabelUpdated = 0;\n      _this.skipPoints(point, halfSidePoints, index);\n    });\n    series.leftSidePoints.forEach(function (point, index, halfSidePoints) {\n      point.initialLabelRegion = point.labelRegion;\n      point.isLabelUpdated = 0;\n      _this.skipPoints(point, halfSidePoints, index);\n    });\n    this.arrangeLeftSidePoints(series);\n    this.isIncreaseAngle = false;\n    this.arrangeRightSidePoints(series);\n  };\n  /**\r\n   * Rightside points alignments calculation.\r\n   *\r\n   * @param {AccumulationSeries} series - To get a proper series.\r\n   * @returns {void}\r\n   */\n  AccumulationDataLabel.prototype.arrangeRightSidePoints = function (series) {\n    var startFresh;\n    var angleChanged;\n    var rightSideRenderPoints = series.rightSidePoints.filter(function (point) {\n      return point.labelVisible && point.labelPosition === 'Outside';\n    });\n    this.rightSideRenderingPoints = rightSideRenderPoints;\n    var checkAngle;\n    var currentPoint;\n    var lastPoint = rightSideRenderPoints[rightSideRenderPoints.length - 1];\n    var nextPoint;\n    if (lastPoint) {\n      if (lastPoint.labelAngle > 90 && lastPoint.labelAngle < 270) {\n        this.isIncreaseAngle = true;\n        this.changeLabelAngle(lastPoint, 89);\n      }\n    }\n    /**\r\n     * Right side points arranged from last point.\r\n     * A point checked with successive points for overlapping.\r\n     * If that is overlapped, its label angle is decreased and placing in optimal position\r\n     * If one point's angle is decreased, its previous points in the half side points also decreased until it reaced optimum position.\r\n     * When decreasing angle falls beyond 270, label angle increased.\r\n     * If one point's angle is increased, its successive points in that half point also increased until it reaced optimum position.\r\n     */\n    for (var i = rightSideRenderPoints.length - 1; i >= 0; i--) {\n      currentPoint = rightSideRenderPoints[i];\n      nextPoint = rightSideRenderPoints[i + 1];\n      // A point checked for overlapping, label visibility\n      if (this.isOverlapWithNext(currentPoint, rightSideRenderPoints, i) && currentPoint.labelVisible || !(currentPoint.labelAngle <= 90 || currentPoint.labelAngle >= 270)) {\n        checkAngle = lastPoint.labelAngle + 10;\n        angleChanged = true;\n        //If last's point change angle in beyond the limit, stop the increasing angle and do decrease the angle.\n        if (startFresh) {\n          this.isIncreaseAngle = false;\n        } else if (checkAngle > 90 && checkAngle < 270 && nextPoint.isLabelUpdated) {\n          this.isIncreaseAngle = true;\n        }\n        if (!this.isIncreaseAngle) {\n          for (var k = i + 1; k < rightSideRenderPoints.length; k++) {\n            this.increaseAngle(rightSideRenderPoints[k - 1], rightSideRenderPoints[k], series, true);\n          }\n        } else {\n          for (var k = i + 1; k > 0; k--) {\n            this.decreaseAngle(rightSideRenderPoints[k], rightSideRenderPoints[k - 1], series, true);\n          }\n        }\n      } else {\n        //If a point did not overlapped with previous points, increase the angle always for right side points.\n        if (angleChanged && nextPoint && !nextPoint.isLabelUpdated) {\n          startFresh = true;\n        }\n      }\n    }\n  };\n  /**\r\n   * Leftside points alignments calculation.\r\n   *\r\n   * @param {AccumulationSeries} series - To get a proper series.\r\n   * @returns {void}\r\n   */\n  AccumulationDataLabel.prototype.arrangeLeftSidePoints = function (series) {\n    var _this = this;\n    var leftSideRenderPoints = series.leftSidePoints.filter(function (point) {\n      return point.labelVisible && point.labelPosition === 'Outside';\n    });\n    this.leftSideRenderingPoints = leftSideRenderPoints;\n    var previousPoint;\n    var currentPoint;\n    var angleChanged;\n    var startFresh;\n    /**\r\n     * Left side points arranged from first point.\r\n     * A point checked with previous points for overlapping.\r\n     * If that is overlapped, its label angle is decreased and placing in optimal position\r\n     * If one point's angle is decreased, its previous points in the half side points also decreased until it reaced optimum position.\r\n     * When decreasing angle falls beyond 90, label angle increased.\r\n     * If one point's angle is increased, its successive points in that half point also increased until it reaced optimum position.\r\n     */\n    for (var i = 0; i < leftSideRenderPoints.length; i++) {\n      currentPoint = leftSideRenderPoints[i];\n      previousPoint = leftSideRenderPoints[i - 1];\n      // A point checked\n      if (this.isOverlapWithPrevious(currentPoint, leftSideRenderPoints, i) && currentPoint.labelVisible || !(currentPoint.labelAngle < 270)) {\n        angleChanged = true;\n        if (startFresh) {\n          this.isIncreaseAngle = false;\n        }\n        if (!this.isIncreaseAngle) {\n          for (var k = i; k > 0; k--) {\n            this.decreaseAngle(leftSideRenderPoints[k], leftSideRenderPoints[k - 1], series, false);\n            leftSideRenderPoints.filter(function (point, index) {\n              if (point.isLabelUpdated && leftSideRenderPoints[index].labelAngle - 10 < 100) {\n                _this.isIncreaseAngle = true;\n              }\n            });\n          }\n        } else {\n          for (var k = i; k < leftSideRenderPoints.length; k++) {\n            this.increaseAngle(leftSideRenderPoints[k - 1], leftSideRenderPoints[k], series, false);\n          }\n        }\n      } else {\n        if (angleChanged && previousPoint && previousPoint.isLabelUpdated) {\n          startFresh = true;\n        }\n      }\n    }\n  };\n  AccumulationDataLabel.prototype.decreaseAngle = function (currentPoint, previousPoint, series, isRightSide) {\n    if (isNullOrUndefined(currentPoint) || isNullOrUndefined(previousPoint)) {\n      return null;\n    }\n    var count = 1;\n    if (isRightSide) {\n      while (isOverlap(currentPoint.labelRegion, previousPoint.labelRegion) || !this.isVariousRadius() && !(previousPoint.labelRegion.height + previousPoint.labelRegion.y < currentPoint.labelRegion.y)) {\n        var newAngle = previousPoint.midAngle - count;\n        if (newAngle < 0) {\n          newAngle = 360 + newAngle;\n        }\n        if (newAngle <= 270 && newAngle >= 90) {\n          newAngle = 270;\n          this.isIncreaseAngle = true;\n          break;\n        }\n        this.changeLabelAngle(previousPoint, newAngle);\n        count++;\n      }\n    } else {\n      if (currentPoint.labelAngle > 270) {\n        this.changeLabelAngle(currentPoint, 270);\n        previousPoint.labelAngle = 270;\n      }\n      while (isOverlap(currentPoint.labelRegion, previousPoint.labelRegion) || !this.isVariousRadius() && currentPoint.labelRegion.y + currentPoint.labelRegion.height > previousPoint.labelRegion.y) {\n        var newAngle = previousPoint.midAngle - count;\n        if (!(newAngle <= 270 && newAngle >= 90)) {\n          newAngle = 90;\n          this.isIncreaseAngle = true;\n          break;\n        }\n        this.changeLabelAngle(previousPoint, newAngle);\n        if (isOverlap(currentPoint.labelRegion, previousPoint.labelRegion) && !series.leftSidePoints.indexOf(previousPoint) && newAngle - 1 < 90 && newAngle - 1 > 270) {\n          this.changeLabelAngle(currentPoint, currentPoint.labelAngle + 1);\n          this.arrangeLeftSidePoints(series);\n          break;\n        }\n        count++;\n      }\n    }\n  };\n  AccumulationDataLabel.prototype.increaseAngle = function (currentPoint, nextPoint, series, isRightSide) {\n    if (isNullOrUndefined(currentPoint) || isNullOrUndefined(nextPoint)) {\n      return null;\n    }\n    var count = 1;\n    if (isRightSide) {\n      while (isOverlap(currentPoint.labelRegion, nextPoint.labelRegion) || !this.isVariousRadius() && !(currentPoint.labelRegion.y + currentPoint.labelRegion.height < nextPoint.labelRegion.y)) {\n        var newAngle = nextPoint.midAngle + count;\n        if (newAngle < 270 && newAngle > 90) {\n          newAngle = 90;\n          this.isIncreaseAngle = true;\n          break;\n        }\n        this.changeLabelAngle(nextPoint, newAngle);\n        if (isOverlap(currentPoint.labelRegion, nextPoint.labelRegion) && newAngle + 1 > 90 && newAngle + 1 < 270 && this.rightSideRenderingPoints.indexOf(nextPoint) === this.rightSideRenderingPoints.length - 1) {\n          this.changeLabelAngle(currentPoint, currentPoint.labelAngle - 1);\n          nextPoint.labelRegion = nextPoint.initialLabelRegion;\n          this.arrangeRightSidePoints(series);\n          break;\n        }\n        if (count > 360) {\n          break;\n        }\n        count++;\n      }\n    } else {\n      while (isOverlap(currentPoint.labelRegion, nextPoint.labelRegion) || !this.isVariousRadius() && currentPoint.labelRegion.y < nextPoint.labelRegion.y + nextPoint.labelRegion.height) {\n        var newAngle = nextPoint.midAngle + count;\n        if (!(newAngle < 270 && newAngle > 90)) {\n          newAngle = 270;\n          this.isIncreaseAngle = false;\n          break;\n        }\n        this.changeLabelAngle(nextPoint, newAngle);\n        if (count > 360) {\n          break;\n        }\n        count++;\n      }\n    }\n  };\n  AccumulationDataLabel.prototype.changeLabelAngle = function (currentPoint, newAngle) {\n    var dataLabel = this.accumulation.series[0].dataLabel;\n    var variableR;\n    if (this.isVariousRadius()) {\n      variableR = this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], currentPoint);\n    }\n    //padding 10px is added to label radius for increasing the angle and avoid congestion.\n    var labelRadius = currentPoint.labelPosition === 'Outside' && this.accumulation.enableSmartLabels && dataLabel.position === 'Inside' ? this.radius + stringToNumber(dataLabel.connectorStyle.length || '4%', this.accumulation.pieSeriesModule.size / 2) : !this.isVariousRadius() ? this.accumulation.pieSeriesModule.labelRadius + 10 : variableR;\n    var radius = !this.isVariousRadius() ? labelRadius : variableR;\n    this.getLabelRegion(currentPoint, 'Outside', currentPoint.textSize, radius, this.marginValue, newAngle);\n    currentPoint.isLabelUpdated = 1;\n    currentPoint.labelAngle = newAngle;\n  };\n  AccumulationDataLabel.prototype.isOverlapWithPrevious = function (currentPoint, points, currentPointIndex) {\n    for (var i = 0; i < currentPointIndex; i++) {\n      if (i !== points.indexOf(currentPoint) && points[i].visible && points[i].labelVisible && points[i].labelRegion && currentPoint.labelRegion && currentPoint.labelVisible && isOverlap(currentPoint.labelRegion, points[i].labelRegion)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  AccumulationDataLabel.prototype.isOverlapWithNext = function (point, points, pointIndex) {\n    for (var i = pointIndex; i < points.length; i++) {\n      if (i !== points.indexOf(point) && points[i].visible && points[i].labelVisible && points[i].labelRegion && point.labelRegion && point.labelVisible && isOverlap(point.labelRegion, points[i].labelRegion)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  AccumulationDataLabel.prototype.skipPoints = function (currentPoint, halfsidePoints, pointIndex) {\n    if (pointIndex > 0 && (currentPoint.midAngle < 285 && currentPoint.midAngle > 255 || currentPoint.midAngle < 105 && currentPoint.midAngle > 75)) {\n      var previousPoint = halfsidePoints[pointIndex - 1];\n      var angleDiff = currentPoint.endAngle % 360 - currentPoint.startAngle % 360;\n      var prevAngleDiff = previousPoint.endAngle % 360 - previousPoint.startAngle % 360;\n      if (prevAngleDiff <= angleDiff && angleDiff < 5 && previousPoint.labelVisible) {\n        this.setPointVisibleTrue(currentPoint);\n      }\n    } else if (pointIndex > 1 && (currentPoint.midAngle < 300 && currentPoint.midAngle > 240 || currentPoint.midAngle < 120 && currentPoint.midAngle > 60)) {\n      var prevPoint = halfsidePoints[pointIndex - 1];\n      var secondPrevPoint = halfsidePoints[pointIndex - 2];\n      var angleDiff = currentPoint.endAngle % 360 - currentPoint.startAngle % 360;\n      var prevAngleDiff = prevPoint.endAngle % 360 - prevPoint.startAngle % 360;\n      var thirdAngleDiff = secondPrevPoint.endAngle % 360 - secondPrevPoint.startAngle % 360;\n      if (angleDiff < 3 && prevAngleDiff < 3 && thirdAngleDiff < 3 && prevPoint.labelVisible && currentPoint.labelVisible) {\n        this.setPointVisibleTrue(currentPoint);\n      }\n    }\n  };\n  AccumulationDataLabel.prototype.getPerpendicularDistance = function (startPoint, point) {\n    var increasedLocation;\n    var add = 10;\n    var height = add + 10 * Math.sin(point.midAngle * Math.PI / 360);\n    if (point.midAngle > 270 && point.midAngle < 360) {\n      increasedLocation = new ChartLocation(startPoint.x + height * Math.cos((360 - point.midAngle) * Math.PI / 180), startPoint.y - height * Math.sin((360 - point.midAngle) * Math.PI / 180));\n    } else if (point.midAngle > 0 && point.midAngle < 90) {\n      increasedLocation = new ChartLocation(startPoint.x + height * Math.cos(point.midAngle * Math.PI / 180), startPoint.y + height * Math.sin(point.midAngle * Math.PI / 180));\n      // eslint-disable-next-line no-dupe-else-if\n    } else if (point.midAngle > 0 && point.midAngle < 90) {\n      increasedLocation = new ChartLocation(startPoint.x - height * Math.cos((point.midAngle - 90) * Math.PI / 180), startPoint.y + height * Math.sin((point.midAngle - 90) * Math.PI / 180));\n    } else {\n      increasedLocation = new ChartLocation(startPoint.x - height * Math.cos((point.midAngle - 180) * Math.PI / 180), startPoint.y - height * Math.sin((point.midAngle - 180) * Math.PI / 180));\n    }\n    return increasedLocation;\n  };\n  return AccumulationDataLabel;\n}(AccumulationBase);\nexport { AccumulationDataLabel };","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","extend","createElement","getValue","isNullOrUndefined","animationMode","Rect","Size","PathOption","measureText","TextOption","ChartLocation","degreeToLocation","isOverlap","stringToNumber","getAngle","appendChildElement","textTrim","subtractThickness","Thickness","getElement","removeElement","RectOption","textElement","showTooltip","colorNameToHex","convertHexToColor","containsRect","textWrap","CircleOption","getSeriesFromIndex","textRender","getFontStyle","createTemplate","measureElementRect","templateAnimate","AccumulationBase","AccumulationDataLabel","_super","accumulation","_this","call","rightSideRenderingPoints","leftSideRenderingPoints","id","element","getDataLabelPosition","point","dataLabel","textSize","points","radius","isCircular","isVariousRadius","pieSeriesModule","labelRadius","getLabelRadius","visibleSeries","getLabelDistance","title","titleSize","titleStyle","themeStyle","datalabelFont","titleRect","availableSize","width","margin","top","height","getLabelRegion","position","marginValue","labelAngle","midAngle","labelPosition","enableSmartLabels","getSmartLabel","endAngle","space","location","center","getLabelLocation","y","x","labelRegion","calculateLabelCollection","argsData","template","innerRadius","padding","maxWidth","areaRect","region","label","indexOf","labelCollection","split","textOverflow","font","enableRtl","getTextSize","i","length","Math","max","circular","connectorLength","connectorStyle","previousPoint","findPreviousPoint","index","enableRotation","isOverlapping","isConnectorLineOverlapping","setOuterSmartLabel","border","type","labelRadius_1","location_1","move","e","isTouch","target","textContent","targetId","seriesIndex","parseInt","pointIndex","isNaN","text","toString","initialClipRect","clearTimeout","clearTooltip","setTimeout","visible","labelVisible","currentPoint","textTrimming","rect","size","setPointVisibileFalse","setPointVisibleTrue","textsize","setSmartLabelForSegments","getOverlappedAngle","prevPoint","textRegion","overlapHeight","previous","start","end","getEdgeOfLabel","previousstart","previousend","isLineRectangleIntersect","line1","line2","rectPoints","round","isLinesIntersect","point1","point2","point11","point12","a1","b1","c1","a2","b2","c2","delta","lies","min","first","second","angle","getConnectorPath","connector","getConnectorStartPoint","middle","endPoint","r","sliceRadius","isLabelUpdated","getPerpendicularDistance","getPolyLinePath","controlPoints","path","t","getBezierPoint","count","p0","p1","x1","y1","x2","y2","labelshape","edge","length_1","series","extraSpace","triangleSize","labelLocation","symbolLocation","labelOffset","location_2","seriesRadius","findAreaRect","left","right","bottom","renderDataLabel","parent","templateElement","redraw","datalabelGroup","renderer","createGroup","color","argsFont","getDatalabelText","format","originalText","cancel","name","fill","trigger","isTemplate","childElement","styles","calculateLabelSize","labelFormat","chart","labelText","Number","customLabelFormat","match","intl","getNumberFormat","useGrouping","useGroupingSeparator","replace","parseFloat","clientRect","isReactCallback","getTemplateSize","correctLabelRegion","drawDataLabels","degree","modifiedPoints","leftSidePoints","concat","rightSidePoints","sort","a","extendedLabelsCalculation","_i","modifiedPoints_1","finalizeDatalabels","setAttribute","dataLabelElement","location_3","setTemplateStyle","startLocation","getAttribute","textWidth","rotate","transform","drawRectangle","rx","ry","dashArray","duration","getSaturatedColor","accumulationLegendModule","legendSettings","findMaxBounds","labelBound","element_1","previousDirection","pathElement","drawPath","dataLabelClipPath","clippath","createClipPath","clipRect","pieBaseRadius","drawCircle","legendModule","legendBounds","appendChild","svgObject","style","cssText","labelColor","getLabelBackground","isBlazor","childElementCount","doTemplateAnimation","saturatedColor","theme","rgbValue","contrast","g","delay","animation","enable","animateSeries","visibility","background","getModuleName","destroy","forEach","halfSidePoints","initialLabelRegion","skipPoints","arrangeLeftSidePoints","isIncreaseAngle","arrangeRightSidePoints","startFresh","angleChanged","rightSideRenderPoints","filter","checkAngle","lastPoint","nextPoint","changeLabelAngle","isOverlapWithNext","k","increaseAngle","decreaseAngle","leftSideRenderPoints","isOverlapWithPrevious","isRightSide","newAngle","variableR","currentPointIndex","halfsidePoints","angleDiff","startAngle","prevAngleDiff","secondPrevPoint","thirdAngleDiff","startPoint","increasedLocation","add","sin","PI","cos"],"sources":["C:/Users/wiliam/Desktop/indiec-nuevo/fronted-vue/node_modules/@syncfusion/ej2-charts/src/accumulation-chart/renderer/dataLabel.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n/**\r\n * AccumulationChart DataLabel module file\r\n */\r\nimport { extend, createElement, getValue, isNullOrUndefined, animationMode } from '@syncfusion/ej2-base';\r\nimport { Rect, Size, PathOption, measureText, TextOption } from '@syncfusion/ej2-svg-base';\r\nimport { ChartLocation, degreeToLocation, isOverlap, stringToNumber, getAngle, appendChildElement } from '../../common/utils/helper';\r\nimport { textTrim, subtractThickness, Thickness, getElement } from '../../common/utils/helper';\r\nimport { removeElement, RectOption, textElement, showTooltip } from '../../common/utils/helper';\r\nimport { colorNameToHex, convertHexToColor, containsRect, textWrap, CircleOption } from '../../common/utils/helper';\r\nimport { getSeriesFromIndex } from '../model/acc-base';\r\nimport { textRender } from '../../common/model/constants';\r\nimport { getFontStyle, createTemplate, measureElementRect, templateAnimate } from '../../common/utils/helper';\r\nimport { AccumulationBase } from './accumulation-base';\r\n/**\r\n * AccumulationDataLabel module used to render `dataLabel`.\r\n */\r\nvar AccumulationDataLabel = /** @class */ (function (_super) {\r\n    __extends(AccumulationDataLabel, _super);\r\n    function AccumulationDataLabel(accumulation) {\r\n        var _this = _super.call(this, accumulation) || this;\r\n        _this.rightSideRenderingPoints = [];\r\n        _this.leftSideRenderingPoints = [];\r\n        _this.id = accumulation.element.id + '_datalabel_Series_';\r\n        return _this;\r\n    }\r\n    /**\r\n     * Method to get datalabel text location.\r\n     *\r\n     * @private\r\n     * @param {AccPoints} point - The data point for which to calculate the label text location.\r\n     * @param {AccumulationDataLabelSettingsModel} dataLabel - The data label settings for the series.\r\n     * @param {Size} textSize - The size of the text to be displayed.\r\n     * @param {AccPoints[]} points - The array of data points in the series.\r\n     * @returns {void}\r\n     */\r\n    AccumulationDataLabel.prototype.getDataLabelPosition = function (point, dataLabel, textSize, points) {\r\n        var radius = this.isCircular() ? (!this.isVariousRadius() ? this.accumulation.pieSeriesModule.labelRadius :\r\n            this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], point)) :\r\n            this.getLabelDistance(point, dataLabel);\r\n        //let radius: number = this.isCircular() ? this.labelRadius : this.getLabelDistance(point, dataLabel);\r\n        if (this.accumulation.title) {\r\n            var titleSize = measureText(this.accumulation.title, this.accumulation.titleStyle, this.accumulation.themeStyle.datalabelFont);\r\n            this.titleRect = new Rect(this.accumulation.availableSize.width / 2 - titleSize.width / 2, this.accumulation.margin.top, titleSize.width, titleSize.height);\r\n        }\r\n        this.getLabelRegion(point, dataLabel.position, textSize, radius, this.marginValue);\r\n        point.labelAngle = point.midAngle;\r\n        point.labelPosition = dataLabel.position;\r\n        if (this.accumulation.enableSmartLabels) {\r\n            this.getSmartLabel(point, dataLabel, textSize, points);\r\n        }\r\n    };\r\n    /**\r\n     * Method to get datalabel bound.\r\n     */\r\n    AccumulationDataLabel.prototype.getLabelRegion = function (point, position, textSize, labelRadius, margin, endAngle) {\r\n        if (endAngle === void 0) { endAngle = 0; }\r\n        var labelAngle = endAngle || point.midAngle;\r\n        var space = 20;\r\n        var location = degreeToLocation(labelAngle, labelRadius, this.isCircular() ? this.center :\r\n            this.getLabelLocation(point, position));\r\n        location.y = (position === 'Inside') ? (location.y - textSize.height / 2) : location.y;\r\n        location.x = (position === 'Inside') ? (location.x - textSize.width / 2) : location.x;\r\n        point.labelRegion = new Rect(location.x, location.y, textSize.width + (margin * 2), textSize.height + (margin * 2));\r\n        if (position === 'Outside') {\r\n            point.labelRegion.y -= point.labelRegion.height / 2;\r\n            if (labelAngle >= 90 && labelAngle <= 270) {\r\n                point.labelRegion.x -= (point.labelRegion.width + space);\r\n            }\r\n            else {\r\n                point.labelRegion.x += space;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Method to get data label collection.\r\n     *\r\n     * @param {AccPoints} point - The data point for which to calculate the label collection.\r\n     * @param {AccumulationDataLabelSettingsModel} dataLabel - The data label settings for the series.\r\n     * @returns {void}\r\n     */\r\n    AccumulationDataLabel.prototype.calculateLabelCollection = function (point, dataLabel) {\r\n        if (point.argsData.template !== null) {\r\n            return null;\r\n        }\r\n        var position = point.labelPosition || dataLabel.position;\r\n        var labelRadius = this.isCircular() ? (!this.isVariousRadius() ? this.accumulation.pieSeriesModule.labelRadius :\r\n            this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], point)) :\r\n            this.getLabelDistance(point, dataLabel);\r\n        var radius = (!this.isVariousRadius() ?\r\n            (this.accumulation.pieSeriesModule.radius - this.accumulation.pieSeriesModule.innerRadius) :\r\n            this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], point));\r\n        var location = degreeToLocation(point.midAngle, labelRadius, this.isCircular() ? this.center :\r\n            this.getLabelLocation(point, position));\r\n        var padding = 20;\r\n        var maxWidth = dataLabel.maxWidth;\r\n        if (!maxWidth) {\r\n            if (position === 'Outside') {\r\n                maxWidth = this.isCircular() ? (location.x >= this.center.x) ? (this.areaRect.x + this.areaRect.width - location.x) :\r\n                    (location.x - this.areaRect.x) : (location.x >= point.region.x) ?\r\n                    (this.areaRect.x + this.areaRect.width - location.x) : (location.x - this.areaRect.x);\r\n            }\r\n            else {\r\n                maxWidth = this.isCircular() ? (radius - padding) : point.region.width;\r\n            }\r\n        }\r\n        if ((point.label.indexOf('<br>') !== -1)) {\r\n            point.labelCollection = point.label.split('<br>');\r\n        }\r\n        else if (dataLabel.textWrap === 'Normal' && dataLabel.textOverflow === 'Ellipsis') {\r\n            point.labelCollection[0] = textTrim(maxWidth, point.label, point.argsData.font, this.accumulation.enableRtl, this.accumulation.themeStyle.datalabelFont);\r\n        }\r\n        else if (dataLabel.textWrap === 'Wrap' || dataLabel.textWrap === 'AnyWhere') {\r\n            point.labelCollection = textWrap(point.label, maxWidth, point.argsData.font, this.accumulation.enableRtl, dataLabel.textWrap === 'AnyWhere', dataLabel.textOverflow === 'Clip', this.accumulation.themeStyle.datalabelFont);\r\n        }\r\n        else {\r\n            point.labelCollection[0] = point.label;\r\n        }\r\n    };\r\n    /**\r\n     * To calculate label collection text size.\r\n     *\r\n     * @param {string[]} labelCollection - The collection of label texts.\r\n     * @param {AccumulationDataLabelSettingsModel} dataLabel - The data label settings for the series.\r\n     * @returns {Size} - The size of the label text collection.\r\n     */\r\n    AccumulationDataLabel.prototype.getTextSize = function (labelCollection, dataLabel) {\r\n        var height = 0;\r\n        var font = dataLabel.font;\r\n        var width = dataLabel.maxWidth ? dataLabel.maxWidth : 0;\r\n        var textSize;\r\n        for (var i = 0; i < labelCollection.length; i++) {\r\n            textSize = measureText(labelCollection[i], font, this.accumulation.themeStyle.datalabelFont);\r\n            width = Math.max(textSize.width, width);\r\n            height += textSize.height;\r\n        }\r\n        if (dataLabel.textOverflow === 'Clip' && dataLabel.textWrap !== 'Normal' && dataLabel.maxWidth) {\r\n            width = dataLabel.maxWidth;\r\n        }\r\n        return (new Size(width, height));\r\n    };\r\n    /**\r\n     * Method to get datalabel smart position.\r\n     *\r\n     * @param {AccPoints} point - The data point for which to calculate the label smart position.\r\n     * @param {AccumulationDataLabelSettingsModel} dataLabel - The data label settings for the series.\r\n     * @param {Size} textSize - The size of the text.\r\n     * @param {AccPoints[]} points - The collection of data points.\r\n     * @returns {void}\r\n     */\r\n    AccumulationDataLabel.prototype.getSmartLabel = function (point, dataLabel, textSize, points) {\r\n        var circular = this.isCircular();\r\n        var labelRadius = circular ? this.radius : this.getLabelDistance(point, dataLabel);\r\n        var connectorLength = circular ? (dataLabel.connectorStyle.length || '4%') :\r\n            '0px';\r\n        labelRadius += stringToNumber(connectorLength, labelRadius);\r\n        var previousPoint = this.findPreviousPoint(points, point.index, point.labelPosition);\r\n        if (dataLabel.position === 'Inside') {\r\n            // `4` is padding adding to height and width of label region.\r\n            point.labelRegion.height -= 4;\r\n            point.labelRegion.width -= 4;\r\n            if (previousPoint && previousPoint.labelRegion && !dataLabel.enableRotation &&\r\n                (isOverlap(point.labelRegion, previousPoint.labelRegion)\r\n                    || this.isOverlapping(point, points)) || !circular && !containsRect(point.region, point.labelRegion)) {\r\n                point.labelPosition = 'Outside';\r\n                if (!circular) {\r\n                    labelRadius = this.getLabelDistance(point, dataLabel);\r\n                }\r\n                this.calculateLabelCollection(point, dataLabel);\r\n                textSize = this.getTextSize(point.labelCollection, dataLabel);\r\n                textSize.height += 4; // 4 for calculation with padding for smart label shape\r\n                textSize.width += 4;\r\n                this.getLabelRegion(point, point.labelPosition, textSize, labelRadius, this.marginValue);\r\n                previousPoint = this.findPreviousPoint(points, point.index, point.labelPosition);\r\n                if (previousPoint && (isOverlap(point.labelRegion, previousPoint.labelRegion) ||\r\n                    this.isConnectorLineOverlapping(point, previousPoint))) {\r\n                    this.setOuterSmartLabel(previousPoint, point, dataLabel.border.width, labelRadius, textSize, this.marginValue);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (previousPoint && previousPoint.labelRegion && (isOverlap(point.labelRegion, previousPoint.labelRegion)\r\n                || this.isOverlapping(point, points) || this.isConnectorLineOverlapping(point, previousPoint))) {\r\n                this.setOuterSmartLabel(previousPoint, point, dataLabel.border.width, labelRadius, textSize, this.marginValue);\r\n            }\r\n        }\r\n        if (this.isOverlapping(point, points) && (this.accumulation.type === 'Pyramid' || this.accumulation.type === 'Funnel')) {\r\n            var position = 'OutsideLeft';\r\n            var space = 20;\r\n            var labelAngle = point.midAngle || 0;\r\n            var labelRadius_1 = circular ? this.radius : this.getLabelDistance(point, dataLabel);\r\n            var location_1 = degreeToLocation(labelAngle, -labelRadius_1, this.isCircular() ? this.center :\r\n                this.getLabelLocation(point, position));\r\n            point.labelRegion = new Rect(location_1.x, location_1.y, textSize.width + (this.marginValue * 2), textSize.height + (this.marginValue * 2));\r\n            point.labelRegion.y -= point.labelRegion.height / 2;\r\n            point.labelRegion.x = point.labelRegion.x - space - point.labelRegion.width;\r\n            if (previousPoint && previousPoint.labelRegion && (isOverlap(point.labelRegion, previousPoint.labelRegion)\r\n                || this.isOverlapping(point, points) || this.isConnectorLineOverlapping(point, previousPoint))) {\r\n                this.setOuterSmartLabel(previousPoint, point, dataLabel.border.width, labelRadius_1, textSize, this.marginValue);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * To find trimmed datalabel tooltip needed.\r\n     *\r\n     * @param {Event} e - The move event.\r\n     * @param {number} x - The x-coordinate.\r\n     * @param {number} y - The y-coordinate.\r\n     * @param {boolean} isTouch - Indicates if the interaction is touch-based.\r\n     * @returns {void}\r\n     * @private\r\n     */\r\n    AccumulationDataLabel.prototype.move = function (e, x, y, isTouch) {\r\n        var _this = this;\r\n        if (e.target.textContent.indexOf('...') > -1) {\r\n            var targetId = e.target.id.split(this.id);\r\n            if (targetId.length === 2) {\r\n                var seriesIndex = parseInt(targetId[1].split('_text_')[0], 10);\r\n                var pointIndex = parseInt(targetId[1].split('_text_')[1], 10);\r\n                if (!isNaN(seriesIndex) && !isNaN(pointIndex)) {\r\n                    if (isTouch) {\r\n                        removeElement(this.accumulation.element.id + '_EJ2_Datalabel_Tooltip');\r\n                    }\r\n                    var point = getSeriesFromIndex(seriesIndex, (this.accumulation).visibleSeries).points[pointIndex];\r\n                    showTooltip(point.text || point.y.toString(), x, y, this.areaRect.width, this.accumulation.element.id + '_EJ2_Datalabel_Tooltip', getElement(this.accumulation.element.id + '_Secondary_Element'), null, null, this.accumulation.initialClipRect);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            removeElement(this.accumulation.element.id + '_EJ2_Datalabel_Tooltip');\r\n        }\r\n        if (isTouch) {\r\n            clearTimeout(this.clearTooltip);\r\n            this.clearTooltip = +setTimeout(function () { removeElement(_this.accumulation.element.id + '_EJ2_Datalabel_Tooltip'); }, 1000);\r\n        }\r\n    };\r\n    /**\r\n     * To find previous valid label point.\r\n     *\r\n     * @param {AccPoints[]} points - The array of accumulation points.\r\n     * @param {number} index - The index of the current point.\r\n     * @param {AccumulationLabelPosition} position - The position of the label.\r\n     * @returns {AccPoints} - Find the previous value of accumulation point.\r\n     */\r\n    AccumulationDataLabel.prototype.findPreviousPoint = function (points, index, position) {\r\n        var point = points[0];\r\n        for (var i = index - 1; i >= 0; i--) {\r\n            point = points[i];\r\n            if (point.visible && point.labelVisible && point.labelRegion && point.labelPosition === position) {\r\n                return point;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * To find current point datalabel is overlapping with other points.\r\n     *\r\n     * @param {AccPoints} currentPoint - The current point.\r\n     * @param {AccPoints[]} points - The array of accumulation points.\r\n     * @returns {boolean} - It returns boolean value of overlapping.\r\n     */\r\n    AccumulationDataLabel.prototype.isOverlapping = function (currentPoint, points) {\r\n        for (var i = currentPoint.index - 1; i >= 0; i--) {\r\n            if (points[i].visible && points[i].labelVisible &&\r\n                points[i].labelRegion && currentPoint.labelRegion &&\r\n                currentPoint.labelVisible && isOverlap(currentPoint.labelRegion, points[i].labelRegion)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * To get text trimmed while exceeds the accumulation chart area.\r\n     *\r\n     * @param {AccPoints} point - The accumulation point.\r\n     * @param {Rect} rect - The area of the accumulation chart.\r\n     * @param {FontModel} font - The font settings.\r\n     * @param {string} position - The position of the data label.\r\n     * @param {AccumulationDataLabelSettingsModel} dataLabel - The data label settings.\r\n     * @returns {void}\r\n     */\r\n    AccumulationDataLabel.prototype.textTrimming = function (point, rect, font, position, dataLabel) {\r\n        if (isOverlap(point.labelRegion, rect)) {\r\n            var size = point.labelRegion.width;\r\n            if (position === 'Right') {\r\n                size = rect.x - point.labelRegion.x;\r\n            }\r\n            else if (position === 'Left') {\r\n                size = point.labelRegion.x - (rect.x + rect.width);\r\n                if (size < 0) {\r\n                    size += point.labelRegion.width;\r\n                    point.labelRegion.x = rect.x + rect.width;\r\n                }\r\n            }\r\n            else if (position === 'InsideRight') {\r\n                size = (rect.x + rect.width) - point.labelRegion.x;\r\n            }\r\n            else if (position === 'InsideLeft') {\r\n                size = (point.labelRegion.x + point.labelRegion.width) - rect.x;\r\n                if (size < point.labelRegion.width) {\r\n                    point.labelRegion.x = rect.x;\r\n                }\r\n            }\r\n            else if (this.accumulation.enableSmartLabels) {\r\n                this.setPointVisibileFalse(point);\r\n            }\r\n            if (point.labelVisible && point.labelRegion) {\r\n                if ((point.label.indexOf('<br>') !== -1)) {\r\n                    point.labelCollection = point.label.split('<br>');\r\n                }\r\n                else if (size < point.labelRegion.width) {\r\n                    if (dataLabel.textWrap === 'Normal' && dataLabel.textOverflow === 'Ellipsis') {\r\n                        point.labelCollection[0] = textTrim(size - (this.marginValue * 2), point.label, font, this.accumulation.enableRtl, this.accumulation.themeStyle.datalabelFont);\r\n                    }\r\n                    else if (dataLabel.textWrap === 'Wrap' || dataLabel.textWrap === 'AnyWhere') {\r\n                        point.labelCollection = textWrap(point.label, size - (this.marginValue * 2), font, this.accumulation.enableRtl, dataLabel.textWrap === 'AnyWhere', dataLabel.textOverflow === 'Clip', this.accumulation.themeStyle.datalabelFont);\r\n                    }\r\n                    point.labelRegion.width = size;\r\n                }\r\n                for (var i = 0; i < point.labelCollection.length; i++) {\r\n                    if (point.labelCollection[i].length === 3 && point.labelCollection[i].indexOf('...') > -1) {\r\n                        this.setPointVisibileFalse(point);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * To set point label visible and region to disable.\r\n     *\r\n     * @param {AccPoints} point - The accumulation point.\r\n     * @returns {void}\r\n     */\r\n    AccumulationDataLabel.prototype.setPointVisibileFalse = function (point) {\r\n        point.labelVisible = false;\r\n        point.labelRegion = null;\r\n    };\r\n    /**\r\n     * To set point label visible to enable.\r\n     *\r\n     * @param {AccPoints} point - The accumulation point.\r\n     * @returns {void}\r\n     */\r\n    AccumulationDataLabel.prototype.setPointVisibleTrue = function (point) {\r\n        point.labelVisible = true;\r\n    };\r\n    /**\r\n     * To set datalabel angle position for outside labels.\r\n     *\r\n     * @param {AccPoints} previousPoint - The previous accumulation point.\r\n     * @param {AccPoints} point - The accumulation point.\r\n     * @param {number} border - The border size.\r\n     * @param {number} labelRadius - The radius for the labels.\r\n     * @param {Size} textsize - The size of the labels.\r\n     * @param {number} margin - The margin value.\r\n     * @returns {void}\r\n     */\r\n    AccumulationDataLabel.prototype.setOuterSmartLabel = function (previousPoint, point, border, labelRadius, textsize, margin) {\r\n        if (!this.isCircular()) {\r\n            this.setSmartLabelForSegments(point, previousPoint);\r\n        }\r\n        else {\r\n            var labelAngle = this.getOverlappedAngle(previousPoint.labelRegion, point.labelRegion, point.midAngle, border * 2);\r\n            this.getLabelRegion(point, 'Outside', textsize, labelRadius, margin, labelAngle);\r\n            if (labelAngle > point.endAngle) {\r\n                labelAngle = point.midAngle;\r\n                //this.setPointVisibileFalse(point);\r\n            }\r\n            point.labelAngle = labelAngle;\r\n            while (point.labelVisible && (isOverlap(previousPoint.labelRegion, point.labelRegion) || labelAngle <= previousPoint.labelAngle\r\n                || labelAngle <= point.midAngle * 0.9 || this.isConnectorLineOverlapping(point, previousPoint))) {\r\n                if (labelAngle > point.endAngle) {\r\n                    //this.setPointVisibileFalse(point);\r\n                    break;\r\n                }\r\n                point.labelAngle = labelAngle;\r\n                this.getLabelRegion(point, 'Outside', textsize, labelRadius, margin, labelAngle);\r\n                labelAngle += 0.1;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Sets smart label positions for funnel and pyramid series.\r\n     *\r\n     * @param {AccPoints} point - The accumulation point.\r\n     * @param {AccPoints} prevPoint - The previous point.\r\n     * @returns {void} setSmartLabelForSegments.\r\n     */\r\n    AccumulationDataLabel.prototype.setSmartLabelForSegments = function (point, prevPoint) {\r\n        var textRegion = point.labelRegion;\r\n        //let overlapWidth: number = prevPoint.labelRegion.x + prevPoint.labelRegion.width - textRegion.x;\r\n        var overlapHeight = this.accumulation.type === 'Funnel' ?\r\n            prevPoint.labelRegion.y - (textRegion.y + textRegion.height) :\r\n            point.labelRegion.y - (prevPoint.labelRegion.y + prevPoint.labelRegion.height);\r\n        if (overlapHeight < 0) {\r\n            point.labelRegion.y += this.accumulation.type === 'Funnel' ? overlapHeight : -overlapHeight;\r\n        }\r\n    };\r\n    /**\r\n     * To find connector line overlapping.\r\n     *\r\n     * @param {AccPoints} point - The accumulation point.\r\n     * @param {AccPoints} previous - The previous point.\r\n     * @returns {boolean} - To find connector line overlapping or not.\r\n     */\r\n    AccumulationDataLabel.prototype.isConnectorLineOverlapping = function (point, previous) {\r\n        var position;\r\n        if (!this.isCircular() && point.labelRegion.x < point.region.x) {\r\n            position = 'outsideLeft';\r\n        }\r\n        var start = this.getLabelLocation(point, position);\r\n        var end = new ChartLocation(0, 0);\r\n        this.getEdgeOfLabel(point.labelRegion, point.labelAngle, end, 0, point);\r\n        var previousstart = this.getLabelLocation(previous);\r\n        var previousend = new ChartLocation(0, 0);\r\n        this.getEdgeOfLabel(previous.labelRegion, previous.labelAngle, previousend, 0, point);\r\n        return this.isLineRectangleIntersect(start, end, point.labelRegion) ||\r\n            this.isLineRectangleIntersect(start, end, previous.labelRegion) ||\r\n            this.isLineRectangleIntersect(previousstart, previousend, point.labelRegion);\r\n    };\r\n    /**\r\n     * To find two rectangle intersect.\r\n     *\r\n     * @param {ChartLocation} line1 - The first line.\r\n     * @param {ChartLocation} line2 - The second line.\r\n     * @param {Rect} rect - The rectangle to check against.\r\n     * @returns {boolean} - To find line rectangle intersect value.\r\n     */\r\n    AccumulationDataLabel.prototype.isLineRectangleIntersect = function (line1, line2, rect) {\r\n        var rectPoints = [\r\n            new ChartLocation(Math.round(rect.x), Math.round(rect.y)),\r\n            new ChartLocation(Math.round((rect.x + rect.width)), Math.round(rect.y)),\r\n            new ChartLocation(Math.round((rect.x + rect.width)), Math.round((rect.y + rect.height))),\r\n            new ChartLocation(Math.round(rect.x), Math.round((rect.y + rect.height)))\r\n        ];\r\n        line1.x = Math.round(line1.x);\r\n        line1.y = Math.round(line1.y);\r\n        line2.x = Math.round(line2.x);\r\n        line2.y = Math.round(line2.y);\r\n        for (var i = 0; i < rectPoints.length; i++) {\r\n            if (this.isLinesIntersect(line1, line2, rectPoints[i], rectPoints[(i + 1) % rectPoints.length])) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * To find two line intersect.\r\n     *\r\n     * @param {ChartLocation} point1 - The first point of the first line.\r\n     * @param {ChartLocation} point2 - The second point of the first line.\r\n     * @param {ChartLocation} point11 - The first point of the second line.\r\n     * @param {ChartLocation} point12 - The second point of the second line.\r\n     * @returns {boolean} - To find line intersect or not.\r\n     */\r\n    AccumulationDataLabel.prototype.isLinesIntersect = function (point1, point2, point11, point12) {\r\n        var a1 = point2.y - point1.y;\r\n        var b1 = point1.x - point2.x;\r\n        var c1 = a1 * point1.x + b1 * point1.y;\r\n        var a2 = point12.y - point11.y;\r\n        var b2 = point11.x - point12.x;\r\n        var c2 = a2 * point11.x + b2 * point11.y;\r\n        var delta = a1 * b2 - a2 * b1;\r\n        if (delta !== 0) {\r\n            var x = (b2 * c1 - b1 * c2) / delta;\r\n            var y = (a1 * c2 - a2 * c1) / delta;\r\n            var lies = Math.min(point1.x, point2.x) <= x && x <= Math.max(point1.x, point2.x);\r\n            lies = lies && Math.min(point1.y, point2.y) <= y && y <= Math.max(point1.y, point2.y);\r\n            lies = lies && Math.min(point11.x, point12.x) <= x && x <= Math.max(point11.x, point12.x);\r\n            lies = lies && Math.min(point11.y, point12.y) <= y && y <= Math.max(point11.y, point12.y);\r\n            return lies;\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * To get two rectangle overlapping angles.\r\n     *\r\n     * @param {Rect} first - The first rectangle.\r\n     * @param {Rect} second - The second rectangle.\r\n     * @param {number} angle - The angle.\r\n     * @param {number} padding - The padding.\r\n     * @returns {number} - Get overlapped angle.\r\n     */\r\n    AccumulationDataLabel.prototype.getOverlappedAngle = function (first, second, angle, padding) {\r\n        var x = first.x;\r\n        if (angle >= 90 && angle <= 270) {\r\n            second.y = first.y - (padding + second.height / 2);\r\n            x = first.x + first.width;\r\n        }\r\n        else {\r\n            second.y = first.y + first.height + padding;\r\n        }\r\n        return getAngle(this.center, new ChartLocation(x, second.y));\r\n    };\r\n    /**\r\n     * To get connector line path.\r\n     *\r\n     * @param {Rect} label - The label.\r\n     * @param {AccPoints} point - The accumulation point.\r\n     * @param {AccumulationDataLabelSettingsModel} dataLabel - The data label settings.\r\n     * @param {number} end - The end.\r\n     * @returns {string} - Get connector line path.\r\n     */\r\n    AccumulationDataLabel.prototype.getConnectorPath = function (label, point, dataLabel, end) {\r\n        if (end === void 0) { end = 0; }\r\n        var connector = dataLabel.connectorStyle;\r\n        var labelRadius = this.isCircular() ? (!this.isVariousRadius() ? this.labelRadius :\r\n            this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], point)) :\r\n            this.getLabelDistance(point, dataLabel);\r\n        //let labelRadius: number = this.isCircular() ? this.labelRadius : this.getLabelDistance(point, dataLabel);\r\n        var start = this.getConnectorStartPoint(point, connector);\r\n        var labelAngle = this.accumulation.enableSmartLabels ? point.midAngle : end || point.midAngle;\r\n        var middle = new ChartLocation(0, 0);\r\n        var endPoint = this.getEdgeOfLabel(label, labelAngle, middle, connector.width, point);\r\n        if (connector.type === 'Curve') {\r\n            if (this.isCircular()) {\r\n                var r = labelRadius - (this.isVariousRadius() ? stringToNumber(point.sliceRadius, this.accumulation.pieSeriesModule.size / 2) :\r\n                    this.radius);\r\n                //let r: number = labelRadius - this.radius;\r\n                if (point.isLabelUpdated) {\r\n                    middle = this.getPerpendicularDistance(start, point);\r\n                }\r\n                else {\r\n                    middle = degreeToLocation(labelAngle, labelRadius - (r / 2), this.center);\r\n                    if (point.labelPosition === 'Outside' && dataLabel.position === 'Inside') {\r\n                        middle = degreeToLocation(labelAngle, labelRadius - r * 1.25, this.center);\r\n                    }\r\n                }\r\n                return 'M ' + start.x + ' ' + start.y + ' Q ' + middle.x + ' ' + middle.y + ' ' + endPoint.x + ' ' + endPoint.y;\r\n            }\r\n            else {\r\n                return this.getPolyLinePath(start, endPoint);\r\n            }\r\n        }\r\n        else {\r\n            return 'M ' + start.x + ' ' + start.y + ' L ' + middle.x + ' ' + middle.y + ' L ' + endPoint.x + ' ' + endPoint.y;\r\n        }\r\n    };\r\n    /**\r\n     * Finds the curved path for funnel/pyramid data label connectors.\r\n     *\r\n     * @param {ChartLocation} start - The start location.\r\n     * @param {ChartLocation} end - The end location.\r\n     * @returns {string} - Get poly line path.\r\n     */\r\n    AccumulationDataLabel.prototype.getPolyLinePath = function (start, end) {\r\n        var controlPoints = [start, end];\r\n        if (start.y === end.y) {\r\n            return 'M ' + start.x + ' ' + start.y + ' L ' + end.x + ' ' + end.y;\r\n        }\r\n        var path = 'M';\r\n        for (var i = 0; i <= 16; i++) {\r\n            var t = i / 16;\r\n            var points = this.getBezierPoint(t, controlPoints, 0, 2);\r\n            path += points.x + ',' + points.y;\r\n            if (i !== 16) {\r\n                path += ' L';\r\n            }\r\n        }\r\n        return path;\r\n    };\r\n    /**\r\n     * Finds the bezier point for funnel/pyramid data label connectors.\r\n     *\r\n     * @param {number} t - The parameter value.\r\n     * @param {ChartLocation[]} controlPoints - The control points for the bezier point.\r\n     * @param {number} index - The index of the point.\r\n     * @param {number} count - The total count of points.\r\n     * @returns {ChartLocation} - Get bazier point.\r\n     */\r\n    AccumulationDataLabel.prototype.getBezierPoint = function (t, controlPoints, index, count) {\r\n        if (count === 1) {\r\n            return controlPoints[index];\r\n        }\r\n        var p0 = this.getBezierPoint(t, controlPoints, index, count - 1);\r\n        var p1 = this.getBezierPoint(t, controlPoints, index + 1, count - 1);\r\n        var x = (p0.x) ? p0.x : p0.x;\r\n        var y = (p0.y) ? p0.y : p0.y;\r\n        var x1 = (p1.x) ? p1.x : p1.x;\r\n        var y1 = (p1.y) ? p1.y : p1.y;\r\n        var x2 = (1 - t) * x + t * x1;\r\n        var y2 = (1 - t) * y + t * y1;\r\n        if (p0.x) {\r\n            return { x: x2, y: y2 };\r\n        }\r\n        else {\r\n            return { x: x2, y: y2 };\r\n        }\r\n    };\r\n    /**\r\n     * To get label edges based on the center and label rect position.\r\n     *\r\n     * @param {Rect} labelshape - The label shape.\r\n     * @param {number} angle - The angle of the label.\r\n     * @param {ChartLocation} middle - The middle point of the label.\r\n     * @param {number} border - The border value.\r\n     * @param {AccPoints} point - The accumulation point.\r\n     * @returns {ChartLocation} - Get label edge value.\r\n     */\r\n    AccumulationDataLabel.prototype.getEdgeOfLabel = function (labelshape, angle, middle, border, point) {\r\n        if (border === void 0) { border = 1; }\r\n        var edge = new ChartLocation(labelshape.x, labelshape.y);\r\n        var space = 10;\r\n        if (angle >= 90 && angle <= 270) {\r\n            edge.x += labelshape.width + border / 2 + space;\r\n            edge.y += labelshape.height / 2;\r\n            middle.x = edge.x + 10;\r\n            middle.y = edge.y;\r\n        }\r\n        else if (point && point.region && point.region.x > point.labelRegion.x) {\r\n            edge.x += border * 2 + labelshape.width + space;\r\n            edge.y += labelshape.height / 2;\r\n            middle.x = edge.x + 10;\r\n            middle.y = edge.y;\r\n        }\r\n        else {\r\n            edge.x -= space - border / 2;\r\n            edge.y += labelshape.height / 2;\r\n            middle.x = edge.x - 10;\r\n            middle.y = edge.y;\r\n        }\r\n        return edge;\r\n    };\r\n    /**\r\n     * Finds the distance between the label position and the edge/center of the funnel/pyramid.\r\n     *\r\n     * @param {AccPoints} point - The accumulation point.\r\n     * @param {AccumulationDataLabelSettingsModel} dataLabel - The data label settings.\r\n     * @returns {number} - Get label distance.\r\n     */\r\n    AccumulationDataLabel.prototype.getLabelDistance = function (point, dataLabel) {\r\n        if (point.labelPosition && dataLabel.position !== point.labelPosition || (dataLabel.connectorStyle.length && dataLabel.position === 'Outside')) {\r\n            var length_1 = stringToNumber(dataLabel.connectorStyle.length || '70px', this.accumulation.initialClipRect.width);\r\n            if (length_1 < this.accumulation.initialClipRect.width) {\r\n                return length_1;\r\n            }\r\n        }\r\n        var position = point.labelPosition || dataLabel.position;\r\n        var series = this.accumulation.visibleSeries[0];\r\n        var extraSpace = (this.accumulation.initialClipRect.width - series.triangleSize.width) / 2;\r\n        var labelLocation;\r\n        switch (position) {\r\n            case 'Inside':\r\n                return 0;\r\n            case 'Outside':\r\n                labelLocation = point.symbolLocation.x + point.labelOffset.x;\r\n                return this.accumulation.initialClipRect.width - labelLocation - extraSpace;\r\n        }\r\n    };\r\n    /**\r\n     * Finds the label position / beginning of the connector(ouside funnel labels).\r\n     *\r\n     * @param {AccPoints} point - The accumulation point.\r\n     * @param {AccumulationLabelPosition | string} position - The data label position.\r\n     * @returns {ChartLocation} - Get label location.\r\n     */\r\n    AccumulationDataLabel.prototype.getLabelLocation = function (point, position) {\r\n        if (position === void 0) { position = 'Outside'; }\r\n        if (this.accumulation.type !== 'Pie') {\r\n            position = position === 'OutsideLeft' ? 'OutsideLeft' : point.labelPosition || position;\r\n            var location_2 = {\r\n                x: point.symbolLocation.x,\r\n                y: point.symbolLocation.y - point.labelOffset.y\r\n            };\r\n            switch (position) {\r\n                case 'Inside':\r\n                    location_2.y = point.region.y + point.region.height / 2;\r\n                    break;\r\n                case 'Outside':\r\n                    location_2.x += point.labelOffset.x;\r\n                    break;\r\n                case 'OutsideLeft':\r\n                    location_2.x -= point.labelOffset.x;\r\n            }\r\n            return location_2;\r\n        }\r\n        else {\r\n            //return degreeToLocation(point.midAngle, this.radius, this.center);\r\n            return degreeToLocation(point.midAngle, (this.isVariousRadius() ? stringToNumber(point.sliceRadius, this.accumulation.pieSeriesModule.seriesRadius) :\r\n                this.radius), this.center);\r\n        }\r\n    };\r\n    /**\r\n     * Finds the beginning of connector line.\r\n     *\r\n     * @param {AccPoints} point - The accumulation point.\r\n     * @param {ConnectorModel} connector - The connector line.\r\n     * @returns {ChartLocation} - Staring point of connector line.\r\n     */\r\n    AccumulationDataLabel.prototype.getConnectorStartPoint = function (point, connector) {\r\n        // return this.isCircular() ? degreeToLocation(point.midAngle, this.radius - connector.width, this.center) :\r\n        //     this.getLabelLocation(point);\r\n        var position;\r\n        if (!this.isCircular() && point.region.x > point.labelRegion.x) {\r\n            position = 'OutsideLeft';\r\n        }\r\n        return this.isCircular() ? degreeToLocation(point.midAngle, (this.isVariousRadius() ? stringToNumber(point.sliceRadius, this.accumulation.pieSeriesModule.seriesRadius) :\r\n            this.radius) - connector.width, this.center) : this.getLabelLocation(point, position);\r\n    };\r\n    /**\r\n     * To find area rect based on margin, available size.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    AccumulationDataLabel.prototype.findAreaRect = function () {\r\n        this.areaRect = new Rect(0, 0, this.accumulation.availableSize.width, this.accumulation.availableSize.height);\r\n        var margin = this.accumulation.margin;\r\n        subtractThickness(this.areaRect, new Thickness(margin.left, margin.right, margin.top, margin.bottom));\r\n    };\r\n    /**\r\n     * To render the data labels from series points.\r\n     *\r\n     * @param {AccPoints} point - The point for which to render the data label.\r\n     * @param {AccumulationDataLabelSettingsModel} dataLabel - The settings for the data labels.\r\n     * @param {Element} parent - The parent element to which the data labels are appended.\r\n     * @param {AccPoints[]} points - The collection of points in the series.\r\n     * @param {number} series - The index of the series.\r\n     * @param {HTMLElement} templateElement - The template element for the data label.\r\n     * @param {boolean} redraw - Indicates whether the data labels are being redrawn.\r\n     * @returns {void}\r\n     */\r\n    AccumulationDataLabel.prototype.renderDataLabel = function (point, dataLabel, parent, points, series, templateElement, redraw) {\r\n        var id = this.accumulation.element.id + '_datalabel_Series_' + series + '_';\r\n        var datalabelGroup = this.accumulation.renderer.createGroup({ id: id + 'g_' + point.index });\r\n        var border = { width: dataLabel.border.width, color: dataLabel.border.color };\r\n        var argsFont = (extend({}, getValue('properties', dataLabel.font), null, true));\r\n        point.label = this.getDatalabelText(dataLabel.format, this.accumulation, point.originalText || point.y.toString());\r\n        var argsData = {\r\n            cancel: false, name: textRender, series: this.accumulation.visibleSeries[0], point: point,\r\n            text: point.label, border: border, color: dataLabel.fill, template: dataLabel.template, font: argsFont\r\n        };\r\n        this.accumulation.trigger(textRender, argsData);\r\n        point.argsData = argsData;\r\n        var isTemplate = argsData.template !== null;\r\n        point.labelVisible = !argsData.cancel;\r\n        point.text = point.label = argsData.text;\r\n        point.labelCollection = [];\r\n        this.marginValue = argsData.border.width ? (5 + argsData.border.width) : 1;\r\n        var childElement = createElement('div', {\r\n            id: this.accumulation.element.id + '_Series_' + 0 + '_DataLabel_' + point.index,\r\n            styles: 'position: absolute;background-color:' + argsData.color + ';' +\r\n                getFontStyle(dataLabel.font, this.accumulation.themeStyle.datalabelFont) + ';border:' + argsData.border.width + 'px solid ' + argsData.border.color + ';'\r\n        });\r\n        this.calculateLabelSize(isTemplate, childElement, point, points, argsData, datalabelGroup, id, dataLabel, redraw);\r\n    };\r\n    AccumulationDataLabel.prototype.getDatalabelText = function (labelFormat, chart, labelText) {\r\n        if (Number(labelText)) {\r\n            var customLabelFormat = labelFormat.match('{value}') !== null;\r\n            var format = chart.intl.getNumberFormat({\r\n                format: customLabelFormat ? '' : labelFormat,\r\n                useGrouping: chart.useGroupingSeparator\r\n            });\r\n            labelText = customLabelFormat ? labelFormat.replace('{value}', format(parseFloat(labelText))) : format(parseFloat(labelText));\r\n        }\r\n        return labelText;\r\n    };\r\n    /**\r\n     * To calculate label size.\r\n     *\r\n     * @param {boolean} isTemplate - Indicates whether the label is a template.\r\n     * @param {HTMLElement} childElement - The child element of the label.\r\n     * @param {AccPoints} point - The point associated with the label.\r\n     * @param {AccPoints[]} points - The collection of points.\r\n     * @param {IAccTextRenderEventArgs} argsData - The arguments data for text rendering.\r\n     * @param {Element} datalabelGroup - The group element for data labels.\r\n     * @param {string} id - The id of the label.\r\n     * @param {AccumulationDataLabelSettingsModel} dataLabel - The settings for the data labels.\r\n     * @param {boolean} redraw - Indicates whether the labels are being redrawn.\r\n     * @param {ClientRect} clientRect - The client rectangle.\r\n     * @param {boolean} isReactCallback - Indicates whether a React callback is being used.\r\n     * @returns {void}\r\n     */\r\n    AccumulationDataLabel.prototype.calculateLabelSize = function (isTemplate, childElement, point, points, argsData, datalabelGroup, id, dataLabel, redraw, clientRect, isReactCallback) {\r\n        this.calculateLabelCollection(point, dataLabel);\r\n        var textSize = isTemplate ? (isReactCallback ? { width: clientRect.width, height: clientRect.height } :\r\n            this.getTemplateSize(childElement, point, argsData, redraw, isTemplate, points, datalabelGroup, id, dataLabel)) : this.getTextSize(point.labelCollection, dataLabel);\r\n        textSize.height += 4; // 4 for calculation with padding for smart label shape\r\n        textSize.width += 4;\r\n        point.textSize = textSize;\r\n        point.templateElement = childElement;\r\n        this.getDataLabelPosition(point, dataLabel, textSize, points);\r\n        if (point.labelRegion) {\r\n            this.correctLabelRegion(point.labelRegion, point.textSize);\r\n        }\r\n    };\r\n    /**\r\n     * To draw a data label.\r\n     *\r\n     * @param {AccumulationSeries} series - The series associated with the data label.\r\n     * @param {AccumulationDataLabelSettingsModel} dataLabel - The settings for the data labels.\r\n     * @param {HTMLElement} parent - The parent element of the data labels.\r\n     * @param {HTMLElement} templateElement - The template element for the data label.\r\n     * @param {boolean} redraw - Indicates whether the data labels are being redrawn.\r\n     * @returns {void}\r\n     * @private\r\n     */\r\n    AccumulationDataLabel.prototype.drawDataLabels = function (series, dataLabel, parent, templateElement, redraw) {\r\n        var angle;\r\n        var degree;\r\n        var modifiedPoints = series.leftSidePoints.concat(series.rightSidePoints);\r\n        modifiedPoints.sort(function (a, b) { return a.index - b.index; });\r\n        if (series.type === 'Pie' && this.accumulation.enableSmartLabels) {\r\n            this.extendedLabelsCalculation();\r\n        }\r\n        for (var _i = 0, modifiedPoints_1 = modifiedPoints; _i < modifiedPoints_1.length; _i++) {\r\n            var point = modifiedPoints_1[_i];\r\n            if (!isNullOrUndefined(point.argsData) && !isNullOrUndefined(point.y)) {\r\n                this.finalizeDatalabels(point, modifiedPoints, dataLabel);\r\n                var id = this.accumulation.element.id + '_datalabel_Series_' + 0 + '_';\r\n                var datalabelGroup = this.accumulation.renderer.createGroup({ id: id + 'g_' + point.index });\r\n                datalabelGroup.setAttribute('aria-hidden', 'true');\r\n                var dataLabelElement = void 0;\r\n                var location_3 = void 0;\r\n                var element = void 0;\r\n                if (point.visible && point.labelVisible) {\r\n                    angle = degree = dataLabel.angle;\r\n                    if (point.argsData.template) {\r\n                        this.setTemplateStyle(point.templateElement, point, templateElement, dataLabel.font.color, point.color, redraw);\r\n                    }\r\n                    else {\r\n                        location_3 = new ChartLocation(point.labelRegion.x + this.marginValue, point.labelRegion.y\r\n                            + (point.textSize.height * 3 / (point.labelCollection.length * 4)) + this.marginValue);\r\n                        element = getElement(id + 'shape_' + point.index);\r\n                        var startLocation = element ? new ChartLocation(+element.getAttribute('x'), +element.getAttribute('y')) : null;\r\n                        var textWidth = point.textSize.width;\r\n                        if (dataLabel.enableRotation) {\r\n                            if (angle === 0) {\r\n                                if (point.labelPosition === 'Outside') {\r\n                                    degree = 0;\r\n                                }\r\n                                else if (point.midAngle >= 90 && point.midAngle <= 260) {\r\n                                    degree = point.midAngle + 180;\r\n                                }\r\n                                else {\r\n                                    degree = point.midAngle;\r\n                                }\r\n                            }\r\n                            else {\r\n                                degree = (angle > 360) ? angle - 360 : (angle < -360) ? angle + 360 : angle;\r\n                            }\r\n                        }\r\n                        else {\r\n                            degree = 0;\r\n                        }\r\n                        var rotate = 'rotate(' + degree + ',' + (location_3.x + (textWidth / 2)) + ',' + (location_3.y) + ')';\r\n                        point.transform = rotate;\r\n                        dataLabelElement = this.accumulation.renderer.drawRectangle(new RectOption(id + 'shape_' + point.index, point.argsData.color, point.argsData.border, 1, point.labelRegion, dataLabel.rx, dataLabel.ry, rotate, series.dataLabel.border.dashArray));\r\n                        appendChildElement(false, datalabelGroup, dataLabelElement, redraw, true, 'x', 'y', startLocation, null, false, false, null, this.accumulation.duration);\r\n                        textElement(this.accumulation.renderer, new TextOption(id + 'text_' + point.index, location_3.x, location_3.y, this.accumulation.enableRtl ? 'end' : 'start', point.labelCollection, rotate, 'auto', degree), point.argsData.font, point.argsData.font.color || this.getSaturatedColor(point, point.argsData.color), datalabelGroup, false, redraw, true, false, this.accumulation.duration, null, null, null, null, true, this.accumulation.themeStyle.datalabelFont);\r\n                        element = null;\r\n                    }\r\n                    if (this.accumulation.accumulationLegendModule && this.accumulation.legendSettings.visible && (dataLabel.position === 'Outside'\r\n                        || this.accumulation.enableSmartLabels)) {\r\n                        this.accumulation.visibleSeries[0].findMaxBounds(this.accumulation.visibleSeries[0].labelBound, point.labelRegion);\r\n                    }\r\n                    if (point.labelPosition === 'Outside') {\r\n                        var element_1 = getElement(id + 'connector_' + point.index);\r\n                        var previousDirection = element_1 ? element_1.getAttribute('d') : '';\r\n                        var pathElement = this.accumulation.renderer.drawPath(new PathOption(id + 'connector_' + point.index, 'transparent', dataLabel.connectorStyle.width, dataLabel.connectorStyle.color || point.color, 1, dataLabel.connectorStyle.dashArray, this.getConnectorPath(extend({}, point.labelRegion, null, true), point, dataLabel, point.labelAngle)));\r\n                        appendChildElement(false, datalabelGroup, pathElement, redraw, true, null, null, null, previousDirection, false, false, null, this.accumulation.duration);\r\n                    }\r\n                    appendChildElement(false, parent, datalabelGroup, redraw);\r\n                }\r\n            }\r\n        }\r\n        if (this.accumulation.type === 'Pie' && dataLabel.textWrap === 'Normal' && dataLabel.textOverflow === 'Clip') {\r\n            this.dataLabelClipPath(dataLabel, parent);\r\n        }\r\n    };\r\n    /**\r\n     * To calculate data label clip path.\r\n     *\r\n     * @param {AccumulationDataLabelSettingsModel} dataLabel - The settings for the data labels.\r\n     * @param {HTMLElement} parent - The parent element of the data labels.\r\n     * @returns {void}\r\n     */\r\n    AccumulationDataLabel.prototype.dataLabelClipPath = function (dataLabel, parent) {\r\n        var id = this.accumulation.element.id + '_datalabel_Series_' + 0 + '_';\r\n        var clippath = this.accumulation.renderer.createClipPath({ id: id + 'clipPath' });\r\n        var clipRect;\r\n        var radius = this.accumulation.pieSeriesModule.pieBaseRadius;\r\n        if (dataLabel.position === 'Inside') {\r\n            clipRect = this.accumulation.renderer.drawCircle(new CircleOption(id + 'clipPath_rect', 'transparent', { width: 0 }, 0, this.center.x, this.center.y, radius));\r\n        }\r\n        else if (dataLabel.maxWidth) {\r\n            var x = this.center.x - radius - stringToNumber((dataLabel.connectorStyle.length || '4%'), radius) - dataLabel.maxWidth;\r\n            var y = this.center.y - radius - stringToNumber((dataLabel.connectorStyle.length || '4%'), radius) - dataLabel.maxWidth;\r\n            var height = (radius + stringToNumber((dataLabel.connectorStyle.length || '4%'), radius) + dataLabel.maxWidth) * 2;\r\n            var width = height;\r\n            if (this.accumulation.legendSettings.visible) {\r\n                var legendModule = this.accumulation.accumulationLegendModule;\r\n                if (legendModule.position === 'Left') {\r\n                    width = (legendModule.legendBounds.x + legendModule.legendBounds.width - x) > 0 ?\r\n                        (width - (legendModule.legendBounds.width - x)) : width;\r\n                    x = (legendModule.legendBounds.x + legendModule.legendBounds.width) < x ? x :\r\n                        (legendModule.legendBounds.x + legendModule.legendBounds.width);\r\n                }\r\n                else if (legendModule.position === 'Right') {\r\n                    width = (x + width - legendModule.legendBounds.x) > 0 ? (width - (x + width - legendModule.legendBounds.x)) : width;\r\n                }\r\n            }\r\n            clipRect = this.accumulation.renderer.drawRectangle(new RectOption(id + 'clipPath_rect', 'transparent', { width: 0 }, 0, new Rect(x, y, height, width), 0, 0));\r\n        }\r\n        if (dataLabel.position === 'Inside' || dataLabel.maxWidth) {\r\n            clippath.appendChild(clipRect);\r\n            appendChildElement(false, this.accumulation.svgObject, clippath);\r\n            parent.style.cssText = 'clip-path:url(#' + clippath.id + ')';\r\n        }\r\n    };\r\n    /**\r\n     * In this method datalabels region checked with legebdBounds and areaBounds.\r\n     * Trimming of datalabel and point's visibility again changed here.\r\n     *\r\n     * @param {AccPoints} point - Current point in which trimming and visibility to be checked.\r\n     * @param {AccPoints[]} points - Finalized points.\r\n     * @param {AccumulationDataLabelSettingsModel} dataLabel - Datalabel model.\r\n     * @returns {void}\r\n     */\r\n    AccumulationDataLabel.prototype.finalizeDatalabels = function (point, points, dataLabel) {\r\n        if (this.isOverlapping(point, points) ||\r\n            (this.titleRect && point.labelRegion && isOverlap(point.labelRegion, this.titleRect))) {\r\n            if (this.isCircular() && point.labelPosition === 'Outside' && this.accumulation.enableSmartLabels) {\r\n                this.setPointVisibileFalse(point);\r\n            }\r\n        }\r\n        if (this.accumulation.accumulationLegendModule && this.accumulation.legendSettings.visible &&\r\n            point.labelVisible && point.labelRegion && (!dataLabel.maxWidth ? dataLabel.textOverflow === 'Clip' ? dataLabel.textWrap !== 'Normal' : true : false)) {\r\n            var rect = this.accumulation.accumulationLegendModule.legendBounds;\r\n            if (this.accumulation.visibleSeries[0].type !== 'Pie' && this.accumulation.legendSettings.position === 'Left'\r\n                && dataLabel.position === 'Outside') {\r\n                point.labelRegion.x = point.labelRegion.x + rect.width;\r\n            }\r\n            var padding = this.accumulation.legendSettings.border.width / 2;\r\n            this.textTrimming(point, new Rect(rect.x - padding, rect.y - padding, rect.width + (2 * padding), rect.height + (2 * padding)), dataLabel.font, this.accumulation.accumulationLegendModule.position, dataLabel);\r\n        }\r\n        if (point.labelVisible && point.labelRegion && (!dataLabel.maxWidth ? dataLabel.textOverflow === 'Clip' ? dataLabel.textWrap !== 'Normal' : true : false)) {\r\n            var position = this.isCircular() ? (point.labelRegion.x >= this.center.x) ? 'InsideRight' : 'InsideLeft' :\r\n                (point.labelRegion.x >= point.region.x) ? 'InsideRight' : 'InsideLeft';\r\n            this.textTrimming(point, this.areaRect, dataLabel.font, position, dataLabel);\r\n        }\r\n        if (point.labelVisible && point.labelRegion && !dataLabel.maxWidth && dataLabel.textOverflow !== 'Clip' && this.accumulation.enableSmartLabels && ((point.labelRegion.y + point.labelRegion.height / 2 >\r\n            this.areaRect.y + this.areaRect.height || point.labelRegion.y < this.areaRect.y) || (point.labelRegion.x < this.areaRect.x ||\r\n            point.labelRegion.x + point.labelRegion.width > this.areaRect.x + this.areaRect.width))) {\r\n            this.setPointVisibileFalse(point);\r\n        }\r\n    };\r\n    /**\r\n     * To find the template element size.\r\n     *\r\n     * @param {HTMLElement} element - To get a template element.\r\n     * @param {AccPoints} point - The accumulation point for the template.\r\n     * @param {IAccTextRenderEventArgs} argsData - The arguments for the accumulation points.\r\n     * @param {boolean} redraw - Indicates whether to redraw the template.\r\n     * @param {boolean} isTemplate - Indicates whether the element is a template.\r\n     * @param {AccPoints[]} points - The accumulation points for the template.\r\n     * @param {Element} datalabelGroup - The group element for the data labels.\r\n     * @param {string} id - The identifier for the template.\r\n     * @param {AccumulationDataLabelSettingsModel} dataLabel - The settings for the data labels.\r\n     * @returns {Size} - The size of the template.\r\n     */\r\n    AccumulationDataLabel.prototype.getTemplateSize = function (element, point, argsData, redraw, isTemplate, points, datalabelGroup, id, dataLabel) {\r\n        element = createTemplate(element, point.index, argsData.template, this.accumulation, point, this.accumulation.visibleSeries[0], this.accumulation.element.id + '_DataLabel', 0, argsData, isTemplate, points, datalabelGroup, id, dataLabel, redraw);\r\n        var clientRect = measureElementRect(element, redraw);\r\n        return { width: clientRect.width, height: clientRect.height };\r\n    };\r\n    /**\r\n     * To set the template element style.\r\n     *\r\n     * @param {HTMLElement} childElement - The child element of the template.\r\n     * @param {AccPoints} point - The point data for the template.\r\n     * @param {Element} parent - The parent element of the template.\r\n     * @param {string} labelColor - The color of the label in the template.\r\n     * @param {string} fill - The fill color of the template.\r\n     * @param {boolean} redraw - Indicates whether to redraw the template.\r\n     * @returns {void}\r\n     */\r\n    AccumulationDataLabel.prototype.setTemplateStyle = function (childElement, point, parent, labelColor, fill, redraw) {\r\n        childElement.style.left = (point.labelRegion.x) + 'px';\r\n        childElement.style.top = (point.labelRegion.y) + 'px';\r\n        childElement.style.color = labelColor || this.getSaturatedColor(point, point.labelPosition === 'Inside' ? fill : this.getLabelBackground(point));\r\n        if (this.accumulation.isBlazor) {\r\n            var position = this.isCircular() ? (point.labelRegion.x >= this.center.x) ? 'InsideRight' : 'InsideLeft' :\r\n                (point.labelRegion.x >= point.region.x) ? 'InsideRight' : 'InsideLeft';\r\n            if (position === 'InsideRight') {\r\n                childElement.style.transform = 'translate(0%, -50%)';\r\n            }\r\n            else {\r\n                childElement.style.transform = 'translate(-100%, -50%)';\r\n            }\r\n        }\r\n        if (childElement.childElementCount) {\r\n            appendChildElement(false, parent, childElement, redraw, true, 'left', 'top');\r\n            this.doTemplateAnimation(this.accumulation, childElement);\r\n        }\r\n    };\r\n    /**\r\n     * To find saturated color for datalabel\r\n     *\r\n     * @param {AccPoints} point - The accumulation point.\r\n     * @param {string} color - The original color.\r\n     * @returns {string} - Get a saturated color.\r\n     */\r\n    AccumulationDataLabel.prototype.getSaturatedColor = function (point, color) {\r\n        var saturatedColor;\r\n        if (this.marginValue >= 1) {\r\n            saturatedColor = color === 'transparent' ? this.getLabelBackground(point) : color;\r\n        }\r\n        else {\r\n            saturatedColor = this.getLabelBackground(point);\r\n        }\r\n        saturatedColor = (saturatedColor === 'transparent') ? ((this.accumulation.theme.indexOf('Dark') > -1 || this.accumulation.theme.indexOf('HighContrast') > -1) ? 'black' : 'white') : saturatedColor;\r\n        var rgbValue = convertHexToColor(colorNameToHex(saturatedColor));\r\n        var contrast = Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000);\r\n        return contrast >= 128 ? 'black' : 'white';\r\n    };\r\n    /**\r\n     * Animates the data label template.\r\n     *\r\n     * @param {AccumulationChart} accumulation - The accumulation chart control.\r\n     * @param {Element} element - The element to animate.\r\n     * @returns {void}\r\n     * @private\r\n     */\r\n    AccumulationDataLabel.prototype.doTemplateAnimation = function (accumulation, element) {\r\n        var series = accumulation.visibleSeries[0];\r\n        var delay = series.animation.delay + series.animation.duration;\r\n        if (((series.animation.enable && animationMode !== 'Disable') || animationMode === 'Enable') && accumulation.animateSeries) {\r\n            element.style.visibility = 'hidden';\r\n            templateAnimate(element, delay, 200, 'ZoomIn');\r\n        }\r\n    };\r\n    /**\r\n     * To find background color for the datalabel.\r\n     *\r\n     * @param {AccPoints} point - The data point for which to determine the background color.\r\n     * @returns {string} - The background color for the data label.\r\n     */\r\n    AccumulationDataLabel.prototype.getLabelBackground = function (point) {\r\n        return point.labelPosition === 'Outside' ?\r\n            this.accumulation.background || this.accumulation.themeStyle.background : !point.y ? this.accumulation.theme.indexOf('dark') ? 'white' : 'black' : point.color;\r\n    };\r\n    /**\r\n     * To correct the padding between datalabel regions.\r\n     *\r\n     * @param {Rect} labelRegion - The region occupied by the data label.\r\n     * @param {Size} textSize - The size of the text within the data label.\r\n     * @param {number} padding - The padding value to adjust the spacing.\r\n     * @returns {void}\r\n     */\r\n    AccumulationDataLabel.prototype.correctLabelRegion = function (labelRegion, textSize, padding) {\r\n        if (padding === void 0) { padding = 4; }\r\n        labelRegion.height -= padding;\r\n        labelRegion.width -= padding;\r\n        labelRegion.x += padding / 2;\r\n        labelRegion.y += padding / 2;\r\n        textSize.height -= padding;\r\n        textSize.width -= padding;\r\n    };\r\n    /**\r\n     * To get the dataLabel module name.\r\n     *\r\n     * @returns {string} - Returns the module name.\r\n     */\r\n    AccumulationDataLabel.prototype.getModuleName = function () {\r\n        return 'AccumulationDataLabel';\r\n    };\r\n    /**\r\n     * To destroy the data label.\r\n     *\r\n     * @returns {void}\r\n     * @private\r\n     */\r\n    AccumulationDataLabel.prototype.destroy = function () {\r\n        /**\r\n         * Destroy method performed here.\r\n         */\r\n    };\r\n    //calculation for placing labels smartly\r\n    AccumulationDataLabel.prototype.extendedLabelsCalculation = function () {\r\n        var _this = this;\r\n        var series = this.accumulation.series[0];\r\n        series.rightSidePoints.forEach(function (point, index, halfSidePoints) {\r\n            point.initialLabelRegion = point.labelRegion;\r\n            point.isLabelUpdated = 0;\r\n            _this.skipPoints(point, halfSidePoints, index);\r\n        });\r\n        series.leftSidePoints.forEach(function (point, index, halfSidePoints) {\r\n            point.initialLabelRegion = point.labelRegion;\r\n            point.isLabelUpdated = 0;\r\n            _this.skipPoints(point, halfSidePoints, index);\r\n        });\r\n        this.arrangeLeftSidePoints(series);\r\n        this.isIncreaseAngle = false;\r\n        this.arrangeRightSidePoints(series);\r\n    };\r\n    /**\r\n     * Rightside points alignments calculation.\r\n     *\r\n     * @param {AccumulationSeries} series - To get a proper series.\r\n     * @returns {void}\r\n     */\r\n    AccumulationDataLabel.prototype.arrangeRightSidePoints = function (series) {\r\n        var startFresh;\r\n        var angleChanged;\r\n        var rightSideRenderPoints = series.rightSidePoints.filter(function (point) { return (point.labelVisible && point.labelPosition === 'Outside'); });\r\n        this.rightSideRenderingPoints = rightSideRenderPoints;\r\n        var checkAngle;\r\n        var currentPoint;\r\n        var lastPoint = rightSideRenderPoints[rightSideRenderPoints.length - 1];\r\n        var nextPoint;\r\n        if (lastPoint) {\r\n            if (lastPoint.labelAngle > 90 && lastPoint.labelAngle < 270) {\r\n                this.isIncreaseAngle = true;\r\n                this.changeLabelAngle(lastPoint, 89);\r\n            }\r\n        }\r\n        /**\r\n         * Right side points arranged from last point.\r\n         * A point checked with successive points for overlapping.\r\n         * If that is overlapped, its label angle is decreased and placing in optimal position\r\n         * If one point's angle is decreased, its previous points in the half side points also decreased until it reaced optimum position.\r\n         * When decreasing angle falls beyond 270, label angle increased.\r\n         * If one point's angle is increased, its successive points in that half point also increased until it reaced optimum position.\r\n         */\r\n        for (var i = rightSideRenderPoints.length - 1; i >= 0; i--) {\r\n            currentPoint = rightSideRenderPoints[i];\r\n            nextPoint = rightSideRenderPoints[i + 1];\r\n            // A point checked for overlapping, label visibility\r\n            if (this.isOverlapWithNext(currentPoint, rightSideRenderPoints, i) && currentPoint.labelVisible\r\n                || !(currentPoint.labelAngle <= 90 || currentPoint.labelAngle >= 270)) {\r\n                checkAngle = lastPoint.labelAngle + 10;\r\n                angleChanged = true;\r\n                //If last's point change angle in beyond the limit, stop the increasing angle and do decrease the angle.\r\n                if (startFresh) {\r\n                    this.isIncreaseAngle = false;\r\n                }\r\n                else if (checkAngle > 90 && checkAngle < 270 && nextPoint.isLabelUpdated) {\r\n                    this.isIncreaseAngle = true;\r\n                }\r\n                if (!this.isIncreaseAngle) {\r\n                    for (var k = i + 1; k < rightSideRenderPoints.length; k++) {\r\n                        this.increaseAngle(rightSideRenderPoints[k - 1], rightSideRenderPoints[k], series, true);\r\n                    }\r\n                }\r\n                else {\r\n                    for (var k = i + 1; k > 0; k--) {\r\n                        this.decreaseAngle(rightSideRenderPoints[k], rightSideRenderPoints[k - 1], series, true);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                //If a point did not overlapped with previous points, increase the angle always for right side points.\r\n                if (angleChanged && nextPoint && !nextPoint.isLabelUpdated) {\r\n                    startFresh = true;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Leftside points alignments calculation.\r\n     *\r\n     * @param {AccumulationSeries} series - To get a proper series.\r\n     * @returns {void}\r\n     */\r\n    AccumulationDataLabel.prototype.arrangeLeftSidePoints = function (series) {\r\n        var _this = this;\r\n        var leftSideRenderPoints = series.leftSidePoints.filter(function (point) { return (point.labelVisible && point.labelPosition === 'Outside'); });\r\n        this.leftSideRenderingPoints = leftSideRenderPoints;\r\n        var previousPoint;\r\n        var currentPoint;\r\n        var angleChanged;\r\n        var startFresh;\r\n        /**\r\n         * Left side points arranged from first point.\r\n         * A point checked with previous points for overlapping.\r\n         * If that is overlapped, its label angle is decreased and placing in optimal position\r\n         * If one point's angle is decreased, its previous points in the half side points also decreased until it reaced optimum position.\r\n         * When decreasing angle falls beyond 90, label angle increased.\r\n         * If one point's angle is increased, its successive points in that half point also increased until it reaced optimum position.\r\n         */\r\n        for (var i = 0; i < leftSideRenderPoints.length; i++) {\r\n            currentPoint = leftSideRenderPoints[i];\r\n            previousPoint = leftSideRenderPoints[i - 1];\r\n            // A point checked\r\n            if (this.isOverlapWithPrevious(currentPoint, leftSideRenderPoints, i) && currentPoint.labelVisible\r\n                || !(currentPoint.labelAngle < 270)) {\r\n                angleChanged = true;\r\n                if (startFresh) {\r\n                    this.isIncreaseAngle = false;\r\n                }\r\n                if (!this.isIncreaseAngle) {\r\n                    for (var k = i; k > 0; k--) {\r\n                        this.decreaseAngle(leftSideRenderPoints[k], leftSideRenderPoints[k - 1], series, false);\r\n                        leftSideRenderPoints.filter(function (point, index) {\r\n                            if (point.isLabelUpdated && leftSideRenderPoints[index].labelAngle - 10 < 100) {\r\n                                _this.isIncreaseAngle = true;\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n                else {\r\n                    for (var k = i; k < leftSideRenderPoints.length; k++) {\r\n                        this.increaseAngle(leftSideRenderPoints[k - 1], leftSideRenderPoints[k], series, false);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (angleChanged && previousPoint && previousPoint.isLabelUpdated) {\r\n                    startFresh = true;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    AccumulationDataLabel.prototype.decreaseAngle = function (currentPoint, previousPoint, series, isRightSide) {\r\n        if (isNullOrUndefined(currentPoint) || isNullOrUndefined(previousPoint)) {\r\n            return null;\r\n        }\r\n        var count = 1;\r\n        if (isRightSide) {\r\n            while (isOverlap(currentPoint.labelRegion, previousPoint.labelRegion) || (!this.isVariousRadius() &&\r\n                !((previousPoint.labelRegion.height + previousPoint.labelRegion.y) < currentPoint.labelRegion.y))) {\r\n                var newAngle = previousPoint.midAngle - count;\r\n                if (newAngle < 0) {\r\n                    newAngle = 360 + newAngle;\r\n                }\r\n                if (newAngle <= 270 && newAngle >= 90) {\r\n                    newAngle = 270;\r\n                    this.isIncreaseAngle = true;\r\n                    break;\r\n                }\r\n                this.changeLabelAngle(previousPoint, newAngle);\r\n                count++;\r\n            }\r\n        }\r\n        else {\r\n            if (currentPoint.labelAngle > 270) {\r\n                this.changeLabelAngle(currentPoint, 270);\r\n                previousPoint.labelAngle = 270;\r\n            }\r\n            while (isOverlap(currentPoint.labelRegion, previousPoint.labelRegion) || (!this.isVariousRadius() &&\r\n                ((currentPoint.labelRegion.y + currentPoint.labelRegion.height) > previousPoint.labelRegion.y))) {\r\n                var newAngle = previousPoint.midAngle - count;\r\n                if (!(newAngle <= 270 && newAngle >= 90)) {\r\n                    newAngle = 90;\r\n                    this.isIncreaseAngle = true;\r\n                    break;\r\n                }\r\n                this.changeLabelAngle(previousPoint, newAngle);\r\n                if (isOverlap(currentPoint.labelRegion, previousPoint.labelRegion) &&\r\n                    !series.leftSidePoints.indexOf(previousPoint) && (newAngle - 1 < 90 && newAngle - 1 > 270)) {\r\n                    this.changeLabelAngle(currentPoint, currentPoint.labelAngle + 1);\r\n                    this.arrangeLeftSidePoints(series);\r\n                    break;\r\n                }\r\n                count++;\r\n            }\r\n        }\r\n    };\r\n    AccumulationDataLabel.prototype.increaseAngle = function (currentPoint, nextPoint, series, isRightSide) {\r\n        if (isNullOrUndefined(currentPoint) || isNullOrUndefined(nextPoint)) {\r\n            return null;\r\n        }\r\n        var count = 1;\r\n        if (isRightSide) {\r\n            while (isOverlap(currentPoint.labelRegion, nextPoint.labelRegion) || (!this.isVariousRadius() &&\r\n                !((currentPoint.labelRegion.y + currentPoint.labelRegion.height) < nextPoint.labelRegion.y))) {\r\n                var newAngle = nextPoint.midAngle + count;\r\n                if (newAngle < 270 && newAngle > 90) {\r\n                    newAngle = 90;\r\n                    this.isIncreaseAngle = true;\r\n                    break;\r\n                }\r\n                this.changeLabelAngle(nextPoint, newAngle);\r\n                if (isOverlap(currentPoint.labelRegion, nextPoint.labelRegion) && (newAngle + 1 > 90 && newAngle + 1 < 270) &&\r\n                    this.rightSideRenderingPoints.indexOf(nextPoint) === this.rightSideRenderingPoints.length - 1) {\r\n                    this.changeLabelAngle(currentPoint, currentPoint.labelAngle - 1);\r\n                    nextPoint.labelRegion = nextPoint.initialLabelRegion;\r\n                    this.arrangeRightSidePoints(series);\r\n                    break;\r\n                }\r\n                if (count > 360) {\r\n                    break;\r\n                }\r\n                count++;\r\n            }\r\n        }\r\n        else {\r\n            while (isOverlap(currentPoint.labelRegion, nextPoint.labelRegion) || (!this.isVariousRadius() &&\r\n                (currentPoint.labelRegion.y < (nextPoint.labelRegion.y + nextPoint.labelRegion.height)))) {\r\n                var newAngle = nextPoint.midAngle + count;\r\n                if (!(newAngle < 270 && newAngle > 90)) {\r\n                    newAngle = 270;\r\n                    this.isIncreaseAngle = false;\r\n                    break;\r\n                }\r\n                this.changeLabelAngle(nextPoint, newAngle);\r\n                if (count > 360) {\r\n                    break;\r\n                }\r\n                count++;\r\n            }\r\n        }\r\n    };\r\n    AccumulationDataLabel.prototype.changeLabelAngle = function (currentPoint, newAngle) {\r\n        var dataLabel = this.accumulation.series[0].dataLabel;\r\n        var variableR;\r\n        if (this.isVariousRadius()) {\r\n            variableR = this.accumulation.pieSeriesModule.getLabelRadius(this.accumulation.visibleSeries[0], currentPoint);\r\n        }\r\n        //padding 10px is added to label radius for increasing the angle and avoid congestion.\r\n        var labelRadius = (currentPoint.labelPosition === 'Outside' && this.accumulation.enableSmartLabels &&\r\n            dataLabel.position === 'Inside') ?\r\n            this.radius + stringToNumber(dataLabel.connectorStyle.length || '4%', this.accumulation.pieSeriesModule.size / 2) :\r\n            (!this.isVariousRadius() ? this.accumulation.pieSeriesModule.labelRadius + 10 : variableR);\r\n        var radius = (!this.isVariousRadius() ? labelRadius : variableR);\r\n        this.getLabelRegion(currentPoint, 'Outside', currentPoint.textSize, radius, this.marginValue, newAngle);\r\n        currentPoint.isLabelUpdated = 1;\r\n        currentPoint.labelAngle = newAngle;\r\n    };\r\n    AccumulationDataLabel.prototype.isOverlapWithPrevious = function (currentPoint, points, currentPointIndex) {\r\n        for (var i = 0; i < currentPointIndex; i++) {\r\n            if (i !== points.indexOf(currentPoint) &&\r\n                points[i].visible && points[i].labelVisible &&\r\n                points[i].labelRegion && currentPoint.labelRegion &&\r\n                currentPoint.labelVisible && isOverlap(currentPoint.labelRegion, points[i].labelRegion)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    AccumulationDataLabel.prototype.isOverlapWithNext = function (point, points, pointIndex) {\r\n        for (var i = pointIndex; i < points.length; i++) {\r\n            if (i !== points.indexOf(point) && points[i].visible &&\r\n                points[i].labelVisible && points[i].labelRegion &&\r\n                point.labelRegion && point.labelVisible && isOverlap(point.labelRegion, points[i].labelRegion)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    AccumulationDataLabel.prototype.skipPoints = function (currentPoint, halfsidePoints, pointIndex) {\r\n        if (pointIndex > 0 && ((currentPoint.midAngle < 285 && currentPoint.midAngle > 255) ||\r\n            (currentPoint.midAngle < 105 && currentPoint.midAngle > 75))) {\r\n            var previousPoint = halfsidePoints[pointIndex - 1];\r\n            var angleDiff = currentPoint.endAngle % 360 - currentPoint.startAngle % 360;\r\n            var prevAngleDiff = previousPoint.endAngle % 360 - previousPoint.startAngle % 360;\r\n            if (prevAngleDiff <= angleDiff && angleDiff < 5 && previousPoint.labelVisible) {\r\n                this.setPointVisibleTrue(currentPoint);\r\n            }\r\n        }\r\n        else if (pointIndex > 1 && ((currentPoint.midAngle < 300 && currentPoint.midAngle > 240) ||\r\n            (currentPoint.midAngle < 120 && currentPoint.midAngle > 60))) {\r\n            var prevPoint = halfsidePoints[pointIndex - 1];\r\n            var secondPrevPoint = halfsidePoints[pointIndex - 2];\r\n            var angleDiff = currentPoint.endAngle % 360 - currentPoint.startAngle % 360;\r\n            var prevAngleDiff = prevPoint.endAngle % 360 - prevPoint.startAngle % 360;\r\n            var thirdAngleDiff = secondPrevPoint.endAngle % 360 - secondPrevPoint.startAngle % 360;\r\n            if (angleDiff < 3 && prevAngleDiff < 3 && thirdAngleDiff < 3 && prevPoint.labelVisible && currentPoint.labelVisible) {\r\n                this.setPointVisibleTrue(currentPoint);\r\n            }\r\n        }\r\n    };\r\n    AccumulationDataLabel.prototype.getPerpendicularDistance = function (startPoint, point) {\r\n        var increasedLocation;\r\n        var add = 10;\r\n        var height = add + 10 * Math.sin(point.midAngle * Math.PI / 360);\r\n        if (point.midAngle > 270 && point.midAngle < 360) {\r\n            increasedLocation = new ChartLocation(startPoint.x + height * (Math.cos((360 - point.midAngle) * Math.PI / 180)), startPoint.y - height * (Math.sin((360 - point.midAngle) * Math.PI / 180)));\r\n        }\r\n        else if (point.midAngle > 0 && point.midAngle < 90) {\r\n            increasedLocation = new ChartLocation(startPoint.x + height * (Math.cos((point.midAngle) * Math.PI / 180)), startPoint.y + height * (Math.sin((point.midAngle) * Math.PI / 180)));\r\n            // eslint-disable-next-line no-dupe-else-if\r\n        }\r\n        else if (point.midAngle > 0 && point.midAngle < 90) {\r\n            increasedLocation = new ChartLocation(startPoint.x - height * (Math.cos((point.midAngle - 90) * Math.PI / 180)), startPoint.y + height * (Math.sin((point.midAngle - 90) * Math.PI / 180)));\r\n        }\r\n        else {\r\n            increasedLocation = new ChartLocation(startPoint.x - height * (Math.cos((point.midAngle - 180) * Math.PI / 180)), startPoint.y - height * (Math.sin((point.midAngle - 180) * Math.PI / 180)));\r\n        }\r\n        return increasedLocation;\r\n    };\r\n    return AccumulationDataLabel;\r\n}(AccumulationBase));\r\nexport { AccumulationDataLabel };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}